<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Github+Hexo+Volantis个人主页个性化搭建（进阶版）</title>
      <link href="/2024/01/03/Website-Building-Tutotrials-Futher/"/>
      <url>/2024/01/03/Website-Building-Tutotrials-Futher/</url>
      
        <content type="html"><![CDATA[<p>本篇文章为在第一篇搭建了基础的个人主页基础上，对主页进行个性化的修改和信息填充的过程记录。</p><span id="more"></span><p>前置教程：</p><div class="tag link"><a class="link-card" title="Github+Hexo+Volantis个人主页搭建流程" href="https://yaelcassini.github.io/2022/06/08/Website-Building-Tutorials/"><div class="left"><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/blog/logo_256.png"/></div><div class="right"><p class="text">Github+Hexo+Volantis个人主页搭建流程</p><p class="url">https://yaelcassini.github.io/2022/06/08/Website-Building-Tutorials/</p></div></a></div><h2 id="制作网站icon"><a href="#制作网站icon" class="headerlink" title="制作网站icon"></a>制作网站icon</h2><p>可以在网上找一个自己喜欢的图案，最好简单一点，我用的是一个小狐狸头，然后可以直接搜索在线转换，把jpg或者png格式的图片转化成ico格式，就可以作为网站的icon了，也是先上传到图床，然后用链接调用。</p><h2 id="制作自己的个人头像"><a href="#制作自己的个人头像" class="headerlink" title="制作自己的个人头像"></a>制作自己的个人头像</h2><p>可以在网上找一张图片，上传到图床，后面会作为在主页的个人头像出现在侧边栏。</p><h2 id="配置个人主页Title"><a href="#配置个人主页Title" class="headerlink" title="配置个人主页Title"></a>配置个人主页Title</h2><ol><li>我给自己的主页起名叫<strong>不知岛</strong>，英文<strong>Unknown Island</strong>。</li><li>配置<code>_config.yml</code>，这部分代码包括title、subtitle、description、author、favicon的配置。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># Site</span><br><span class="line">title: Unknown Island</span><br><span class="line">subtitle: &#x27;Cassini’s Blog&#x27;</span><br><span class="line">description: &#x27;赛博垃圾分离企划&#x27;</span><br><span class="line">keywords:</span><br><span class="line">author: Cassini</span><br><span class="line">language:</span><br><span class="line">  - zh-CN</span><br><span class="line">  - en</span><br><span class="line">  - zh-HK</span><br><span class="line">  - zh-TW</span><br><span class="line">timezone: &#x27;&#x27;</span><br><span class="line"># 网站图标，更多尺寸等图标请使用import方式批量导入</span><br><span class="line">favicon: https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/blog/logo_64.ico</span><br></pre></td></tr></table></figure></li></ol><h2 id="配置主页封面"><a href="#配置主页封面" class="headerlink" title="配置主页封面"></a>配置主页封面</h2><p>在<code>_config.volantis.yml</code>文件中，这部分配置主要修改了title、subtitle以及features，features中是首页封面的跳转栏及其地址、icon配置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">############################### Cover ############################### &gt; start</span><br><span class="line">cover:</span><br><span class="line">  height_scheme: full # full, half</span><br><span class="line">  layout_scheme: dock # blank (留白), search (搜索), dock (坞), featured (精选), focus (焦点)</span><br><span class="line">  display:</span><br><span class="line">    home: true</span><br><span class="line">    archive: true</span><br><span class="line">    others: true # can be written in front-matter &#x27;cover: true&#x27;</span><br><span class="line">  background: # https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/blog/liuyao.jpg</span><br><span class="line">  logo: # https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/blog/logo_128_2.png</span><br><span class="line">  title: &#x27;Unknown Island&#x27;</span><br><span class="line">  subtitle: &#x27;Cassini’s Blog&#x27;</span><br><span class="line">  search: A Wonderful Theme for Hexo # search bar placeholder</span><br><span class="line">  features:</span><br><span class="line">    - name: 主页</span><br><span class="line">      icon: #</span><br><span class="line">      img: https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0.0/assets/svg/1f3d5.svg # https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0.2/assets/svg/1f3d8.svg #  https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f389.svg</span><br><span class="line">      url: /</span><br><span class="line">    - name: 分类</span><br><span class="line">      icon: #</span><br><span class="line">      img: https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0.2/assets/svg/1f4c2.svg #  https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f516.svg</span><br><span class="line">      url: categories/</span><br><span class="line">    - name: 标签</span><br><span class="line">      icon: #</span><br><span class="line">      img: https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f516.svg # volantis-static/media/twemoji/assets/svg/1f516.svg</span><br><span class="line">      url: tags/</span><br><span class="line">    - name: 归档</span><br><span class="line">      icon: #</span><br><span class="line">      img: https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f5c3.svg # volantis-static/media/twemoji/assets/svg/1f5c3.svg</span><br><span class="line">      url: /archives/</span><br><span class="line">    - name: 友链</span><br><span class="line">      icon: #</span><br><span class="line">      img: https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0.0/assets/svg/1f37b.svg # https://cdn.jsdelivr.net/gh/twitter/twemoji@14.0.2/assets/svg/1faf1-1f3fc-200d-1faf2-1f3fe.svg #  https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f389.svg</span><br><span class="line">      url: friends/</span><br><span class="line">    - name: 关于</span><br><span class="line">      icon: #</span><br><span class="line">      img: https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0.2/assets/svg/2139.svg # https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f5c3.svg</span><br><span class="line">      url: about/</span><br><span class="line">    # - name: 源码</span><br><span class="line">    #   icon: #</span><br><span class="line">    #   img: volantis-static/media/twemoji/assets/svg/1f9ec.svg #  https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f9ec.svg</span><br><span class="line">    #   url: https://github.com/YaelCassini/YaelCassini.github.io</span><br><span class="line">############################### Cover ############################### &gt; end</span><br></pre></td></tr></table></figure><h2 id="配置侧边栏"><a href="#配置侧边栏" class="headerlink" title="配置侧边栏"></a>配置侧边栏</h2><p>在<code>_config.volantis.yml</code>文件中，配置包括：</p><ul><li>position：侧边栏出现在页面左边还是右边</li><li>for_page：打开网页固有页面时（比如主页，关于页面）侧边栏显示类别，此处设置为显示博主卡片、分类卡片、标签卡片。</li><li>for_post：打开文章页面时侧边栏显示类别，此处设置为显示博主卡片、分类卡片、标签卡片。</li><li>avatar：侧边栏博主卡片的头像</li><li>social：侧边栏博主卡片下方的链接（邮箱、github等）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">############################### Sidebar ############################### &gt; start</span><br><span class="line">sidebar:</span><br><span class="line">  position: left # left right</span><br><span class="line">  # 主页、分类、归档等独立页面</span><br><span class="line">  for_page: [blogger, category, tagcloud]</span><br><span class="line">  # layout: docs/post 这类文章页面</span><br><span class="line">  for_post: [blogger, toc]</span><br><span class="line">  # 侧边栏组件库</span><br><span class="line">  widget_library:</span><br><span class="line">    # ---------------------------------------</span><br><span class="line">    # blogger info widget</span><br><span class="line">    blogger:</span><br><span class="line">      class: blogger</span><br><span class="line">      display: [desktop, mobile] # [desktop, mobile]</span><br><span class="line">      avatar: https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/blog/avatar_1024.jpg</span><br><span class="line">      shape: rectangle # circle, rectangle</span><br><span class="line">      url: about/</span><br><span class="line">      title: Yael Cassini</span><br><span class="line">      subtitle: </span><br><span class="line">      jinrishici: true # Poetry Today. You can set a string, and it will be displayed when loading fails.</span><br><span class="line">      social:</span><br><span class="line">        - icon: fa-solid fa-home</span><br><span class="line">          url: /</span><br><span class="line">        - icon: fa-solid fa-envelope</span><br><span class="line">          url: mailto:3247365200@qq.com</span><br><span class="line">        - icon: fab fa-github</span><br><span class="line">          url: https://github.com/YaelCassini</span><br><span class="line">        - icon: fa-solid fa-headphones-alt</span><br><span class="line">          url: /</span><br></pre></td></tr></table></figure></li></ul><h2 id="配置Navbar"><a href="#配置Navbar" class="headerlink" title="配置Navbar"></a>配置Navbar</h2><p>navbar是网页顶部的跳转栏，这里的配置主要有logo和menu，menu包括name、icon、url的配置，分别是显示文字，icon图标，和跳转链接。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">navbar:</span><br><span class="line">  visiable: auto # always, auto</span><br><span class="line">  logo:  # choose [img] or [icon + title]</span><br><span class="line">    img: https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/blog/logo_128_3.png</span><br><span class="line">    # icon: https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/blog/logo_256.ico</span><br><span class="line">    # title: &#x27;Unknown Island&#x27;</span><br><span class="line">  menu:</span><br><span class="line">    - name: 主页</span><br><span class="line">      icon: fa-solid fa-home</span><br><span class="line">      url: /</span><br><span class="line">    - name: 分类</span><br><span class="line">      icon: fa-solid fa-folder-open</span><br><span class="line">      url: categories/</span><br><span class="line">    - name: 标签</span><br><span class="line">      icon: fa-solid fa-tags</span><br><span class="line">      url: tags/</span><br><span class="line">    - name: 归档</span><br><span class="line">      icon: fa-solid fa-archive</span><br><span class="line">      url: archives/</span><br><span class="line">    - name: 友链</span><br><span class="line">      icon: fa-solid fa-users</span><br><span class="line">      url: friends/</span><br><span class="line">    - name: 关于</span><br><span class="line">      icon: fa-solid fa-info-circle</span><br><span class="line">      url: about/</span><br><span class="line">    - name: 暗黑模式</span><br><span class="line">      icon: fa-solid fa-moon</span><br><span class="line">      toggle: darkmode</span><br></pre></td></tr></table></figure><h2 id="配置网站轮播背景"><a href="#配置网站轮播背景" class="headerlink" title="配置网站轮播背景"></a>配置网站轮播背景</h2><p>提前找好喜欢的背景图片上传到图床，在<code>_config.volantis.yml</code>文件中的parallax标签把enable设置为true，配置images链接，duration表示轮播间隔，这里我也忘记为什么使用webp格式以及png格式行不行了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 视差滚动效果 Slide Background</span><br><span class="line">parallax:</span><br><span class="line">  enable: true</span><br><span class="line">  position: fixed       # cover: sticky on the cover.   fixed: Fixed as background for the site.</span><br><span class="line">  shuffle: true         # shuffle playlist</span><br><span class="line">  duration: 10000       # Duration (ms)</span><br><span class="line">  fade: 1500            # fade duration (ms) (Not more than 1500)</span><br><span class="line">  images:               # For personal use only. At your own risk if used for commercial purposes !!!</span><br><span class="line">    - https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/blog/background/001.webp</span><br><span class="line">    - https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/blog/background/002.webp</span><br><span class="line">    - https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/blog/background/003.webp</span><br><span class="line">    - ···</span><br></pre></td></tr></table></figure><h2 id="配置网站歌单"><a href="#配置网站歌单" class="headerlink" title="配置网站歌单"></a>配置网站歌单</h2><h3 id="1-创建歌单"><a href="#1-创建歌单" class="headerlink" title="1. 创建歌单"></a>1. 创建歌单</h3><p>在网易云或者qq音乐新建歌单，并在歌单的分享链接中摘取歌单的id编号，比如本站使用的是qq音乐，歌单编号为：8849727324。</p><h3 id="2-配置到volantis"><a href="#2-配置到volantis" class="headerlink" title="2. 配置到volantis"></a>2. 配置到volantis</h3><p>在<code>_config.volantis.yml</code>文件中的aplayer标签下配置，以本站为例，需要：</p><ul><li>把enable的值修改为true(这里我不记得默认是true还是false了)</li><li>把server的值修改为tencent</li><li>把type的值修改为playlist</li><li>把id修改为8849727324</li></ul><p>但是该方法有一个问题是不能加入vip权限的音乐，并且由于图床是部署在github上面的，有时候需要外网访问，但是歌单都是内网，有时候会出现网络代理问题。</p><h2 id="配置关于页面"><a href="#配置关于页面" class="headerlink" title="配置关于页面"></a>配置关于页面</h2><p>这部分我没有做很多设计，只简单写了一下自己的教育经历，放了一些其他平台的账号链接，不过每个平台的icon需要自己提前找好。链接格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% link Github::https://github.com/YaelCassini::https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/icon/github_rgba.png %&#125;</span><br></pre></td></tr></table></figure><ul><li>Github为链接标题</li><li>后面跟跳转链接</li><li>链接后::再跟icon链接。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Github Pages </tag>
            
            <tag> Hexo </tag>
            
            <tag> Volantis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>To-Do-Lists</title>
      <link href="/2024/01/03/To-Do-Lists/"/>
      <url>/2024/01/03/To-Do-Lists/</url>
      
        <content type="html"><![CDATA[<ol><li>音乐播放一直不行，应该是github的网络问题。</li><li>个人主页添加知乎、bilibili、小红书跳转链接。</li><li>将个人主页设置的步骤包括头像和2.中的操作更新到个人主页搭建流程。</li><li>能不能找到在网页添加语言切换的方法。</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Useful Links</title>
      <link href="/2024/01/03/Useful-Links/"/>
      <url>/2024/01/03/Useful-Links/</url>
      
        <content type="html"><![CDATA[<h4 id="Icon网站"><a href="#Icon网站" class="headerlink" title="Icon网站"></a>Icon网站</h4><ul><li><a href="https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0.0/assets/svg/">https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0.0/assets/svg/</a></li><li><a href="https://unpkg.com/browse/volantis-static@0.0.1649552113628/media/org.volantis/icon/1322024-social-media/">https://unpkg.com/browse/volantis-static@0.0.1649552113628/media/org.volantis/icon/1322024-social-media/</a></li><li><a href="https://fontawesome.com/icons?d=gallery">https://fontawesome.com/icons?d=gallery</a></li><li><a href="https://seeklogo.com/">https://seeklogo.com/</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Environment-Lighting</title>
      <link href="/2023/12/21/Environment-Lighting/"/>
      <url>/2023/12/21/Environment-Lighting/</url>
      
        <content type="html"><![CDATA[<p>Cube Maps<br>Spherical Maps<br>Equirectangular Maps</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>凹凸映射以及粗糙度贴图</title>
      <link href="/2023/11/15/Bump-Mapping-Roughness/"/>
      <url>/2023/11/15/Bump-Mapping-Roughness/</url>
      
        <content type="html"><![CDATA[<p>本文摘自笔者的本科毕业论文，是在学习研究过程中一些对凹凸映射以及粗糙度贴图的知识的整理及个人理解。</p><span id="more"></span><h3 id="凹凸映射及切向空间"><a href="#凹凸映射及切向空间" class="headerlink" title="凹凸映射及切向空间"></a>凹凸映射及切向空间</h3><p>凹凸映射（Bump Mapping）是一种通过对纹理贴图采样，扰动模型法线，从而表现出更多像素级别材质细节的技术。在渲染管线中计算片元着色时，三角形面片内部的法线最早是直接通过三个顶点的法线插值得到的。这样的方式保证了模型的平滑，但直接使用插值结果将使得我们无法表达出三角形面片内部的像素级凹凸细节，因此凹凸映射技术应运而生。凹凸映射最早使用的是高度图（Height Map），即通过采样高度图，修改片元的在模型表面的高度，因此模型表面的法线也会改变，从而影响着色，如下图。<br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202311152005.jpg" title="高度贴图作用示意图" alt="高度贴图作用示意图" width="50%"></p><p>目前行业中广泛使用的基于法线贴图（Normal Map）的Normal Mapping则是基于法线贴图的。法线贴图储存的是模型在切向空间（Tangent Space）的法线信息。切向空间（也可以称为TBN坐标系）是用来解决模型旋转或缩放造成的法线错误问题的。如果法线贴图中储存的是世界坐标下的法线，则模型的旋转和缩放等操作都会导致法线贴图错误，而切向空间可以保证法线不受模型这些变换干扰。切向空间中的Z轴取自顶点法线插值后得到的法线方向。另外两个轴则分别是模型切面上的切线方向（Tangent）和副切线方向（Bitangent），其中切线方向是模型的UV坐标中U分量增长的方向，而副切线方向则是V分量增长的方向。而法线贴图储存的数据就是该处法线相对于从顶点法线插值得到的法线的偏移量（在切向空间下），向量&lt;0,0,1&gt;代表直接使用插值得到的法线而不进行修改。<br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202311152008.jpg" title="切向空间示意图" alt="切向空间示意图" width="50%"></p><h3 id="使用高度贴图提取法线的算法实现"><a href="#使用高度贴图提取法线的算法实现" class="headerlink" title="使用高度贴图提取法线的算法实现"></a>使用高度贴图提取法线的算法实现</h3><p>Normal Map其实就是高度场的归一化梯度，因此我们可以使用Lengyel在《Mathematics for 3D Game Programming and Computer Graphics》中提到的思路：通过求解高度图梯度，在切空间构造S向量和T向量，并将其叉乘来得到法线。当沿着U和V方向高度差都为零时，模型没有高度变化，此时法线为Normal(i,j)&#x3D; &lt;0,0,1&gt;，直接使用插值得到的法线而不对其进行修改。否则，法线就会朝U或者V方向偏移。<br>设H(i,j)为高度图上(i,j)处像素的高度值，则S和T向量可以表示为：<br>$ S(i,j)&#x3D; &lt;1,0,aH(i+1,j)-aH(i-1,j)&gt; $<br>$ T(i,j)&#x3D; &lt;0,1,aH(i,j+1)-aH(i,j-1)&gt; $</p><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202311152010.jpg" title="求解S、T向量示意图" alt="求解S、T向量示意图" width="50%"><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202311152011.jpg" title="求解S、T向量示意图" alt="求解S、T向量示意图" width="50%"><p>其中，a是一个用于放缩的控制参数，其取值取决于高度图的量纲，aH(i+1,j)-aH(i-1,j)表示模型表面沿着U方向的高度差，aH(i,j+1)-aH(i,j-1)表示模型表面沿着V方向的高度差。我们使用S_z和T_z来表示两个向量的Z分量，经过推导可以得到：<br>$$ Normal(i,j)&#x3D;  \frac{S(i,j)×T(i,j)}{||S(i,j)×T(i,j)||}   &#x3D;  \frac{&lt;-S_z,-T_z,1&gt;}{√S_z^2+T_z^2+1} $$<br>通过测试比较不同方法的效果，在实践中笔者最终使用了Sobel算子，对图像进行滤波以计算图像梯度。Sobel_x和Sobel_y两个算子分别用于计算图像沿着x和y两个方向的梯度，整体梯度G可由x方向的梯度G_x和y方向的梯度G_y按以下公式求得：<br>$$ sobel_x  &#x3D;  \left[\begin{array}{l} 1\ 2\1 \end{array} \right] * \left[\begin{array}{l} 1 &amp; 0 &amp; -1 \end{array} \right]  &#x3D; \left[\begin{array}{l} 1 &amp; 0 &amp; -1 \ 2 &amp; 0 &amp; -2 \ 1 &amp; 0 &amp; -1 \end{array} \right]$$<br>$$ sobel_y  &#x3D;  \left[\begin{array}{l} 1 &amp; 2 &amp; 1 \end{array} \right] * \left[\begin{array}{l} 1\ 0\-1 \end{array} \right]  &#x3D; \left[\begin{array}{l} 1 &amp; 2 &amp; 1 \ 0 &amp; 0 &amp; 0 \ -1 &amp; -2 &amp; -1 \end{array} \right]$$<br>$$ G &#x3D; \sqrt{G_x^2 + G_y^2} $$</p><h3 id="Roughness-贴图的物理意义"><a href="#Roughness-贴图的物理意义" class="headerlink" title="Roughness 贴图的物理意义"></a>Roughness 贴图的物理意义</h3><p>所有的PBR技术都基于微平面理论。这项理论认为，达到微观尺度之后任何平面都可以使用被称为微平面(Microfacets)的细小镜面来进行描绘。Roughness贴图主要控制表面的粗糙程度，根据平面粗糙程度的不同，这些细小镜面的朝向会有不同程度的随机。理论上来讲，微表面可以通过几何上的变换进行模拟，但是由于这些微平面尺度太小，渲染时已经无法在像素水平对其进行区分，因此PBR理论中引入了粗糙度(Roughness)，并通过统计学的方法来近似这些微平面。Roughness越低表示微表面法线分布越统一，反射光线表现更加趋近于镜面反射，而Roughness越高，则表示表面法线分布越混乱越随机，反射光线表现更趋近于漫反射。<br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202311152020.jpg" title="微表面及其法线示意图" alt="微表面及其法线示意图" width="50%"></p><p>具体到反射方程中，Roughness会影响到BRDF中的D（法线分布函数）和G（几何函数）的计算。</p><p>法线分布函数（NDF）被用来描述表面一点内微表面的法向分布。输入一个方向h，法线分布函数会返回法向是h的微平面占所有微表面的比例。法线分布函数有许多不同的模型，但都需要Roughness参与计算，其中目前最常使用的是由Bruce Walter和Kenneth Torrance提出的GGX-NDF，其中，Burley推荐以 α&#x3D;roughness^2,其中roughness∈[0,1] 的方式代入模型表面粗糙度数据，以让分布以更线性的方式变化：<br>$$ NDF_{GGXTR} (n,h,α)&#x3D;\frac{α^2}{\pi((n·h)^2·(α^2-1)+1)^2} $$</p><p>几何函数（GSF）则是用于描述由于微面的自阴影行为而导致的光衰减的函数。几何函数模拟了在给定点微面相互遮挡或光在多个微面上反弹的概率，在这些情况下，光在到达视点之前会失去能量，因此宏观上也就表现为我们观察到该处的反射强度会降低。BRDF中使用的几何函数一般指的是包含了在光照方向L上的阴影函数（shadowing function）和在观察方向V上的遮蔽函数（masking function）的联合遮蔽阴影函数。几何函数对于BRDF能量守恒至关重要,BRDF方程一个关键部分是有效表面积（指的是能将光线从光源方向反射到视点方向的表面所覆盖的面积与微面表面的总表面积之间的比率）。而如果不考虑几何函数，则该有效表面积可能会超过总面积，也就破坏了能量守恒。为了准确地生成GSF，大多数拟合公式需要对粗糙度进行采样以确定微平面分布，因此几何函数也与粗糙度Roughness有密切的联系。</p><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202311152021.jpg" title="在光照方向L上的阴影（左）和在观察方向V上的遮蔽（右）示意图" alt="在光照方向L上的阴影（左）和在观察方向V上的遮蔽（右）示意图" width="50%"><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202311152022.jpg" title="在光照方向L上的阴影（左）和在观察方向V上的遮蔽（右）示意图" alt="在光照方向L上的阴影（左）和在观察方向V上的遮蔽（右）示意图" width="50%"><h3 id="Mipmap技术及其引入的高光走样问题简介"><a href="#Mipmap技术及其引入的高光走样问题简介" class="headerlink" title="Mipmap技术及其引入的高光走样问题简介"></a>Mipmap技术及其引入的高光走样问题简介</h3><p>为了避免高光走样问题，现代渲染通常会使用Mipmap技术，但在渲染中用Mipmap技术处理法线贴图会引入高光走样问题。为了解决该问题，NVIDIA提出了一种基于Mipmap的法线方差估计技术，通过计算法线贴图方差信息，修改材质的粗糙度信息，从而解决高光走样。我的毕业论文中在Blender中近似地实现了该效果，下面将对该问题的产生原因及解决原理做进一步阐述。</p><p>Mipmap技术现代渲染中必不可少的一个环节。图形学中使用纹理映射（Texture Mapping）将模型上每个点的颜色信息储存在二维的图像上。这种方式方便了美术工作者对模型着色的修改和控制，但贴图尺度过大或者过小都会引发一些渲染走样。当纹理相对于模型过小时，屏幕空间中多个像素点对应在纹理贴图上的坐标都集中在一个像素附近，如果简单地取最近邻的像素值，会导致渲染结果产生严重的走样。实际渲染中一般使用双线性插值来对坐标附近的像素值做一个混合，但这样得到的效果仍不足以弥补问题。<br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202311152035.jpg" title="纹理较小时屏幕空间（左）与纹理空间（右）的像素对应关系" alt="纹理较小时屏幕空间（左）与纹理空间（右）的像素对应关系" width="50%"><br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202311152036.jpg" title="纹理较小时使用插值得到的渲染结果" alt="纹理较小时使用插值得到的渲染结果" width="50%"></p><p>而当纹理相对于模型在屏幕上所占像素数过大时（模型离相机较远时），屏幕空间的一个像素，可能就对应了贴图中一整个区域，这个区域被称为屏幕像素在纹理空间的footprint。此时对于在屏幕空间上相邻的片元来说，如果仅采样贴图上一个点来作为着色值，就会导致屏幕上相邻像素采样得到的颜色是不连续的，从而导致了渲染的锯齿状走样。从信号的角度上来说，这是采样频率过低引起的信息丢失。而使用SuperSampling（超采样）计算量过大，因此Mipmap技术应运而生。<br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202311152037.jpg" title="纹理较大时屏幕空间（左）与纹理空间（右）的像素对应关系" alt="纹理较大时屏幕空间（左）与纹理空间（右）的像素对应关系" width="50%"></p><p>Mipmap技术最早由Lance Williams在他的论文Pyramidal parametrics中提出。Mipmap技术的主要原理就是提前计算像素对应的footprint的均值。具体做法是对贴图进行多次下采样，得到不同尺寸的贴图，在渲染时根据模型与相机的距离，选择不同尺度的贴图。</p><h3 id="基于Mipmap的法线方差估计"><a href="#基于Mipmap的法线方差估计" class="headerlink" title="基于Mipmap的法线方差估计"></a>基于Mipmap的法线方差估计</h3><p>在Mipmap下采样的过程中，普通颜色贴图中储存的是线性数据，因此可以直接进行线性混合。但法线贴图中储存的是归一化后的方向信息，原理上应该在球面坐标系下做向量插值计算。直接对三个分量线性插值得到的结果会与球面向量插值有所差别。下图给出了二维法线float2(1,0)与float2(0,1)按照从0~1的权重使用两种插值方式得到结果的角度差异（渲染时我们仅关注法线方向）。两种插值结果差异并不大，但使用球面向量插值会大大增加计算量，因此实际渲染管线中通常也直接使用线性插值进行法线贴图的Mipmap。<br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202311152038.jpg" title="两法线lerp与slerp的结果角度差异" alt="两法线lerp与slerp的结果角度差异" width="50%"></p><p>且我们可以得到这样一个规律，如下图，插值后的向量长度越接近一，则插值前两向量夹角越小，反之，则插值前法线夹角越大。<br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202311152039.jpg" title="不同夹角向量两种插值方式结果对比" alt="不同夹角向量两种插值方式结果对比" width="50%"></p><p>下图提供了向量夹角与线性插值结果长度的关系。<br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202311152040.jpg" title="法线夹角与法线线性插值后结果长度的关系" alt="法线夹角与法线线性插值后结果长度的关系" width="50%"></p><p>但线性插值得到的Normal结果显然无法完全表达材质的细节，多个法线混合后得到一个法线结果，在这个过程中我们损失了该处混合前法线的变化剧烈程度信息，这部分信息可以用法线贴图的方差来表达。Nvidia借用微表面理论中的原理，假设法线在Mipmap时输入符合高斯分布，标准差为σ。如下图，Nvidia得出了一定范围内的法线标准差与插值后结果的长度关系。其中红色是其实际关系的曲线，而绿色是Nvidia对其的逼近，逼近公式如下：<br>$$ |N_a |  &#x3D;  \frac{1}{1+σ^2}  ⇔σ^2  &#x3D;  \frac{1-|N_a |}{|N_a | } $$<br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202311152040.jpg" title="法线平均值的长度与这个标准差的函数关系（来源Nvidia）" alt="法线平均值的长度与这个标准差的函数关系（来源Nvidia）" width="50%"><br>因此，只需要采样Mipmap之后的法线贴图，我们就可以使用上述公式估计法线的局部方差。</p><h3 id="使用Roughness变化矫正法线Mipmap带来的高光走样及其理解"><a href="#使用Roughness变化矫正法线Mipmap带来的高光走样及其理解" class="headerlink" title="使用Roughness变化矫正法线Mipmap带来的高光走样及其理解"></a>使用Roughness变化矫正法线Mipmap带来的高光走样及其理解</h3><p>在实践中我们发现，仅对法线贴图Mipmap仍然会带来高光走样问题，这是由于Mipmap后的法线贴图不能完全表达出之前的材质信息，Mipmap后的贴图只能采样到一个方向信息，却忽略了材质局部的法线变化程度。<br>我们之所以在渲染中引入Roughness贴图，正是因为无法描述亚像素级别的微平面法线差异。因此从本质上来说，Roughness贴图储存的也是模型的一部分法线信息。而使用法线贴图来宏观表现还是使用粗糙度贴图来微观表现，其分界就在像素级别。一个像素仅可以对应一个法线方向，因此，所有在一个像素内的法线变化信息（不论其对应纹理空间多大的范围），都应该被包含在粗糙度贴图中。也就是说，当法线贴图生成Mipmap时，部分法线信息退化为表面粗糙度信息，我们需要提高模型的粗糙度以避免高光走样问题（如下图）。<br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202311152041.jpg" title="存在高光走样（左）和避免掉高光走样（右）的对比效果（图源网络）" alt="存在高光走样（左）和避免掉高光走样（右）的对比效果（图源网络）" width="50%"></p><p>在实践中，笔者将法线贴图的局部方差对应到材质粗糙度的改变，并借鉴了Nvidia提出的方法，通过对Mipmap之后的法线贴图采样，计算法线局部的方差，从而实时地实现了对人脸粗糙度的改变，避免了Mipmap带来的高光走样问题。</p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphics </category>
          
          <category> Rendering </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rendering </tag>
            
            <tag> Physically Based Rendering </tag>
            
            <tag> Microfacet </tag>
            
            <tag> Materials </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一篇搞懂基于微表面模型的PBR材质</title>
      <link href="/2023/11/13/PBR-BSDF-Based-Microfacet-Model/"/>
      <url>/2023/11/13/PBR-BSDF-Based-Microfacet-Model/</url>
      
        <content type="html"><![CDATA[<p>在当前的图形学前沿研究中，对人脸的真实感渲染，基本都是基于PBR理论的。基于物理的渲染（Physically-based rendering）指的是使用数学建模的方式，模拟物体表面各种材质对光线反射和折射的特性，从而达到逼近真实的渲染效果的技术。其主要特点是遵循真实物理规律，光与材质相分离，且材质参数取自真实生活中的材质特征。由于本身基于物理原理，使用PBR的渲染效果相较于简单的Phong等模型会更加真实，其基于物理的参数设置也使得美术工作者可以对材质进行可预见效果的调节。</p><p>渲染与材质息息相关，私以为如果说Rasterization Rendering Pipeline，Path Tracing是渲染的骨骼，那么Materials就是渲染的心脏，是决定Mesh表面着色，光线追踪中光线Bounce后的采样方向等重要环节的核心模块。而所谓的Physically Based Rendering，除了Path Tracing本身是Physically Based的一种想法之外，Physically Based Materials也是必不可少甚至于根本上反映Physically的一环。</p><span id="more"></span><p>我从本科学习时就曾经接触到Physically Based Rendering，但是直到做我的毕业论文课题时才对其有了一个较为全面的基础了解，但或许是我天资较差，相关的知识于我而言总是常看常新的，在至今的一两年中每次学习总是能发现自己之前理解的不对的地方，在最近做Blender和Mitsuba中材质模型的对齐工作时，我总算觉得自己对Physically Based Material有了一个自己认为还比较完整的理解，故将自毕业论文以来的学习和思考整理于此。（当然之后也可能再次进行学习并推翻现在的一些想法。</p><p>本篇的核心追求是完整地梳理PBR材质相关的知识线，因此相对来说可能会较为啰嗦，会引用一些我本科毕业论文中的原文，还望海涵。</p><h3 id="基础概念的引入"><a href="#基础概念的引入" class="headerlink" title="基础概念的引入"></a>基础概念的引入</h3><p>基于物理的渲染(PBR, Physically-Based Rendering)是计算机图形学中用数学建模的方式模拟物体表面各种材质散射光线的属性从而渲染照片真实图片的技术，是近年来渲染的大趋势。它主要的特点是遵循物理规律，光与材质是分离的，且控制材质的参数是与现实生活中的材质特征对应的。</p><p>由于PBR本身基于物理原理，因此，这种渲染方式相比于之前的Phong或者Blinn-Phong这样简单的模型来说，渲染结果会更加真实。另一方面，PBR也使得美术人员可以直接以物理参数为依据来调节和编辑材质，使得材质可以有基于物理性质可预见的视觉变化，并且无论光照条件如何，这样的材质都会是相对来说物理合理的。</p><p>BRDF（Bidirectional Reflectance Distribution Function，双向反射分布函数）是真实感图形学中最核心的概念之一，是用于描述光反射现象的基本模型，描述的是入射光线经过物体表面反射后如何在各个出射方向上分布。其输出是入射光线方向和出射光线方向，并且由于都是归一化的向量，因此输入其实是四维的，输出是出射光线占入射光线的比例。而PBR中使用的BRDF模型通过包含材质的各种几何及光学性质来尽可能精确的近似现实世界中的材料，它必须满足至少如下两条特性：能量守恒、亥姆霍兹光路可逆性（Helmholtz Recoprpcity Rule）。</p><p>BRDF：Bi-directional Reflective Distribution Function<br>BTDF：Bi-directional Transmit Distribution Function<br>BSDF：Bi-directional Scattering Distribution Function<br>其中，BSDF中的Scattering是反射和折射的统称，实际使用时BSDF &#x3D; BRDF + BTDF</p><h3 id="微表面和Cook-Torrance模型"><a href="#微表面和Cook-Torrance模型" class="headerlink" title="微表面和Cook-Torrance模型"></a>微表面和Cook-Torrance模型</h3><p>微表面模型（Microfacet）是PBR中的重要理论基础。该假设认为物体表面是由法线方向不同的众多微小表面组成的。目前业界大部分的实时渲染管线使用的都是Cook-Torrance BRDF模型，该模型的整体反射方程为：<br>$ L_o (p,ω_o )&#x3D; \int_\Omega (k_d  \frac{c}{π} +k_s  \frac{DFG}{4(ω_o·n)(ω_i·n)} ) L_i (p,ω_i )n·ω_i dω_i $<br>其中BRDF也就是反射部分的公式是：<br>$ f(l,v)&#x3D; \frac{D(h)F(v,h)G(l,v,h)}{(4(n·h)(n·v))} $</p><h3 id="D-法线分布函数（Normal-Distribution-Funtion）"><a href="#D-法线分布函数（Normal-Distribution-Funtion）" class="headerlink" title="D: 法线分布函数（Normal Distribution Funtion）"></a>D: 法线分布函数（Normal Distribution Funtion）</h3><p>在BRDF模型中，法线分布函数（Normal Distribution Function，简写为NDF），也就是上述公式中的D(h)，被用来描述表面一点的所有微表面的法线分布概率。输入一个朝向h，NDF会返回朝向是h的微表面占所有微表面的比例。</p><p>在微表面模型的假设下，表面越粗糙，每个微面将沿着表面排列得越混乱，从而导致方向范围更广泛的镜面反射。相反，在光滑的表面上，光线更有可能沿大致相同的方向反射，从而产生更小、更清晰的反射。</p><p>理论上来讲，微表面可以通过几何上的面片进行模拟，但是由于这些微面过于小，我们无法在每个像素的基础上区分它们，因此在基于物理的渲染工作流中，业界一般使用的方法是：在给定粗糙度参数的情况下，在统计上近似这些微平面。通过对粗糙度贴图（Roughness）采样，以计算微平面归一化的法线分布函数，可以将需渲染的几何体细化到了微观尺度（Microscale）的亚像素层面，所以能够带来更加接近真实的渲染质量和更全面的材质外观质感把控。也就是说，Roughenss Map其实是亚像素级别的 Normal Map。</p><p>NDF函数有许多不同的模型，按照提出的时间可以总结为（本总结摘自毛星云大佬的知乎文章）：</p><ul><li>Berry[1923]</li><li>Beckmann[1963]</li><li>Phong [1973]</li><li>Blinn-Phong[1977]</li><li>ABC[1989]</li><li>GGX[2007]</li><li>Trowbridge-Reitz[1975]</li><li>Shifted</li><li>Gamma Distribution</li><li>SGD[2012]</li><li>Trowbridge-Reitz（GTR）[2012]</li><li>Student’s T-Distribution STD[2017]</li><li>Exponential Power Distribution</li><li>EPD[2017]。</li></ul><p>其中目前业界最常使用的是由 Bruce Walter 和 Kenneth Torrance提出的GGX NDF和Beckmann NDF。</p><ul><li>GGX的公式：<br>$ NDF_{GGXTR} (n,h,α)&#x3D; \frac{α^2}{(π((n·h)^2·(α^2-1)+1)^2 )} $</li><li>Beckmann公式：<br>$ NDF_{Beckmann} (n,h,\alpha) &#x3D; \frac{1}{\pi \alpha^2 (n·h)^4} e^{(\frac{(n·m)^2-1}{\alpha^2 (n·m)^2})} $</li></ul><p>下图是不同NDF公式的曲线可视化对比，其中红线为 $α_b&#x3D;0.2$ 时的Beckmann-NDF，蓝线为 $α_p&#x3D;48$ 时的Phong-NDF，绿线为 $α_g&#x3D;0.2$ 时的GGX-NDF。从图中不难看出，GGX分布函数拥有一个比Beckmann和Phong模型更大的拖尾，衰减更慢，因此在实际使用中使用GGX会使得高光衰减过渡更自然。<br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202311131732.jpg" title="不同画幅对比" alt="不同NDF曲线对比" width="50%"><br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202311131733.jpg" title="不同画幅对比" alt="不同NDF曲线高光效果对比" width="50%"></p><p>另外，Brent Burley在Physically-based shading at Disney中提出了一种叫做GTR的通用的NDF模型，其可以通过参数 γ 控制NDF曲线的形状，及其拖尾的大小，从而控制材质的光影过渡程度，当 γ 为2时等于GGX模型。<br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202311131734.jpg" title="不同画幅对比" alt="GTR通用NDF模型" width="50%"></p><h3 id="G-几何遮蔽函数（Geometric-Shadowing-Function）"><a href="#G-几何遮蔽函数（Geometric-Shadowing-Function）" class="headerlink" title="G: 几何遮蔽函数（Geometric Shadowing Function）"></a>G: 几何遮蔽函数（Geometric Shadowing Function）</h3><p>BRDF模型中的几何遮蔽函数是用于描述由于微表面的自阴影行为而导致的光衰减的函数。这种近似模拟了在给定点微面相互遮挡或光在多个微面上反弹的概率。在这些情况下，光在到达视点之前会失去能量，因此宏观也就表现为我们观察到该处的反射强度会降低。</p><p>几何阴影函数对于 BRDF 模型是否满足能量守恒至关重要。如果没有几何阴影函数，可能会导致物体表面反射的光比接收的更多。BRDF 方程一个关键部分是有效表面积（指的是能将光线从光源方向反射到视点方向的表面所覆盖的面积与微面表面的总表面积之间的比率）。而如果不考虑几何阴影函数，则该有效表面积可能会超过总面积，也就破坏了能量守恒。</p><p>几何阴影也有不同的拟合公式，历史上主流的几何函数建模，按提出或归纳的时间进行排序，可以总结为（摘自毛星云知乎文章）：</p><ul><li>Smith [1967]</li><li>V-cavity（Cook-Torrance）[1982]</li><li>Schlick-Smith [1994]</li><li>Neumann [1999]</li><li>Kelemen [2001]</li><li>Implicit [2010] [21]</li></ul><p>其中，Smith遮蔽函数（Smith masking function）是现在业界所采用的主流遮蔽函数，Eric Heitz在2014年[4]将其拓展为Smith联合遮蔽阴影函数（Smith Joint Masking-Shadowing Function），该函数具有四种形式：</p><ul><li>分离遮蔽阴影型（Separable Masking and Shadowing）</li><li>高度相关遮蔽阴影型（Height-Correlated Masking and Shadowing）</li><li>方向相关遮蔽阴影型（Direction-Correlated Masking and Shadowing）</li><li>高度-方向相关遮蔽阴影型（Height-Direction-Correlated Masking and Shadowing）</li></ul><p>其中，高度相关遮蔽阴影型及其近似，是目前业界采用的主流遮蔽阴影函数。高度相关理论的准确性也由Eric Heitz在《Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs》中证明[4]。</p><p>2014年之前，Disney在SIGGRAPH2012上提出的GSF参考了[Walter 2007]的近似方法，使用Smith GGX导出的G项，并将粗糙度参数进行重映射以减少光泽表面的极端增益，即将α 从[0,1]重映射到[0.5, 1]，α的值为 $(0.5+roughness&#x2F;2)^2$ 。从而使几何项的粗糙度变化更加平滑，更便于美术人员的使用。<br>UE4在SIGGRAPH 2013上公布的方案为基于Schlick近似，将k映射为 k&#x3D;a&#x2F;2 ,去匹配GGX Smith方程，并采用了Disney对粗糙度的重映射$(0.5+roughness&#x2F;2)^2$：<br>$ G_1 (v)&#x3D;(n·v)&#x2F;((n·v)(1-k)+k) $<br>$ G(l,v,h)&#x3D;G_1 (l) G_1 (v) $<br>其中，G_1 (l) G_1 (v) 是因为我们需要将观察方向（几何遮蔽Geometry Obstruction）和光线方向向量（几何阴影Geometry Shadowing）都考虑进去。<br>而在2014年之后，UE4、Frostbite和Unity等引擎都受到Heitz的启发，为了得到更精确的几何遮挡关系，开始考虑入射阴影和出射遮蔽之间的相关性（不考虑相关性会导致计算出的阴影偏多），并在后续更新中各自转向了Smith联合遮蔽阴影函数（The Smith Joint Masking-Shadowing Function）的高度相关遮蔽阴影形式（Height-Correlated Masking and Shadowing），并相应地都做了一些近似与优化。</p><h3 id="F-菲涅尔函数（Fresnel-Function）"><a href="#F-菲涅尔函数（Fresnel-Function）" class="headerlink" title="F: 菲涅尔函数（Fresnel Function）"></a>F: 菲涅尔函数（Fresnel Function）</h3><p>菲涅尔效应（Fresnel effect）表示的是看到的光线的反射率与视角相关的现象，由法国物理学家奥古斯丁·菲涅尔率先发现：当垂直观察的时候，任何物体或者材质表面都有一个基础反射率F_0（Base Reflectivity），但是如果以一定的角度往平面上看的时候所有反光都会变得明显起来。如果从理想的90度视角观察，所有的平面理论上来说都能完全的反射光线。<br>而菲涅尔方程作为基于物理的渲染理念中的核心理念之一，描述的是光线入射之后，光会部分反射且部分折射，反射的比例就是菲涅尔系数。菲涅尔系数满足：$ 0&lt;&#x3D;F_r&lt;&#x3D;1 $<br>当光线垂直撞击表面时，该光线被反射（Reflected）为镜面反射光的比率被称为$F_0$。而折射（Refracted）到表面中的光量则为$1-F_0$。但需要注意的是，我们在宏观层面看到的菲涅尔效应实际上是微观层面微平面菲涅尔效应的平均值。也就是说，影响菲涅尔效应的关键参数在于每个微平面的法向量和入射光线的角度，而不是宏观平面的法向量和入射光线的角度。</p><p>菲涅尔系数可以由麦克斯韦方程组直接推导出来的，已知平面处两种介质的折射率分别为：$\eta_i、\eta_t$，则根据斯涅尔定理可得折射角和入射角的关系：<br>$\eta_i sin\theta_i  &#x3D; \eta_t sin \theta_t$<br>根据麦克斯韦方程组计算推导，平行和垂直偏振光的菲涅尔反射公式：<br>$$ r_{\parallel} &#x3D; \frac{\eta_t cos \theta_i - \eta_i cos \theta_t}{\eta_t cos \theta_i + \eta_i cos \theta_t} $$<br>$$ r_{\perp} &#x3D; \frac{\eta_i cos \theta_i - \eta_t cos \theta_t}{\eta_i cos \theta_i + \eta_t cos \theta_t} $$</p><p>$$ F_r &#x3D; \frac{1}{2} (r_{\parallel}^2 + r_{\perp}^2)</p><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202311131734.jpg" title="不同画幅对比" alt="GTR通用NDF模型" width="50%"><p>已知两种介质的折射率分别为<br> 。 首先根据斯涅尔定律得到折射角和入射角的关系：</p><p>上面这部分参考了：<a href="https://zhuanlan.zhihu.com/p/158025828">https://zhuanlan.zhihu.com/p/158025828</a></p><p>菲涅尔项的常见模型：</p><ul><li>Cook-Torrance[1982]</li><li>Schlick[1994]</li><li>Gotanta [2014]。<br>目前业界在渲染时大多采用Fresel的Schlick近似[3]：<br>$$ c &#x3D; \frac{n·v}{a\sqrt{1-(n·v)^2}} $$<br>MERL材质[6]中的菲涅尔项如下图，为了方便观察这个曲线经过一定程度的放缩和偏移，在θ_d为90度时都有一定程度的增大。红色虚线部分是理论中的菲涅尔反应。<img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202311131735.jpg" title="实测菲涅尔项" alt="实测菲涅尔项" width="50%"></li></ul><p>基础反射率$F_0$的求解方式需要用到材料的折射率：<br>$$ F_0&#x3D;(\frac{n_1-n_2}{n_1+n_2})^2 $$<br>其中，n_1和n_2分别为两种介质的折射率。通常假设 n_1&#x3D;1 近似于空气的折射率，并用n替换n_2，于是，上式可以简化为：<br>$$ F_0&#x3D;(\frac{n-1}{n+1})^2 $$</p><h3 id="相对折射率-relative-refractive-index"><a href="#相对折射率-relative-refractive-index" class="headerlink" title="相对折射率(relative refractive index)"></a>相对折射率(relative refractive index)</h3><p>在学习Mitsuba代码的时候，发现其折射率涉及到代码里两个变量：m_eta和m_k，查资料后知道其代表的分别是相对折射率的实部和虚部。<br>折射率(refractive index)是用来描述光线在某介质内传播速度的比例。对于同一种光源在不同介质中的折射率,如果以真空为基准,就称为相对折射率。而相对折射率通常可以用一个复数来表示: $ n &#x3D; n’ + k * i $。其中:</p><ul><li>n’是相对折射率的实部,代表光线在该介质中的沿进速度。</li><li>k是相对折射率的虚部,代表光线在该介质中的衰减率。</li></ul><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ol><li>不同N、G、F的公式可见：<a href="https://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html">https://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html</a></li><li>B. Burley and W. D. A. Studios. Physically-based shading at disney. In ACM SIGGRAPH, pages 1–7, 2012.</li></ol>]]></content>
      
      
      <categories>
          
          <category> Computer Graphics </category>
          
          <category> Rendering </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rendering </tag>
            
            <tag> Physically Based Rendering </tag>
            
            <tag> Microfacet </tag>
            
            <tag> Materials </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>相机相关知识(待补充)</title>
      <link href="/2023/11/07/Camera-Realted-Knowledge/"/>
      <url>/2023/11/07/Camera-Realted-Knowledge/</url>
      
        <content type="html"><![CDATA[<p>工作需求经常需要跟坐标系转换打交道，在学习过程中也接触到很多相机姿态相关知识，另外因为自己是摄影爱好者，对相机相关参数也比较有学习的兴趣，因此开坑在这里整理一些学习到的相机计算相关知识。</p><span id="more"></span><h3 id="Fov、Focal-Length和Sensor"><a href="#Fov、Focal-Length和Sensor" class="headerlink" title="Fov、Focal Length和Sensor"></a>Fov、Focal Length和Sensor</h3><p>首先是一个在对齐Relighting项目（里面主要用到了neural-renderer）和Blender的相机参数时发现的问题，在使用我自己的编写的从Blender导出calib数据，和从calib数据导入Blender代码时，发现同一个相机竟然在不同的Blender工程中视场不一样大（震惊），检查之后终于找到了问题点所在，再Blender的相机面板的Camera下面，可以选择拟合传感器的方式，Blender默认是Auto，而我之前的工程文件是Horizontal。</p><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202311071601.jpg" title="Blender中的相机面板" alt="Blender中的相机面板" width="50%">查找资料并咨询了同事之后知道其原因。首先，在渲染中都默认sensor模拟的是35毫米胶卷，指的是单格长高边为36MM×24MM的胶卷。最早是由莱卡公司发起的。35mm其实指的是胶卷高度，由于两边还有齿孔位置因此最后的感光高度只有24mm。而进入数码相机时代之后，相机使用ccd和cmos作为感光元件，全幅相机中的cmos也是36MM*24MM大小，全幅也就是比较标准的cmos规格，市面上的镜头说的焦距一般都是在全幅下的焦距，不同画幅的感光元件大小和焦距计算所乘的倍数如下图所示（图源网络）。全画幅和其他画幅如APSC画幅的对角线之比，成为该画幅相当于全画幅的裁切系数。很巧的时，在写下这些文字的当下，笔者正在考虑是否要把自己的残幅机身换成全幅机身（Canon R7换R62）。<img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202311071609.jpg" title="不同画幅对比" alt="不同画幅对比" width="50%">不同画幅不止会带来视场大小的差异，也会带来画质和宽容度的差别，比如我现在使用的主力机R7，在残幅的大小下，包含了三千多万的像素，就会导致每个像素的感光面积很小，带来的体感差异也就是R7的高感效果一般，并且感觉在光线不足时拍照画面纯净度较低。<img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202311071613.jpg" title="画幅大小差异带来的画质差异" alt="画幅大小差异带来的画质差异" width="50%"><p>跑题了，说回Blender中的Sensor面板，关于Fov（视场），焦距，Sensor大小，有以下约束关系：<br>数值计算公式: $fov(度)&#x3D; 2 * arctan(传感器尺寸&#x2F;2&#x2F;焦距)$</p><ul><li>视场取决于传感器大小和焦距。</li><li>相同焦距下，传感器越大，视场越宽。</li><li>相同传感器下，焦距越长，视场越窄；焦距越短,视场越宽。</li></ul><p>如下图，可以把相机简化为一个小孔模型，镜头的光学中心点到成像平面的距离就是焦距。当更换画幅时，传感器大小变化，焦距不变，因此fov变化；当更换镜头时，传感器大小不变，焦距变化，fov变小，因此在相同的对焦距离下，视场更小。而之所以焦距变化，是镜头带来的固有光学属性，这样看来应该是对于机身来说，像平面不同，不同镜头改变了光学中心的位置从而改变焦距，因此也就可以解释为什么长焦镜头都是瘦高个。<br>在影视飓风的视频里看到16mm镜头在全画幅下fov为108度，但我无论怎么计算都计算不到这个数字，后面查资料才发现在相机中如果只使用一个fov数值那一般是感光元件对角线长度除以焦距，而不是长或者宽。全画幅的对角线长度约为43MM。<br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202311071737.jpg" title="视场，焦距及传感器大小" alt="视场，焦距及传感器大小" width="50%"><br>想到一个之前参加社团笔试的题目，用广角和长焦对着同一个主体拍摄：1、在同一距离，将广角拍摄得到的画面进行裁切后，保证主体大小相同，得到画面与长焦是否完全相同；2、改变拍摄距离距离，保证两种镜头主体大小相同，拍到的画面是否有区别。答案是第一问没有区别，第二问有区别。我对该问题的理解是，可以直接去思考相机与主体和背景的相对位置关系，同一距离下，相对位置完全相同，只有fov不同，因此只需要裁切就可以完全一样，但是不同距离下，当主体大小相同时，其实拍摄点与背景的相对位置关系已经发生了变化，因此画面已经完全不同。</p><p>又跑题了，说回Blender中的Sensor面板，当Sensor fit为Auto时，Blender会用下面的数值去拟合画面中较长的一个边，比如画面是横幅的就会拟合宽，竖幅的画面则会将这个数值对应到高。而下面的Horizontal和Vertical则是制定了以某一个固定的数值去拟合画面，Horizontal就是以指定的Width去拟合画面的宽，而高度是会根据我们设置的画面分辨率比例进行动态的计算调整的，不参与计算，也不显示动态变化（这里我觉得应该动态变化比较合理），Vertical则相反。<br>至于Blender中的fov，我在观察实验后发现，在修改Sensor fit时，Blender是保持Focal Length不变，根据上面的计算规则去计算Fov的，但并不是使用的对角线fov，而只是单纯某个边的fov。</p><h3 id="Blender中相机平移旋转参数和相机变化矩阵的相互转换计算"><a href="#Blender中相机平移旋转参数和相机变化矩阵的相互转换计算" class="headerlink" title="Blender中相机平移旋转参数和相机变化矩阵的相互转换计算"></a>Blender中相机平移旋转参数和相机变化矩阵的相互转换计算</h3>]]></content>
      
      
      <categories>
          
          <category> Computer Graphics </category>
          
          <category> Rendering </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rendering </tag>
            
            <tag> Camera </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Beckmann分布的Blender-Cycles与Mitsuba高光渲染效果对齐</title>
      <link href="/2023/10/24/Blender-Source-Code/"/>
      <url>/2023/10/24/Blender-Source-Code/</url>
      
        <content type="html"><![CDATA[<p>由于工作需求，我们的采集流程中使用的是基于Mitsuba的可微渲染，而采集得到的高光贴图需要在Blender中进行渲染成图，两边的BSDF渲染效果不统一问题困扰了我们许久。因此本文的核心需求是，阅读Blender和Mitsuba的源码，找出其差异，并在源码级别实现在Blender中复现Mitsuba的高光渲染效果。最后本文对Blender源码做了修改和重编译，用新的Blender编译版本实现了该渲染效果对齐的需求。</p><span id="more"></span><h3 id="Blender和Mitsuba渲染场景及参数的对齐"><a href="#Blender和Mitsuba渲染场景及参数的对齐" class="headerlink" title="Blender和Mitsuba渲染场景及参数的对齐"></a>Blender和Mitsuba渲染场景及参数的对齐</h3><p>为了方便对齐两边的渲染效果，我需要首先把两边的渲染场景对齐，其中Mitsuba使用xml文件储存场景信息，而Blender则是工程文件，我具体进行的对齐有：</p><ol><li>两边都取消所有点光源、面光源等，都只使用同一张exr格式的环境贴图，对贴图亮度的scale都设置为0.05，使用的环境贴图是Equirectangular Mapping格式。</li><li>两边camera的参数对齐，包括外参：相机的姿态矩阵和内参：相机的fov、cx、cy等，都使用perspective透视模式。（这部分其实包含很多具体的学习内容和计算，可以参考我的博客文章：<a href="https://yaelcassini.github.io/2023/11/07/Camera-Realted-Knowledge/%EF%BC%89">https://yaelcassini.github.io/2023/11/07/Camera-Realted-Knowledge/）</a></li><li>两边渲染分辨率的对齐，都使用6960*4640。</li><li>两边spp（sample per pixel）的对齐，实验过程中都使用1024。</li><li>两边渲染结果都使用exr格式输出。（这里一开始由于Blender的颜色管理出问题导致误以为两边光照不相同，浪费了很多时间，具体可以参考我的博客文章：<a href="https://yaelcassini.github.io/2023/04/24/Color-Management/%EF%BC%89">https://yaelcassini.github.io/2023/04/24/Color-Management/）</a></li><li>两边的最大bounce次数对齐，其中，Blender中Max Bounces都设置为0时，才是只有直接光照的结果，而不是设置为1时。</li><li>两边渲染使用的Mesh完全相同，（载入Blender时要注意Blender的坐标系是z轴朝上的，import obj会默认做一个绕x轴的90度旋转。）</li><li>模型贴图都使用exr格式输入，不做颜色空间转换避免出现问题。</li></ol><h3 id="Mistuba源码阅读及分析"><a href="#Mistuba源码阅读及分析" class="headerlink" title="Mistuba源码阅读及分析"></a>Mistuba源码阅读及分析</h3><p>Mitsuba场景文件中的bsdf信息如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;bsdf id=&quot;obj_bsdf&quot; type=&quot;roughconductor&quot;&gt;</span><br><span class="line">    &lt;boolean name=&quot;sample_visible&quot; value=&quot;false&quot;/&gt;</span><br><span class="line">    &lt;string name=&quot;distribution&quot; value=&quot;beckmann&quot;/&gt;</span><br><span class="line">    &lt;boolean name=&quot;fresnel_schlick&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">    &lt;boolean name=&quot;forward&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">    &lt;texture id=&quot;f0&quot; name=&quot;f0&quot; type=&quot;bitmap&quot;&gt;</span><br><span class="line">        &lt;string name=&quot;filename&quot; value=&quot;/f0.exr&quot;/&gt;</span><br><span class="line">    &lt;/texture&gt;</span><br><span class="line">    &lt;texture id=&quot;alpha&quot; name=&quot;alpha&quot; type=&quot;bitmap&quot;&gt;</span><br><span class="line">        &lt;string name=&quot;filename&quot; value=&quot;alpha.exr&quot;/&gt;</span><br><span class="line">    &lt;/texture&gt;</span><br><span class="line">&lt;/bsdf&gt;</span><br></pre></td></tr></table></figure><p>可以看到使用的是roughconductor模型，主要代码在<code>mitsuba2\src\bsdfs\roughconductor.cpp</code>文件中，bsdf的相关计算在RoughConductor类的eval函数中，我们项目中使用的是学长修改过的mitsuba，因此可以支持fresnel_schlick近似的计算，学习源码后转化的公式为：</p><p>$$ result &#x3D; \frac{F * D * G}{4 * cos \theta_i} $$</p><p>$$ D &#x3D; D_{NDF_Beckmann} (n,h,α)&#x3D;\frac{1}{(\pi α^2 (n·h)^4 )} e^{(\frac{(n·h)^2-1}{α^2 (n·h)^2 })} $$</p><p>$$ G &#x3D; G_2(l,v,h) &#x3D; G_1(l) * G_1(v) $$</p><p>$$ G_1(v) &#x3D; G_{GGX_Beckmann}(v) &#x3D; \left {<br>\begin{array}{l l}<br> \frac{ 3.535 c + 2.181 c^2 }{ 1 + 2.276 c + 2.577 c^2 } &amp; \quad \text{if $c &lt; 1.6$}\<br> 1 &amp; \quad \text{if $c \geq 1.6$}<br>\end{array} \right. $$</p><p>$$ 其中：c &#x3D; \frac{n·v}{ \alpha \sqrt{1 - (n·v)^2} } $$<br>$$ F &#x3D; F_{Schlick}(v,h) &#x3D; f0 + (1 - f0) * (1-v·h)^5 $$</p><h3 id="Blender源码阅读及分析（主要针对Glossy-BSDF着色节点的跟踪）"><a href="#Blender源码阅读及分析（主要针对Glossy-BSDF着色节点的跟踪）" class="headerlink" title="Blender源码阅读及分析（主要针对Glossy BSDF着色节点的跟踪）"></a>Blender源码阅读及分析（主要针对Glossy BSDF着色节点的跟踪）</h3><p>Blender中“Principled BSDF”节点是没有Beckmann分布的，只提供GGX和Multiscatter GGX两个微表面模型，因此我们流程中使用的是提供Beckmann分布的“Glossy BSDF”节点。因此需求转化为分析“Glossy BSDF”节点的具体实现公式，因此在大致学习了Blender源码的编写结构之后就从“Glossy BSDF”结点入手进行具体分析。<br>首先，Blender支持OSL(Open Shader Language)，源码中有内置shader nodes的osl实现版本。因此在一开始通过关键词检索源码的阶段我自然而然的找到了osl实现的部分，虽然后来发现只关注osl是显然不行的，但此处还是顺着我的探索历程来整理。<br>(PS: 这里说一嘴，虽然osl模式有很多限制，但是胜在相比于普通渲染模式的代码阅读起来更类似GLSL等Shader语言，非常流畅，而且Blender应该是做了两种模式下渲染效果的对齐的，因此OSL可以作为辅助功能，比如想查看某个BSDF的具体计算过程，就可以先看OSL代码。)</p><ol><li>“Glossy BSDF”节点的底层实现使用OSL编写，在blender源码的<code>intern\cycles\kernel\osl\shaders\node_glossy_bsdf.osl</code>文件中，其中使用到了<code>microfacet</code>函数。</li><li>接下来自然而然地去找<code>microfacet</code>函数的实现，找到<code>intern\cycles\kernel\osl\closures_template.h</code>文件中使用<code>OSL_CLOSURE_STRUCT_</code>系列关键字做了Microfacet、microfacet和用到的参数及其类型的声明。</li><li>由于工程里面没有找到其他的Microfacet关键字，因此下一步我选择搜索哪里用到了<code>closures_template.h</code>，找到了以下几个文件：</li></ol><ul><li>closures_setup.h</li><li>closures.cpp</li><li>osl.h</li><li>types.h<br>Blender源码使用的方式是以上的每个文件里使用#define重新定义<code>OSL_CLOSURE_STRUCT_</code>系列关键字的含义，以减轻代码的重复性和冗余性。</li></ul><ol start="3"><li><ol><li><code>closures_setup.h</code>中引入template用于创建Closure结构体。</li></ol></li><li><ol start="2"><li><code>closures.cpp</code>中引入了两次template，一次用于创建返回值为ClosureParam的函数，猜测是用于返回参数列表，另一次是用于注册闭包。</li></ol></li><li><ol start="3"><li><code>osl.h</code>中引入template用于<code>flatten_closure_tree</code>函数中，根据函数名及函数体内容猜测，该函数用于展开OSL闭包树,将其转换为单一BSDF表示。</li></ol></li><li><ol start="4"><li><code>types.h</code>中引入template用于在枚举类型<code>OSLClosure</code>中声明不同shading类型的名字和值。</li></ol></li><li><p>根据关键词<code>osl_closure_microfacet</code>搜索只能找到<code>closures_setup.h</code>中的<code>osl_closure_microfacet_setup</code>函数。该函数体内，在判断distribution为beckmann时，分三种情况讨论，折射，glass和else，我们需要的显然是最后一种情况。</p></li><li><ol><li>用正则表达式搜索<code>osl_closure_microfacet_setup</code>函数，发现在<code>osl.h</code>中使用了switch判断，case为OSL_CLOSURE_##Upper##<em>ID时，调用了osl_closure</em>##lower##<em>setup函数，猜测调用的方式时渲染时，在flatten_closure_tree函数中判断closure-&gt;id（应该是一个枚举类型OSLClosureType的变量），发现节点的枚举值是OSL_CLOSURE</em>##Upper##<em>ID（types.h），调用osl_closure</em>##lower##<em>setup（osl.h）。而closures.cpp中的register_closures函数则把小写的shading node名字#lower，大写的OSL_CLOSURE</em>##Upper##<em>ID，返回参数列表的osl_closure</em>##lower##_params()函数绑定了。</li></ol></li><li><p>最后一种情况调用<code>bsdf_microfacet_beckmann_setup</code>函数，并把bsdf类的fresnel_type变量赋值为MicrofacetFresnel::NONE，变量赋值为CLOSURE_BSDF_MICROFACET_BECKMANN_ID，从这里开始不再出现CLOSURE_BSDF_MICROFACET_ID，而需要顺着CLOSURE_BSDF_MICROFACET_BECKMANN_ID找。</p></li><li><p>搜索CLOSURE_BSDF_MICROFACET_BECKMANN_ID找到的bsdf_sample函数，位于<code>intern\cycles\kernel\closure\bsdf.h</code>文件中，在判断ShaderClosure-&gt;type后调用<code>bsdf_microfacet_beckmann_sample</code>函数。</p></li><li><p>bsdf_eval函数中调用的bsdf_microfacet_beckmann_eval是计算bsdf的核心，位于<code>intern\cycles\kernel\closure\bsdf_microfacet.h</code>文件中。</p></li><li><p>位于<code>intern\cycles\scene</code>的shader_nodes.cpp中的NODE_DEFINE(GlossyBsdfNode)中定义了glossy_bsdf节点，并在其中进行了分布枚举类型的名字和ID注册对应，比如：<code>distribution_enum.insert(&quot;beckmann&quot;, CLOSURE_BSDF_MICROFACET_BECKMANN_ID);</code></p></li><li><p>由于“Principled BSDF”节点是有Fresnel项的，因此看一下Pricipled BSDF的代码做一个对比，发现该节点的osl实现里面用到了<code>generalized_schlick_bsdf</code>函数，我发现该函数是可以输出beckmann并且有fresnel项的，因此我使用Blender的OSL模式，调用该函数进行渲染，在使用如下设置和参数时，实现了同光照同场景下和Mitsuba渲染效果的对齐：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shader <span class="title">simple_material</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    string distribution = <span class="string">&quot;beckmann&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    color f0 = color(<span class="number">0.04</span>, <span class="number">0.04</span>, <span class="number">0.04</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">float</span> roughness = <span class="number">0.1</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    normal Normal = N,</span></span></span><br><span class="line"><span class="params"><span class="function">    output closure color BSDF = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    color reflection_tint = <span class="built_in">color</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    color transmission_tint = <span class="built_in">color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="type">float</span> roughness_x = roughness;</span><br><span class="line">    <span class="type">float</span> roughness_y = roughness;</span><br><span class="line">    vector tangent = <span class="built_in">vector</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    color f90 = <span class="built_in">color</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="type">float</span> exponent = <span class="number">5</span>;</span><br><span class="line">    BSDF = <span class="built_in">generalized_schlick_bsdf</span>(Normal, tangent, reflection_tint, transmission_tint, roughness_x, roughness_y, f0, f90, exponent, distribution);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在OSL模式下对齐渲染效果是一个巨大的进步，之后我就只需要对照osl的实现修改普通渲染模式下的实现。在微表面模型设置为<code>beckmann</code>，fresnel项使用schlick近似，使用<code>generalized_schlick_bsdf</code>渲染时，Blender中的bsdf计算可以转化为以下公式：</p></li></ol><p>$$ result &#x3D; \frac{F * D}{4 * cos\theta_i * (1 + G_{l} + G(v))} $$</p><p>$$ D &#x3D; D_{NDF_Beckmann} (n,h,α)&#x3D;\frac{1}{(\pi α^2 (n·h)^4 )} e^{(\frac{(n·h)^2-1}{α^2 (n·h)^2 })} $$</p><p>$$ G(v) &#x3D; G_{GSF_Beckmann} &#x3D; \frac{1.0 - 1.259c + 0.369c^2}{3.535c + 2.181c^2} $$</p><p>$$ 其中：c &#x3D; \frac{n·v}{ \alpha \sqrt{1 - (n·v)^2} } $$<br>$$ F &#x3D; F_{Schlick}(v,h) &#x3D; f0 + (1 - f0) * (1-v·h)^5 $$</p><ol start="11"><li><strong>结论</strong>：目前通过对比Blender和Mitsuba源码得到的结论是：在我们的流程中，Blender使用的Glossy BSDF里面不包含Fresnel项的赋值和计算，因此Fresnel值在进行beckmann_setup的时候被设置为<code>MicrofacetFresnel::NONE</code>（BSDF计算对比如下图）。在修改时要注意两边的Roughness有没有进行平方映射要对齐，通过对源码的阅读，Mistuba的Roughness是不进行平方映射的，因此Blender中也要去掉平方映射。其中，G项的不同我本来以为是Blender写错了，后来才发现还是自己太无知了，Blender使用的是高度相关遮蔽阴影型，而Mitsuba使用的是分离遮蔽阴影型。虽然具体计算不同但原理相同，计算结果差异也可忽略。具体可以参考毛星云大佬的文章：<a href="https://zhuanlan.zhihu.com/p/81708753">https://zhuanlan.zhihu.com/p/81708753</a><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202312272157.jpg" title="bsdf公式对比" alt="bsdf公式对比" width="100%" align="middle"></li></ol><h3 id="Blender-调试流程"><a href="#Blender-调试流程" class="headerlink" title="Blender 调试流程"></a>Blender 调试流程</h3><ol><li>下载Blender源码<br>最好在Blender官方Git项目上选择一个稳定的branch，比如我选择的是blender-v4.0-release和blender-v3.6-release。可以用命令行git clone也可以直接download zip。笔者由于当时git网络不好使都是直接下载代码压缩包解压的，主要用到的是blender-v4.0-release这个分支。</li></ol><ul><li>Blender仓库地址：<a href="https://github.com/blender/blender">https://github.com/blender/blender</a></li><li>Git clone指定分支指令：<code>git clone -b blender-v4.0-release https://github.com/blender/blender</code></li></ul><ol start="2"><li>下载SVN，并使用SVN下载Blender编译需要的库，SVN可以理解为另一种形式的git，具体的区别笔者也米有深入了解，主打一个能用就行。笔者用的是TortoiseSVN，下载的是LTS 64位版本。下载后就可以像git一样在文件资源管理器右键寻找svn使用。</li></ol><ul><li>TortoiseSVN下载地址：<a href="https://tortoisesvn.net/downloads.html">https://tortoisesvn.net/downloads.html</a></li></ul><ol start="3"><li>在Blender源码的同级路径新建lib文件夹，再在其中新建win64_vc15文件夹，之后文件资源管理器右键选择<code>SVN Checkout</code>，在URL of repository一栏输入Blender官方提供lib下载地址，在这里要注意，SVN也有版本管理，默认是HEAD revision，不同的Blender版本最好选择不同的revision，可以在SVN的GUI页面选择Show log，在其中查看自己下载的Blender版本对应的revision代号。比如，笔者下载的blender-v4.0-release分支，打开revision log之后，选择的是Message为“Windows: 4.0 Liabrary Update”的revision，代号为63491，所以直接把63491填到revision后面的框内点击ok就可以下载对应的lib。</li></ol><ul><li>Blender官方提供的lib下载地址：<a href="https://svn.blender.org/svnroot/bf-blender/trunk/lib/win64_vc15">https://svn.blender.org/svnroot/bf-blender/trunk/lib/win64_vc15</a></li></ul><ol start="4"><li><p>完成源码和library下载后的文件夹结构：<br>├────blender&#x2F;<br>│    ├────.git&#x2F;<br>│    ├────build_files&#x2F;<br>│    ├────extern&#x2F;<br>│    ├────intern&#x2F;<br>│    ├────locale&#x2F;<br>│    ├────release&#x2F;<br>│    ├────scripts&#x2F;<br>│    ├────tests&#x2F;<br>│    ├────tools&#x2F;<br>│    ├────make.bat<br>│    ├────CMakeLists.txt<br>│    ├────pyproject.toml<br>│    ├────README.md<br>│    └────···<br>├────lib&#x2F;<br>│    ├────win64_vc15&#x2F;<br>│    │    ├────alembic<br>│    │    ├────blosc<br>│    │    ├────boost<br>│    │    ├────brotli<br>└────└────└────···</p></li><li><p>编译构建，在blender源码目录下，使用cmd进行命令行操作。<br>4.1.用命令行直接编译，生成文件在 build_windows_Full_x64_vc16_Release\bin\Release</p></li></ol><ul><li>命令：<code>make</code></li></ul><p>4.2. 生成IDE工程，在 build_windows_Full_x64_vc16_Release 文件夹中生成VS工程。打开 Blender.sln，</p><ul><li>命令：<code>make full nobuild</code><br>4.2.1. CMakePredefinedTargets&#x2F;INSTALL 工程上右键，执行 Build，这步会将一些文件放到输出目录。这个只需执行一次，不过切换Debug&#x2F;Release，也要执行一次。<br>4.2.2. blender工程是默认工程，直接点击绿色三角。</li></ul><h3 id="Blender-源码修改步骤"><a href="#Blender-源码修改步骤" class="headerlink" title="Blender 源码修改步骤"></a>Blender 源码修改步骤</h3><ol><li><p>把输入的Color值作为f0传递给bsdf，Blender中用了一些很神奇的操作传值，主要的读值操作在<code>intern\cycles\kernel\svm\closure.h</code>的<code>svm_node_closure_bsdf</code>函数中，集中在函数体的开头，当时也读了一段时间才读懂，由于篇幅限制此处不做详细解释，后续可能会单独写一篇。而传值操作在<code>intern\cycles\scene\shader_nodes.cpp</code>中的<code>void GlossyBsdfNode::compile</code>函数中，对该函数的修改:</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  closure = distribution;</span><br><span class="line"></span><br><span class="line">  /* TODO: Just use weight for legacy MultiGGX? Would also simplify OSL. */</span><br><span class="line">  if (closure == CLOSURE_BSDF_MICROFACET_MULTI_GGX_ID) &#123;</span><br><span class="line">    BsdfNode::compile(</span><br><span class="line">        compiler, input(&quot;Roughness&quot;), input(&quot;Anisotropy&quot;), input(&quot;Rotation&quot;), input(&quot;Color&quot;));</span><br><span class="line">  &#125;</span><br><span class="line">  else &#123;</span><br><span class="line"><span class="deletion">-    BsdfNode::compile(compiler, input(&quot;Roughness&quot;), input(&quot;Anisotropy&quot;), input(&quot;Rotation&quot;));</span></span><br><span class="line"><span class="addition">+    BsdfNode::compile(compiler, input(&quot;Roughness&quot;), input(&quot;Anisotropy&quot;), input(&quot;Rotation&quot;), input(&quot;Color&quot;));</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>在<code>intern\cycles\kernel\svm\closure.h</code>的<code>svm_node_closure_bsdf</code>函数中添加Fresnel项的内存分配以及材质信息赋值，这个函数相当于是设置材质固有信息，比如roughness和Normal等，没有拿到入射光线出射光线等信息，并不直接进行bsdf计算。(这里由于我是和指定的mistuba模型对齐，使用schlick近似，因此直接把exponent设置为5，如果有别的需求也可以添加node输入节点后传值设置。)</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">    case CLOSURE_BSDF_MICROFACET_GGX_ID:</span><br><span class="line">    case CLOSURE_BSDF_MICROFACET_BECKMANN_ID:</span><br><span class="line">    case CLOSURE_BSDF_ASHIKHMIN_SHIRLEY_ID:</span><br><span class="line">    case CLOSURE_BSDF_MICROFACET_MULTI_GGX_ID: &#123;</span><br><span class="line">#ifdef __CAUSTICS_TRICKS__</span><br><span class="line">      if (!kernel_data.integrator.caustics_reflective &amp;&amp; (path_flag &amp; PATH_RAY_DIFFUSE))</span><br><span class="line">        break;</span><br><span class="line">#endif</span><br><span class="line">      Spectrum weight = closure_weight * mix_weight;</span><br><span class="line">      ccl_private MicrofacetBsdf *bsdf = (ccl_private MicrofacetBsdf *)bsdf_alloc(</span><br><span class="line">          sd, sizeof(MicrofacetBsdf), weight);</span><br><span class="line"><span class="addition">+      ccl_private FresnelGeneralizedSchlick *fresnel =</span></span><br><span class="line"><span class="addition">+          (bsdf != NULL) ? (ccl_private FresnelGeneralizedSchlick *)closure_alloc_extra(</span></span><br><span class="line"><span class="addition">+                                sd, sizeof(FresnelGeneralizedSchlick)) : NULL;</span></span><br><span class="line"><span class="deletion">-      if (!bsdf) &#123;</span></span><br><span class="line"><span class="addition">+      if (!bsdf || !fresnel) &#123;</span></span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="deletion">-      float roughness = sqr(param1);</span></span><br><span class="line"><span class="addition">+      float roughness = param1;</span></span><br><span class="line"></span><br><span class="line"><span class="deletion">-      bsdf-&gt;ior = 1.0f;</span></span><br><span class="line"><span class="addition">+      bsdf-&gt;ior = 0.0f;</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+      kernel_assert(stack_valid(data_node.w));</span></span><br><span class="line"><span class="addition">+      fresnel-&gt;f0 = rgb_to_spectrum(stack_load_float3(stack, data_node.w));</span></span><br><span class="line"><span class="addition">+      fresnel-&gt;f90 = one_spectrum();</span></span><br><span class="line"><span class="addition">+      fresnel-&gt;exponent = 5;</span></span><br><span class="line"><span class="addition">+      fresnel-&gt;reflection_tint = one_spectrum();</span></span><br><span class="line"><span class="addition">+      fresnel-&gt;transmission_tint = zero_spectrum();</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+      bsdf-&gt;ior = ior_from_F0(fresnel-&gt;f0.x);</span></span><br><span class="line"></span><br><span class="line">      /* compute roughness */</span><br><span class="line">      float anisotropy = clamp(param2, -0.99f, 0.99f);</span><br><span class="line">      if (data_node.y == SVM_STACK_INVALID || fabsf(anisotropy) &lt;= 1e-4f) &#123;</span><br><span class="line">        /* Isotropic case. */</span><br><span class="line">        bsdf-&gt;T = zero_float3();</span><br><span class="line">        bsdf-&gt;alpha_x = roughness;</span><br><span class="line">        bsdf-&gt;alpha_y = roughness;</span><br><span class="line">      &#125;</span><br><span class="line">      else &#123;</span><br><span class="line">        bsdf-&gt;T = stack_load_float3(stack, data_node.y);</span><br><span class="line"></span><br><span class="line">        /* rotate tangent */</span><br><span class="line">        float rotation = stack_load_float(stack, data_node.z);</span><br><span class="line">        if (rotation != 0.0f) &#123;</span><br><span class="line">          bsdf-&gt;T = rotate_around_axis(bsdf-&gt;T, bsdf-&gt;N, rotation * M_2PI_F);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (anisotropy &lt; 0.0f) &#123;</span><br><span class="line">          bsdf-&gt;alpha_x = roughness / (1.0f + anisotropy);</span><br><span class="line">          bsdf-&gt;alpha_y = roughness * (1.0f + anisotropy);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">          bsdf-&gt;alpha_x = roughness * (1.0f - anisotropy);</span><br><span class="line">          bsdf-&gt;alpha_y = roughness / (1.0f - anisotropy);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      /* setup bsdf */</span><br><span class="line">      if (type == CLOSURE_BSDF_MICROFACET_BECKMANN_ID) &#123;</span><br><span class="line">        sd-&gt;flag |= bsdf_microfacet_beckmann_setup(bsdf);</span><br><span class="line"><span class="addition">+        bsdf_microfacet_setup_fresnel_generalized_schlick(kg, bsdf, sd, fresnel, false);</span></span><br><span class="line">      &#125;</span><br><span class="line">      else if (type == CLOSURE_BSDF_ASHIKHMIN_SHIRLEY_ID) &#123;</span><br><span class="line">        sd-&gt;flag |= bsdf_ashikhmin_shirley_setup(bsdf);</span><br><span class="line">      &#125;</span><br><span class="line">      else &#123;</span><br><span class="line">        sd-&gt;flag |= bsdf_microfacet_ggx_setup(bsdf);</span><br><span class="line">        if (type == CLOSURE_BSDF_MICROFACET_MULTI_GGX_ID) &#123;</span><br><span class="line">          kernel_assert(stack_valid(data_node.w));</span><br><span class="line">          const Spectrum color = rgb_to_spectrum(stack_load_float3(stack, data_node.w));</span><br><span class="line">          bsdf_microfacet_setup_fresnel_constant(kg, bsdf, sd, color);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>加了上面的代码之后发现Blender无法正常渲染，整个人脸部分都是全黑色的，printf输出debug之后发现是上述增加的<code>closure_alloc_extra</code>无法为Fresnel项分配内存，到函数内部debug发现是sd-&gt;num_closure变量不够用，因此找到了设置该变量的位置：<code>intern\cycles\scene\shader_graph.cpp</code>中的<code>int ShaderGraph::get_num_closures()</code>，修改如下：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">  int num_closures = 0;</span><br><span class="line">  foreach (ShaderNode *node, nodes) &#123;</span><br><span class="line">    ClosureType closure_type = node-&gt;get_closure_type();</span><br><span class="line">    if (closure_type == CLOSURE_NONE_ID) &#123;</span><br><span class="line">      continue;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (CLOSURE_IS_BSSRDF(closure_type)) &#123;</span><br><span class="line">      num_closures += 3;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (CLOSURE_IS_BSDF_MULTISCATTER(closure_type)) &#123;</span><br><span class="line">      num_closures += 2;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (CLOSURE_IS_PRINCIPLED(closure_type)) &#123;</span><br><span class="line">      num_closures += 12;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (CLOSURE_IS_VOLUME(closure_type)) &#123;</span><br><span class="line">      /* TODO(sergey): Verify this is still needed, since we have special minimized volume storage</span><br><span class="line">       * for the volume steps. */</span><br><span class="line">      num_closures += MAX_VOLUME_STACK_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (closure_type == CLOSURE_BSDF_MICROFACET_BECKMANN_GLASS_ID ||</span><br><span class="line">             closure_type == CLOSURE_BSDF_MICROFACET_GGX_GLASS_ID ||</span><br><span class="line">             closure_type == CLOSURE_BSDF_HAIR_CHIANG_ID ||</span><br><span class="line">             closure_type == CLOSURE_BSDF_HAIR_HUANG_ID)</span><br><span class="line">    &#123;</span><br><span class="line">      num_closures += 2;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="addition">+    else if (closure_type == CLOSURE_BSDF_MICROFACET_BECKMANN_ID)</span></span><br><span class="line"><span class="addition">+    &#123;</span></span><br><span class="line"><span class="addition">+      num_closures += 2;</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line">    else &#123;</span><br><span class="line">    //   printf(&quot;this is else, num_closures+1.\n&quot;);</span><br><span class="line">      ++num_closures;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return num_closures;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>修改之后，Blender可以正常渲染了，但是整体的高光效果非常暗，整体亮度偏低，这里我又做了很多对照实现，分层渲染分析高光的Color、直接光、间接光，最后发现高光部分的直接光和Ground Truth对照组（OSL渲染的generalized_bsdf）有一个大致的线性倍数关系，实验后发现倍数刚好是f0的值，查看glossy bsdf node的OSL代码后发现，Blender的逻辑似乎是在BSDF计算后再乘上Color值，而我把f0值直接输入Color就会导致错误产生，为了避免这种干扰，我选择修改Glossy BSDF Node的输入节点设置，增加一个f0输入接口，而Color值设为1.0，修改位置如下：</p></li></ol><ul><li><p><code>intern\cycles\scene\shader_nodes.cpp</code>中的<code>NODE(GlossyBsdfNode)</code>:</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">  NodeType *type = NodeType::add(&quot;glossy_bsdf&quot;, create, NodeType::SHADER);</span><br><span class="line"></span><br><span class="line">  SOCKET_IN_COLOR(color, &quot;Color&quot;, make_float3(0.8f, 0.8f, 0.8f));</span><br><span class="line">  SOCKET_IN_NORMAL(normal, &quot;Normal&quot;, zero_float3(), SocketType::LINK_NORMAL);</span><br><span class="line">  SOCKET_IN_FLOAT(surface_mix_weight, &quot;SurfaceMixWeight&quot;, 0.0f, SocketType::SVM_INTERNAL);</span><br><span class="line"></span><br><span class="line">  static NodeEnum distribution_enum;</span><br><span class="line">  distribution_enum.insert(&quot;beckmann&quot;, CLOSURE_BSDF_MICROFACET_BECKMANN_ID);</span><br><span class="line">  distribution_enum.insert(&quot;ggx&quot;, CLOSURE_BSDF_MICROFACET_GGX_ID);</span><br><span class="line">  distribution_enum.insert(&quot;ashikhmin_shirley&quot;, CLOSURE_BSDF_ASHIKHMIN_SHIRLEY_ID);</span><br><span class="line">  distribution_enum.insert(&quot;multi_ggx&quot;, CLOSURE_BSDF_MICROFACET_MULTI_GGX_ID);</span><br><span class="line">  SOCKET_ENUM(distribution, &quot;Distribution&quot;, distribution_enum, CLOSURE_BSDF_MICROFACET_GGX_ID);</span><br><span class="line"></span><br><span class="line">  SOCKET_IN_VECTOR(tangent, &quot;Tangent&quot;, zero_float3(), SocketType::LINK_TANGENT);</span><br><span class="line"></span><br><span class="line">  SOCKET_IN_FLOAT(roughness, &quot;Roughness&quot;, 0.5f);</span><br><span class="line">  SOCKET_IN_FLOAT(anisotropy, &quot;Anisotropy&quot;, 0.0f);</span><br><span class="line">  SOCKET_IN_FLOAT(rotation, &quot;Rotation&quot;, 0.0f);</span><br><span class="line"></span><br><span class="line"><span class="addition">+  SOCKET_IN_COLOR(f0, &quot;F0&quot;, make_float3(0.5f, 0.5f, 0.5f));</span></span><br><span class="line"></span><br><span class="line">  SOCKET_OUT_CLOSURE(BSDF, &quot;BSDF&quot;);</span><br><span class="line"></span><br><span class="line">  return type;</span><br></pre></td></tr></table></figure></li><li><p><code>intern\cycles\scene\shader_nodes.cpp</code>中的<code>void GlossyBsdfNode::compile</code>，把原来的<code>input(&quot;Color&quot;)</code>改为<code>input(&quot;F0&quot;)</code>:</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  closure = distribution;</span><br><span class="line"></span><br><span class="line">  /* TODO: Just use weight for legacy MultiGGX? Would also simplify OSL. */</span><br><span class="line">  if (closure == CLOSURE_BSDF_MICROFACET_MULTI_GGX_ID) &#123;</span><br><span class="line">    BsdfNode::compile(</span><br><span class="line">        compiler, input(&quot;Roughness&quot;), input(&quot;Anisotropy&quot;), input(&quot;Rotation&quot;), input(&quot;Color&quot;));</span><br><span class="line">  &#125;</span><br><span class="line">  else &#123;</span><br><span class="line"><span class="deletion">-    BsdfNode::compile(compiler, input(&quot;Roughness&quot;), input(&quot;Anisotropy&quot;), input(&quot;Rotation&quot;));</span></span><br><span class="line"><span class="addition">+    BsdfNode::compile(compiler, input(&quot;Roughness&quot;), input(&quot;Anisotropy&quot;), input(&quot;Rotation&quot;), input(&quot;F0&quot;));</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p><code>intern\cycles\scene\shader_nodes.h</code>中的GlossyBsdfNode定义：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class GlossyBsdfNode : public BsdfNode &#123;</span><br><span class="line"> public:</span><br><span class="line">  SHADER_NODE_CLASS(GlossyBsdfNode)</span><br><span class="line"></span><br><span class="line">  void simplify_settings(Scene *scene);</span><br><span class="line">  ClosureType get_closure_type()</span><br><span class="line">  &#123;</span><br><span class="line">    return distribution;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  NODE_SOCKET_API(float3, tangent)</span><br><span class="line">  NODE_SOCKET_API(float, roughness)</span><br><span class="line">  NODE_SOCKET_API(float, anisotropy)</span><br><span class="line">  NODE_SOCKET_API(float, rotation)</span><br><span class="line"><span class="addition">+  NODE_SOCKET_API(float3, f0)</span></span><br><span class="line">  NODE_SOCKET_API(ClosureType, distribution)</span><br><span class="line">  </span><br><span class="line">  void attributes(Shader *shader, AttributeRequestSet *attributes);</span><br><span class="line">  bool has_attribute_dependency()</span><br><span class="line">  &#123;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  bool is_isotropic();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><code>source\blender\nodes\shader\nodes\node_shader_bsdf_glossy.cc</code>中的<code>static void node_declare</code>函数中：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  b.add_input&lt;decl::Color&gt;(&quot;Color&quot;).default_value(&#123;0.8f, 0.8f, 0.8f, 1.0f&#125;);</span><br><span class="line">  b.add_input&lt;decl::Float&gt;(&quot;Roughness&quot;)</span><br><span class="line">      .default_value(0.5f)</span><br><span class="line">      .min(0.0f)</span><br><span class="line">      .max(1.0f)</span><br><span class="line">      .subtype(PROP_FACTOR);</span><br><span class="line">  b.add_input&lt;decl::Float&gt;(&quot;Anisotropy&quot;).default_value(0.0f).min(-1.0f).max(1.0f);</span><br><span class="line">  b.add_input&lt;decl::Float&gt;(&quot;Rotation&quot;)</span><br><span class="line">      .default_value(0.0f)</span><br><span class="line">      .min(0.0f)</span><br><span class="line">      .max(1.0f)</span><br><span class="line">      .subtype(PROP_FACTOR);</span><br><span class="line">  b.add_input&lt;decl::Vector&gt;(&quot;Normal&quot;).hide_value();</span><br><span class="line">  b.add_input&lt;decl::Vector&gt;(&quot;Tangent&quot;).hide_value();</span><br><span class="line">  b.add_input&lt;decl::Float&gt;(&quot;Weight&quot;).unavailable();</span><br><span class="line"><span class="addition">+  b.add_input&lt;decl::Color&gt;(&quot;F0&quot;).default_value(&#123;0.5f, 0.5f, 0.5f, 1.0f&#125;);</span></span><br><span class="line">  b.add_output&lt;decl::Shader&gt;(&quot;BSDF&quot;);</span><br></pre></td></tr></table></figure></li></ul><ol start="5"><li><p>为了保持OSL模式下渲染效果也一致，修改了<code>intern\cycles\kernel\osl\shaders\node_glossy_bsdf.osl</code>，如下：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">shader node_glossy_bsdf(color Color = 0.8,</span><br><span class="line">                        string distribution = &quot;ggx&quot;,</span><br><span class="line">                        float Roughness = 0.2,</span><br><span class="line">                        float Anisotropy = 0.0,</span><br><span class="line">                        float Rotation = 0.0,</span><br><span class="line">                        normal Normal = N,</span><br><span class="line">                        normal Tangent = 0.0,</span><br><span class="line"><span class="addition">+                        color F0 = 0.0,</span></span><br><span class="line">                        output closure color BSDF = 0)</span><br><span class="line">&#123;</span><br><span class="line">  /* compute roughness */</span><br><span class="line">  float roughness = Roughness * Roughness;</span><br><span class="line">  float roughness_u, roughness_v;</span><br><span class="line">  float aniso = clamp(Anisotropy, -0.99, 0.99);</span><br><span class="line"></span><br><span class="line">  /* rotate tangent around normal */</span><br><span class="line">  vector T = Tangent;</span><br><span class="line"></span><br><span class="line">  if (abs(aniso) &lt;= 1e-4) &#123;</span><br><span class="line">    roughness_u = roughness;</span><br><span class="line">    roughness_v = roughness;</span><br><span class="line">  &#125;</span><br><span class="line">  else &#123;</span><br><span class="line">    if (Rotation != 0.0)</span><br><span class="line">      T = rotate(T, Rotation * M_2PI, point(0.0, 0.0, 0.0), Normal);</span><br><span class="line"></span><br><span class="line">    if (aniso &lt; 0.0) &#123;</span><br><span class="line">      roughness_u = roughness / (1.0 + aniso);</span><br><span class="line">      roughness_v = roughness * (1.0 + aniso);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">      roughness_u = roughness * (1.0 - aniso);</span><br><span class="line">      roughness_v = roughness / (1.0 - aniso);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (distribution == &quot;Multiscatter GGX&quot;)</span><br><span class="line">    BSDF = Color * microfacet_multi_ggx_aniso(Normal, T, roughness_u, roughness_v, Color);</span><br><span class="line"><span class="addition">+  else if (distribution == &quot;Beckmann&quot; || distribution == &quot;beckmann&quot;)</span></span><br><span class="line"><span class="addition">+  &#123;</span></span><br><span class="line"><span class="addition">+    color reflection_tint = color(1, 1, 1);</span></span><br><span class="line"><span class="addition">+    color transmission_tint = color(0, 0, 0);</span></span><br><span class="line"><span class="addition">+    float roughness_x = Roughness;</span></span><br><span class="line"><span class="addition">+    float roughness_y = Roughness;</span></span><br><span class="line"><span class="addition">+    color F90 = color(1, 1, 1);</span></span><br><span class="line"><span class="addition">+    BSDF = generalized_schlick_bsdf(Normal, T, reflection_tint, transmission_tint, roughness_x, roughness_y, F0, F90, 5, distribution);</span></span><br><span class="line"><span class="addition">+  &#125;</span></span><br><span class="line">  else</span><br><span class="line">    BSDF = Color * microfacet(distribution, Normal, T, roughness_u, roughness_v, 0.0, 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>Blender中创建ShaderData变量的位置在：<code>intern\cycles\kernel\integrator\shader_surface.h</code>的<code>ccl_device int integrate_surface</code>函数中</p></li><li><p><code>source\blender\nodes\shader\nodes\node_shader_bsdf_glossy.cc</code>文件中有一部分也用了glossy bsdf node的输入，不过这部分被包裹在<code>#ifdef WITH_MATERIALX</code>定义中，因此应该只有materialX时才会用到。</p></li></ol><h3 id="另一种可能的Blender源码修改方法"><a href="#另一种可能的Blender源码修改方法" class="headerlink" title="另一种可能的Blender源码修改方法"></a>另一种可能的Blender源码修改方法</h3><p>在后面做其他工作的时候又想到因为Principled BSDF用的是generalized bsdf，是否可以直接在里面加一个beckmann分布，有了之前的经验，这次很快就把该分布加上了，但是渲染效果偏暗并不能对齐，这里由于牵扯的变量太多了，时间原因暂且不深究，只在下面记录在Principled BSDF加入beckmann分布选项的方法：</p><ol><li><code>source\blender\makesrna\intern\rna_nodetree.cc</code>中：<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static const EnumPropertyItem node_principled_distribution_items[] = &#123;</span><br><span class="line"><span class="addition">+    &#123;SHD_GLOSSY_BECKMANN, &quot;BECKMANN&quot;, 0, &quot;Beckmann&quot;, &quot;&quot;&#125;,</span></span><br><span class="line">    &#123;SHD_GLOSSY_GGX, &quot;GGX&quot;, 0, &quot;GGX&quot;, &quot;&quot;&#125;,</span><br><span class="line">    &#123;SHD_GLOSSY_MULTI_GGX,</span><br><span class="line">     &quot;MULTI_GGX&quot;,</span><br><span class="line">     0,</span><br><span class="line">     &quot;Multiscatter GGX&quot;,</span><br><span class="line">     &quot;GGX with additional correction to account for multiple scattering, preserve energy and &quot;</span><br><span class="line">     &quot;prevent unexpected darkening at high roughness&quot;&#125;,</span><br><span class="line">    &#123;0, nullptr, 0, nullptr, nullptr&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><code>intern\cycles\blender\shader.cpp</code>中：<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  else if (b_node.is_a(&amp;RNA_ShaderNodeBsdfPrincipled)) &#123;</span><br><span class="line">    BL::ShaderNodeBsdfPrincipled b_principled_node(b_node);</span><br><span class="line">    PrincipledBsdfNode *principled = graph-&gt;create_node&lt;PrincipledBsdfNode&gt;();</span><br><span class="line">    switch (b_principled_node.distribution()) &#123;</span><br><span class="line"><span class="addition">+    case BL::ShaderNodeBsdfPrincipled::distribution_BECKMANN:</span></span><br><span class="line"><span class="addition">+        principled-&gt;set_distribution(CLOSURE_BSDF_MICROFACET_BECKMANN_GLASS_ID);</span></span><br><span class="line"><span class="addition">+        break;</span></span><br><span class="line">      case BL::ShaderNodeBsdfPrincipled::distribution_GGX:</span><br><span class="line">        principled-&gt;set_distribution(CLOSURE_BSDF_MICROFACET_GGX_GLASS_ID);</span><br><span class="line">        break;</span><br><span class="line">      case BL::ShaderNodeBsdfPrincipled::distribution_MULTI_GGX:</span><br><span class="line">        principled-&gt;set_distribution(CLOSURE_BSDF_MICROFACET_MULTI_GGX_GLASS_ID);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="前期学习阶段中使用到的阅读资料和学到的新知识点"><a href="#前期学习阶段中使用到的阅读资料和学到的新知识点" class="headerlink" title="前期学习阶段中使用到的阅读资料和学到的新知识点"></a>前期学习阶段中使用到的阅读资料和学到的新知识点</h3><h4 id="Cycles官方开发文档"><a href="#Cycles官方开发文档" class="headerlink" title="Cycles官方开发文档"></a>Cycles官方开发文档</h4><ul><li><a href="https://www.cycles-renderer.org/development/">https://www.cycles-renderer.org/development/</a></li><li><a href="https://wiki.blender.org/wiki/Source/Render/Cycles">https://wiki.blender.org/wiki/Source/Render/Cycles</a></li></ul><h4 id="Next-Event-Estimation（NEE）"><a href="#Next-Event-Estimation（NEE）" class="headerlink" title="Next Event Estimation（NEE）"></a>Next Event Estimation（NEE）</h4><ol><li>在查看Blender源码的过程中发现了一个<code>DEVICE_KERNEL_INTEGRATOR_SHADE_SURFACE_MNEE</code>，查询后认为MNEE指的应该是Manifold Next Event Estimation，这是一种可以正确的渲染焦散（caustic）的路径追踪方式。</li></ol><ul><li>MNEE论文：<a href="https://dl.acm.org/doi/10.5555/2858834.2858844">https://dl.acm.org/doi/10.5555/2858834.2858844</a></li><li>相关讨论：<a href="https://www.zhihu.com/question/322343601">https://www.zhihu.com/question/322343601</a></li></ul><ol start="2"><li>其中，NEE是Next Event Estimation的缩写，指的是次事件估计。次事件估计是一种多重重要性采样的方法，简而言之就是对于每次bounce，直接光照通过光源采样得到，间接光照通过BSDF采样得到，并且最后通过多重重要性采样结合起来。</li></ol><h4 id="HIP"><a href="#HIP" class="headerlink" title="HIP"></a>HIP</h4><p>ROCm平台是平行于CUDA的概念，是AMD的软件平台，用于A卡上面加速GPU计算，在源码级别支持CUDA程序。而HIP是在A卡上使用的编程模型，对标CUDA编程模型。HIP几乎是克隆CUDA，大多数情况下稍加修改就能转换，并且可以在N卡上运行。</p><ul><li>参考资料：<a href="https://blog.csdn.net/chongbin007/article/details/124043701">https://blog.csdn.net/chongbin007/article/details/124043701</a></li></ul><h4 id="clang-fromat"><a href="#clang-fromat" class="headerlink" title="clang-fromat"></a>clang-fromat</h4><p>clang-fromat是一种代码风格统一管理工具，Blender用其进行代码的风格统一和规范，所谓代码风格指的是：修饰符偏移，括号对齐，宏定义对齐等格式上的规范。</p><ul><li>参考资料：<a href="https://blog.csdn.net/weixin_43717839/article/details/129382657">https://blog.csdn.net/weixin_43717839/article/details/129382657</a></li></ul><h4 id="Open-Shading-Language（OSL）"><a href="#Open-Shading-Language（OSL）" class="headerlink" title="Open Shading Language（OSL）"></a>Open Shading Language（OSL）</h4><p>OSL是一种语法类似C语言的开放式着色语言，在blender中可以用OSL实现自己创建shading node。在渲染时.osl文件被编译为用于渲染的.oso文件，大多数支持OSL着色器的渲染引擎都附带OSL编译器。<br>参考资料：</p><ul><li><a href="https://docs.blender.org/manual/en/latest/render/shader_nodes/osl.html">https://docs.blender.org/manual/en/latest/render/shader_nodes/osl.html</a></li><li><a href="https://github.com/AcademySoftwareFoundation/OpenShadingLanguage/blob/main/src/doc/osl-languagespec.pdf">https://github.com/AcademySoftwareFoundation/OpenShadingLanguage/blob/main/src/doc/osl-languagespec.pdf</a></li><li><a href="https://juejin.cn/post/7147477548220776484">https://juejin.cn/post/7147477548220776484</a></li></ul><h4 id="OptiX"><a href="#OptiX" class="headerlink" title="OptiX"></a>OptiX</h4><p>OpitX和Cuda都是NVidia的渲染框架，OptiX是专为光线追踪设计的，相比与Cuda在渲染更复杂的场景或者材质时可以提供更快的渲染时间。另外，目前在Blender中要使用OSL编程着色模型并且使用GPU渲染的话，似乎只支持OptiX不支持Cuda（截至2023.12.21，Blender4.0）。</p><ul><li>参考资料：<a href="https://zhuanlan.zhihu.com/p/648965721">https://zhuanlan.zhihu.com/p/648965721</a></li></ul><h4 id="Cycles-Kernel-Language"><a href="#Cycles-Kernel-Language" class="headerlink" title="Cycles Kernel Language"></a>Cycles Kernel Language</h4><ul><li><a href="https://wiki.blender.org/wiki/Source/Render/Cycles/KernelLanguage">https://wiki.blender.org/wiki/Source/Render/Cycles/KernelLanguage</a></li></ul><h4 id="Wavefront-Path-Tracing"><a href="#Wavefront-Path-Tracing" class="headerlink" title="Wavefront Path Tracing:"></a>Wavefront Path Tracing:</h4><p>Blender源码中，一种为了解决GPU编程时Kernel函数过大遇到的问题，把一个很大的Kernel拆分成很多小的Kernel的技术。</p><ul><li>参考资料：<a href="https://www.cnblogs.com/Heskey0/p/15973546.html">https://www.cnblogs.com/Heskey0/p/15973546.html</a></li></ul><h4 id="SIMD"><a href="#SIMD" class="headerlink" title="SIMD"></a>SIMD</h4><p>SIMD(Single Instruction Multiple Data)即单指令流多数据流，是一种采用一个控制器来控制多个处理器，同时对一组数据（又称“数据向量”）中的每一个分别执行相同的操作从而实现空间上的并行性的技术。简单来说就是一个指令能够同时处理多个数据。</p><ul><li>参考资料：<a href="https://zhuanlan.zhihu.com/p/55327037">https://zhuanlan.zhihu.com/p/55327037</a></li></ul><h4 id="Open-Shading-Language-教程"><a href="#Open-Shading-Language-教程" class="headerlink" title="Open Shading Language 教程"></a>Open Shading Language 教程</h4><p><a href="https://github.com/AcademySoftwareFoundation/OpenShadingLanguage/blob/main/src/doc/osl-languagespec.pdf">https://github.com/AcademySoftwareFoundation/OpenShadingLanguage/blob/main/src/doc/osl-languagespec.pdf</a></p><h3 id="遇到的其他问题和尝试的其他方案"><a href="#遇到的其他问题和尝试的其他方案" class="headerlink" title="遇到的其他问题和尝试的其他方案"></a>遇到的其他问题和尝试的其他方案</h3><ol><li><p>一开始不确定重编译Blender会不会遇到其他的问题，试图直接使用OSL模式渲染，就是在osl脚本里面调用generalized_schlick_bsdf，但是发现Blender对OSL的支持并不完备，使用GPU渲染只能选择OptiX框架，当时在OSL模式下无法渲染我们的材质球，或许是因为里面节点太多了，显示的报错是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error: Requested OSL group data size (6456) is greater than the maximum supported with OptiX (2048)</span><br></pre></td></tr></table></figure></li><li><p>之后尝试的解决方案是把用shader graph做的节点分模块改写为OSL，再进行渲染，这样的好处是可以通过OptiX编译限制，并且Shader Graph更简洁，缺点是不利于美术人员后续对材质继续修改。但是试验后发现，虽然这样改写后可以渲染，但是Blender4.0使用OptiX渲染SSS的效果是错误的，不能直接使用。</p></li><li><p>后面又考虑了把Diffuse（包括SSS）和Specular分开渲染再合起来，后面通过实践和思考证明这样行不通，一起渲染时，Specular部分的间接光照会带上Diffuse的颜色并且较亮，而分开渲染时Specular的间接光照则是纯黑白的，且比较暗。分开渲染是行不通的，因此综上所述，只能走重编译的道路。</p></li><li><p>Blender3.6到4.0升级遇到的Principled Bsdf节点变化以及自动转换的评估：<br>3.6 Base Color 和Subsurface两个颜色输入，Subsurface是浮点数输入。<br>4.0 只有一个Base Color，自动添加了Mix Color节点，混合之前的两个输入作为Base Color的输入，该节点混合的Factor为原来的Subsurface输入（Clamp Factor）。</p></li></ol><p>Roughness和Normal连接不变。</p><p>3.6的Subsurface除了作为mix factor还会连接在4.0的Subsurface模块的Scale输入上。</p><p>3.6的Specular输入在4.0连接在Specular模块的IOR Level上。</p><p>源码中IOR的描述：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.description(</span><br><span class="line">          &quot;Adjustment to the IOR to increase or decrease specular intensity &quot;</span><br><span class="line">          &quot;(0.5 means no adjustment, 0 removes all reflections, 1 doubles them at normal &quot;</span><br><span class="line">          &quot;incidence)&quot;);</span><br></pre></td></tr></table></figure><p>自动转换后Specular的渲染会有一个很小的亮度差异，但我认为不影响最终效果。<br>但是在测试的过程中发现Blender4.0的SSS效果和之前有很大的差异，但是不能判断该差异是变好了还是变坏了，需要美术人员测试决定。</p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphics </category>
          
          <category> Rendering </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rendering </tag>
            
            <tag> Monte Carlo </tag>
            
            <tag> Path tracing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Quaternions四元数学习笔记（待补充</title>
      <link href="/2023/10/12/Quaternions/"/>
      <url>/2023/10/12/Quaternions/</url>
      
        <content type="html"><![CDATA[<p>参考资料：</p><ul><li><a href="https://www.bilibili.com/video/BV1fx41187tZ">https://www.bilibili.com/video/BV1fx41187tZ</a></li><li><a href="https://www.bilibili.com/video/BV1SW411y7W1">https://www.bilibili.com/video/BV1SW411y7W1</a></li></ul><h3 id="万向结死锁问题（Gimbal-Lock）"><a href="#万向结死锁问题（Gimbal-Lock）" class="headerlink" title="万向结死锁问题（Gimbal Lock）"></a>万向结死锁问题（Gimbal Lock）</h3><p>万向结死锁问题指的是，在使用Euler欧拉角进行旋转的表达时，由于沿着中间轴旋转90度导致的自由度丢失问题。我们在使用欧拉角描述旋转时，x,y,z三个轴互相垂直，以物体本身的坐标系来看，绕某一个轴旋转会导致顺序更靠前的轴旋转，但是不会导致顺序更靠前的轴旋转，可以使用万向结模型来思考这个问题，从外到内依次是xyz，当转动最外圈时，里面两个轴向都会跟着转动。因此，一旦沿y轴旋转了90度，就会导致x轴和z轴完全重合，旋转丧失了一个自由度。</p><h3 id="球极投影（Stereographic-Projection）"><a href="#球极投影（Stereographic-Projection）" class="headerlink" title="球极投影（Stereographic Projection）"></a>球极投影（Stereographic Projection）</h3><p>球极投影是一种</p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphics </category>
          
          <category> Rendering </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rendering </tag>
            
            <tag> Quaternions </tag>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Blender开发相关知识（待补充</title>
      <link href="/2023/10/11/Blender-Plugins/"/>
      <url>/2023/10/11/Blender-Plugins/</url>
      
        <content type="html"><![CDATA[<p>从去年七月接收公司的Blender插件至今也有一年多的时间了，期间断断续续地进行了很多Blender工具的开发，用于制作本科毕业的Demo以及满足流程中美术工作人员的需求，工具也进行了很多次迭代，但是最近在满足新的需求时，发现由于学习时主要是面向尽快投入使用的，自己在工具开发的基础仍然有些薄弱，因此准备再反刍学习一下基础的一些概念，开一个新帖在这里记录一下。(其实是因为当初准备学习的时候没有任何实践看不懂理论orz)<br>参考：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/413506846">https://zhuanlan.zhihu.com/p/413506846</a></li><li><a href="https://zhuanlan.zhihu.com/p/418293645">https://zhuanlan.zhihu.com/p/418293645</a></li></ul><h3 id="一、"><a href="#一、" class="headerlink" title="一、"></a>一、</h3><ul><li>bl_info 插件信息，即在Blender加载插件界面显示的信息。</li><li>register 启用插件时会执行的函数</li><li>unregister 取消启用时会执行的函数</li></ul><h3 id="在Blender环境下安装需要的python包到Blender-Python"><a href="#在Blender环境下安装需要的python包到Blender-Python" class="headerlink" title="在Blender环境下安装需要的python包到Blender Python"></a>在Blender环境下安装需要的python包到Blender Python</h3><ol><li>需要的包：numpy-quaternion<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. path to python.exe</span></span><br><span class="line">python_exe = os.path.join(sys.prefix,<span class="string">&#x27;bin&#x27;</span>, <span class="string">&#x27;python.exe&#x27;</span>)</span><br><span class="line"><span class="comment"># 3. upgrade pip</span></span><br><span class="line">subprocess.call([python_exe, <span class="string">&quot;-m&quot;</span>, <span class="string">&quot;ensurepip&quot;</span>])</span><br><span class="line">subprocess.call([python_exe, <span class="string">&quot;-m&quot;</span>, <span class="string">&quot;pip&quot;</span>, <span class="string">&quot;install&quot;</span>, <span class="string">&quot;--upgrade&quot;</span>, <span class="string">&quot;pip&quot;</span>])</span><br><span class="line"><span class="comment"># 4. install required packages</span></span><br><span class="line">subprocess.call([python_exe, <span class="string">&quot;-m&quot;</span>, <span class="string">&quot;pip&quot;</span>, <span class="string">&quot;install&quot;</span>, <span class="string">&quot;package_name&quot;</span>])</span><br><span class="line"><span class="comment">#注：若没有换pip源可将此句改为</span></span><br><span class="line"><span class="comment">#subprocess.call([python_exe, &quot;-m&quot;, &quot;pip&quot;, &quot;install&quot;, &quot;package_name&quot;,  &quot;-i&quot;, &quot;https://pypi.tuna.tsinghua.edu.cn/simple&quot;])</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Tool Development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blender </tag>
            
            <tag> Plugins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python Useful Function</title>
      <link href="/2023/09/20/Python-Useful-Function/"/>
      <url>/2023/09/20/Python-Useful-Function/</url>
      
        <content type="html"><![CDATA[<p>参考：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/562082459">https://zhuanlan.zhihu.com/p/562082459</a></li></ul><h3 id="Python中的特殊索引方式"><a href="#Python中的特殊索引方式" class="headerlink" title="Python中的特殊索引方式"></a>Python中的特殊索引方式</h3><p>以<code>a = [1,2,3,4,5,6,7,8]</code>为例</p><ol><li>[- n]，倒着数第n个元素</li></ol><ul><li>[-1]，最后一个元素</li><li>同样的[-2]表示倒数第二个元素。</li></ul><ol start="2"><li>[n : m]，从第n项到第m-1项（前闭后开）</li></ol><ul><li>[:-1]，从第一项到倒数第二项</li><li>[:5]，从第1个到第5个(idx从0开始)元素。</li><li>[2:5]，从第3项到第5项元素。</li></ul><ol start="3"><li>[n : m : k]，从第n项开始取，每隔k个取一项，截止到第m-1项（前闭后开），当k为正的时候起始索引应该小于结束索引；当k为负的时候起始索引应该大于结束索引，因为在倒序来看，首先是索引值大的被取到，然后才是索引值小的。</li></ol><ul><li>[::-1]，全列表倒序</li><li>[4::-1]，从第5项倒序取到第0项</li></ul><p><strong>逗号表示维度的分割线</strong></p><ol start="4"><li>[n:m, j:k, g:h]，第0维从n到m，第1维从j到k，第2维从g到h（均为前闭后开）</li></ol><ul><li>[:,:,0]： 前两个维度全选，最后一个维度只取0号索引。</li><li>[…,-1]：…省略维度，表示前面所有维度</li><li>[…,::-1]： 对最后一个维度进行逆序。</li><li>[:,::-1,:]：第二个维度逆序。</li></ul><h3 id="Tensor交换维度"><a href="#Tensor交换维度" class="headerlink" title="Tensor交换维度"></a>Tensor交换维度</h3><h4 id="transpose"><a href="#transpose" class="headerlink" title="transpose()"></a>transpose()</h4><p>可以交换tensor的任意两个维度，但是该函数一次只有两个参数，即一次只能交换两个维度。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import torch</span><br><span class="line">x = torch.randn(8, 6, 5, 4)</span><br><span class="line">y = x.transpose(1,2)  # 交换第二与第三维度</span><br></pre></td></tr></table></figure><h4 id="permute"><a href="#permute" class="headerlink" title="permute()"></a>permute()</h4><p>该函数可以随意交换任意维度，并且可以重新排列整合维度</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import torch</span><br><span class="line">x = torch.randn(8, 6, 5, 4)</span><br><span class="line">y = x.permute(3,0,2,1)</span><br></pre></td></tr></table></figure><h3 id="Numpy交换维度"><a href="#Numpy交换维度" class="headerlink" title="Numpy交换维度"></a>Numpy交换维度</h3><h4 id="transpose-1"><a href="#transpose-1" class="headerlink" title="transpose()"></a>transpose()</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">img = np.transpose(img, (1, 2, 0))</span><br></pre></td></tr></table></figure><h3 id="Numpy挤出维度"><a href="#Numpy挤出维度" class="headerlink" title="Numpy挤出维度"></a>Numpy挤出维度</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">x = np.arange(8).reshape(2, 4)</span><br><span class="line"> </span><br><span class="line"># 添加第0维,输出shape -&gt; (1, 2, 4)</span><br><span class="line">x1 = x[np.newaxis, :]</span><br><span class="line">x1 = x[np.newaxis, ...]</span><br><span class="line">x1 = x[None, :]</span><br><span class="line">x1 = x[None, ...]</span><br><span class="line">print(x1.shape)</span><br><span class="line"> </span><br><span class="line"># 添加第1维, 输出shape -&gt; (2, 1, 4)</span><br><span class="line">x2 = np.expand_dims(x, axis=1)</span><br><span class="line">print(x2.shape)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pytroch </tag>
            
            <tag> Python </tag>
            
            <tag> Numpy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue.js学习及实践笔记</title>
      <link href="/2023/09/14/Vue-js-Learning/"/>
      <url>/2023/09/14/Vue-js-Learning/</url>
      
        <content type="html"><![CDATA[<p>学校社团有做网站的计划，之前刚好接触过一丢丢前端，遂开始摸鱼。</p><span id="more"></span><p>参考资料：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/349318513">https://zhuanlan.zhihu.com/p/349318513</a></li><li><a href="https://cn.vuejs.org/guide/quick-start.html">https://cn.vuejs.org/guide/quick-start.html</a></li><li><a href="https://element.eleme.cn/#/zh-CN/component/installation">https://element.eleme.cn/#/zh-CN/component/installation</a></li><li><a href="https://blog.csdn.net/weixin_46591962/article/details/109145467">https://blog.csdn.net/weixin_46591962/article/details/109145467</a></li></ul><ol><li>首先在Node.js官网安装Node.js: <a href="https://nodejs.org/en">https://nodejs.org/en</a></li><li>安装后新建路径，在cmd分别运行：<blockquote><p>npm create vue@latest<br>cd <your-project-name><br>npm install<br>npm run dev<br>测试没有问题之后Ctrl+C退出。<br>npm install -g vue-cli<br>npm install webpack -g<br>npm install element-ui -S<br>npm install vue-router vue-resource –S<br>npm install moment -S<br>npm run dev</p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue.js </tag>
            
            <tag> Element-UI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GPU 显存分析</title>
      <link href="/2023/09/05/GPU-Memory-Analysis/"/>
      <url>/2023/09/05/GPU-Memory-Analysis/</url>
      
        <content type="html"><![CDATA[<p>前情提要：在做Relighting项目的时候，每次训练图像分辨率增大到512就会报错，显示无法分配显存，但是控制台报错显示的剩余显存是完全足够的，为了训练更高分辨率的Ground Truth图像，不得已开始学习更加细致的GPU显存分析。</p><span id="more"></span><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><ul><li><a href="https://zhuanlan.zhihu.com/p/424512257">https://zhuanlan.zhihu.com/p/424512257</a></li><li>Pytorch官方的profiler教程：<a href="https://pytorch.org/tutorials/recipes/recipes/profiler_recipe.html">https://pytorch.org/tutorials/recipes/recipes/profiler_recipe.html</a></li><li>线上Profile可视化：edge:&#x2F;&#x2F;tracing&#x2F;</li></ul><h4 id="一-使用Torch内置函数而不是Nvidia-smi"><a href="#一-使用Torch内置函数而不是Nvidia-smi" class="headerlink" title="一. 使用Torch内置函数而不是Nvidia-smi"></a>一. 使用Torch内置函数而不是Nvidia-smi</h4><p>在对GPU占用情况进行分析时，通常会使用Nvidia官方提供的控制台命令：Nvidia-smi。但是对于深度学习来说，Pytorch有自己的GPU显存分配机制，Pytorch的机制是使用缓存分配器来管理缓存分配的(因为这样速度快)，但是在缓存分配器的机制下, 一个Tensor就算被释放了，进程也不会把空闲出来的显存还给GPU，而是等待下一个Tensor来填入这一片被释放的空间(即只要一个Tensor对象在后续不会再被使用，那么PyTorch就会自动回收该Tensor所占用的显存，并以缓冲区的形式继续占用显存，所以在nvidia-smi&#x2F;gpustat中看到的显存并没有减少)。因此使用Nvidia-smi并不能准确地实时查看GPU状态，需要使用Pytorch的内置函数：</p><ul><li>torch.cuda.memory_allocated()</li><li>torch.cuda.memory_reserved() 或者 torch.cuda.memory_cached()</li><li>torch.cuda.memory_summary()<br>需要注意的是，上面两个函数输出的结果都是以Bytes为单位的，如果要以MB或者GB为单位需要自己进行换算。</li></ul><h4 id="二-Pytorch的显存层级分配："><a href="#二-Pytorch的显存层级分配：" class="headerlink" title="二. Pytorch的显存层级分配："></a>二. Pytorch的显存层级分配：</h4><p>在PyTorch中，显存是按页为单位进行分配的，这可能是CUDA设备的限制。就算我们只想申请4字节的显存，pytorch也会为我们分配512字节或者1024字节的空间。即就算我们只想申请4字节的显存，pytorch也会先向CUDA设备申请2MB的显存到自己的cache区中，然后pytorch再为我们分配512字节或者1024字节的空间。这个在使用torch.cuda.memory_allocated()的时候可以看出来512字节；用torch.cuda.memory_cached()可以看出向CUDA申请的2MB。<br>Pytorch分配逻辑：</p><ul><li><ol><li>pytorch中的reserved_memory以block的形式存在。</li></ol></li><li><ol start="2"><li>一个allocation的显存被释放后，他所在的block可以被重新被allocate.</li></ol></li><li><ol start="3"><li>分配器尝试寻找能满足requested size的最小cached block，如果这个block 的大小大于requested size，那么这个block可以被split. 如果没有block了，那么分配器就会调用cudaMalloc向CUDA设备申请显存。</li></ol></li><li><ol start="4"><li>如果cudaMalloc失败了，分配器会先尝试释放掉一个足够大的，且没有被split的cached block，并重新尝试allocate。</li></ol></li><li><ol start="5"><li>大于1MB的allocation和小于等于1MB的allocation会被存储在不同的pool中。小的请求会放进2MB的buffer里，大的请求会先尝试使用最小的可用free block，或者用cudaMalloc申请一个新的block。</li></ol></li><li><ol start="6"><li>为了减小碎片化，在所有可用block都没有充足的大小的时候，1MB到10MB的allocation会使allocator申请一个20MB的block，并在上面进行split；为了进一步减小碎片化，大于200MB的块则不能够被split。大于200MB的超大cached blocks仍可满足小于20MB的请求。</li></ol></li></ul><h3 id="三-变量拷贝到显存上时使用-to-device-和cuda-的区别"><a href="#三-变量拷贝到显存上时使用-to-device-和cuda-的区别" class="headerlink" title="三. 变量拷贝到显存上时使用.to(device)和cuda()的区别"></a>三. 变量拷贝到显存上时使用.to(device)和cuda()的区别</h3><p>在实践中我发现对于一个相同的Tensor，使用to.(device)和cuda()两种方式将其移动的GPU上，造成的显存占用略有不同。<br>dbq我是蠢比，只用x.to(device)当然是不行的，因为之后没有用到过这个变量，Pytorch会自动将其释放，但是改成x&#x3D;x.to(device)就没有问题了。</p><h3 id="四-尝试使用Nsight进行可视化分析。"><a href="#四-尝试使用Nsight进行可视化分析。" class="headerlink" title="四. 尝试使用Nsight进行可视化分析。"></a>四. 尝试使用Nsight进行可视化分析。</h3><p>首先尝试控制台调用nsys，参考该帖中的指令：<a href="https://dev-discuss.pytorch.org/t/using-nsight-systems-to-profile-gpu-workload/59%EF%BC%9A">https://dev-discuss.pytorch.org/t/using-nsight-systems-to-profile-gpu-workload/59：</a><br><code>nsys profile -w true -t cuda,nvtx,osrt,cudnn,cublas -s cpu  --capture-range=cudaProfilerApi --stop-on-range-end=true --cudabacktrace=true -x true -o my_profile python main.py</code><br>后面根据我本机上的报错更换了指令，</p><ul><li>unrecognised option ‘–cudabacktrace&#x3D;true’， 删除该命令行参数</li><li>–sample&#x3D;cpu requires administrative privileges.， 以管理员方式打开vscode</li><li>Illegal –trace argument ‘osrt’, Possible –trace values are one or more of ‘cuda’, ‘nvtx’, ‘opengl’, ‘opengl-annotations’, ‘vulkan’, ‘vulkan-annotations’, ‘dx11’, ‘dx11-annotations’, ‘dx12’, ‘dx12-annotations’, ‘wddm’ or ‘none’， 把不在possible value里面的都删除。</li><li>Program not found: python，这个不知道是为什么，猜测与anaconda封装不同的python环境有关，因此增加python的绝对路径进行调用。<br>所以最后的控制台指令变为：<br><code>nsys profile -w true -t cuda,nvtx -s cpu  --capture-range=cudaProfilerApi --stop-on-range-end=true -x true -o my_profile C:\Users\face\anaconda3\envs\py39\python.exe train_rnr_analysis.py</code></li></ul><h3 id="五-网络映射盘的管理员权限问题："><a href="#五-网络映射盘的管理员权限问题：" class="headerlink" title="五. 网络映射盘的管理员权限问题："></a>五. 网络映射盘的管理员权限问题：</h3><p>但是又遇到了新的问题：在win10环境下，管理员权限下无法正确访问到网络映射盘。原因可能是因为：win10 的uac隔离更严格，普通用户权限创建的网络映射盘，管理员权限是无权访问的。<br>请教同学之后发现该服务器windows启动默认打开的是名为face的账户，真正的管理员用户Administrator是默认禁用的，可以在计算机管理取消禁用该用户后重新挂载网络映射盘，也可以管理员权限开启控制台，输入<code>net use Y: \\192.168.16.73\exchange</code>命令进行重新映射。<br>现在nsys终于跑起来了（orz。</p><h3 id="六-The-application-terminated-before-the-collection-started"><a href="#六-The-application-terminated-before-the-collection-started" class="headerlink" title="六. The application terminated before the collection started."></a>六. The application terminated before the collection started.</h3><p>遇到了新的问题：程序正常运行，但运行结束后输出：The application terminated before the collection started. No report was generated.<br>决定先用<a href="https://dev-discuss.pytorch.org/t/using-nsight-systems-to-profile-gpu-workload/59%E4%B8%AD%E7%9A%84%E7%A4%BA%E4%BE%8B%E6%9D%A5%E8%A7%A3%E5%86%B3%E8%BF%99%E4%B8%AA%E9%97%AE%E9%A2%98%EF%BC%8C%E5%86%8D%E5%88%B0%E8%AE%AD%E7%BB%83%E7%A8%8B%E5%BA%8F%E4%B8%8A%E8%B7%91%E3%80%82">https://dev-discuss.pytorch.org/t/using-nsight-systems-to-profile-gpu-workload/59中的示例来解决这个问题，再到训练程序上跑。</a></p><h3 id="七-换用nsight-system-gui"><a href="#七-换用nsight-system-gui" class="headerlink" title="七. 换用nsight system gui"></a>七. 换用nsight system gui</h3><p>用nsight compute gui一直出错，最后改用nsight systems gui，版本为2022.1.3，运行命令即为简单的<code>python train_rnr.py</code>，在服务器上本地运行nsight。唉但是发现使用Nsight的问题是，在timeline上展示出的调用函数都太过底层了，因此我只能把迭代次数和timeline上的重复单元对应起来，却不能很好的进行更细致的分析。<br>但是使用Nsight可以可视化显存占用的变化曲线，可以比较直观的感受到显存的占用情况。</p><h3 id="八-编写memory进行模块化显存占用输出"><a href="#八-编写memory进行模块化显存占用输出" class="headerlink" title="八. 编写memory进行模块化显存占用输出"></a>八. 编写memory进行模块化显存占用输出</h3><p>最后我使用Nsight进行整体的显存占用变化可视化，用自己编写的memory类调用pytorch的内置函数输出分析步骤级的GPU占用，唯一的问题是：假如某一个步骤中GPU最大占用了4个G，但是最后释放完成后只占用了2个G，并且最大占用没有大到改变到pytorch的max_allocated，则不能准确得到这个最大占用的4个G，想知道这个信息只能将该步骤进一步切分分析。<br>Memory类代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="comment"># torch.cuda.empty_cache()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MemoryInfoGPU</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, device_idx = <span class="number">0</span></span>):</span><br><span class="line">        torch.cuda.empty_cache()</span><br><span class="line">        self.device = device_idx</span><br><span class="line">        self.last_allocated = <span class="number">0</span></span><br><span class="line">        self.last_cached = <span class="number">0</span></span><br><span class="line">        self.last_max_allocated = <span class="number">0</span></span><br><span class="line">        self.last_max_cached = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        self.now_allocated = <span class="number">0</span></span><br><span class="line">        self.now_cached = <span class="number">0</span></span><br><span class="line">        self.max_allocated = <span class="number">0</span></span><br><span class="line">        self.max_cached = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        self.queryGPU()</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">queryGPU</span>(<span class="params">self</span>):</span><br><span class="line">        self.last_allocated = self.now_allocated</span><br><span class="line">        self.last_cached = self.now_cached</span><br><span class="line">        self.last_max_allocated = self.max_allocated</span><br><span class="line">        self.last_max_cached = self.max_cached</span><br><span class="line">        </span><br><span class="line">        self.now_allocated = torch.cuda.memory_allocated(device=self.device)</span><br><span class="line">        self.now_cached = torch.cuda.memory_reserved(device=self.device)</span><br><span class="line">        self.max_allocated = torch.cuda.max_memory_allocated(device=self.device)</span><br><span class="line">        self.max_cached = torch.cuda.max_memory_cached(device=self.device)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">printMemoryInfo</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">str</span>(self.device) + <span class="string">&quot; GPU Memory Info: &quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\tNow Allocated:\t&quot;</span>, self.now_allocated/<span class="number">1024.0</span>/<span class="number">1024.0</span>, <span class="string">&quot; MB&quot;</span>,</span><br><span class="line">              <span class="string">&quot;\tNow Cached:\t&quot;</span>, self.now_cached/<span class="number">1024.0</span>/<span class="number">1024.0</span>, <span class="string">&quot; MB&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\tMax Allocated:\t&quot;</span>, self.max_allocated/<span class="number">1024</span>/<span class="number">1024.0</span>, <span class="string">&quot; MB&quot;</span>,</span><br><span class="line">              <span class="string">&quot;\tMax Cached:\t&quot;</span>, self.max_cached/<span class="number">1024.0</span>/<span class="number">1024.0</span>, <span class="string">&quot; MB&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">printConsume</span>(<span class="params">self, message</span>):</span><br><span class="line">        <span class="built_in">print</span>(message)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Consume:\t&quot;</span>, (self.now_allocated - self.last_allocated)/<span class="number">1024.0</span>/<span class="number">1024.0</span>, <span class="string">&quot; MB&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span>(self.max_allocated &gt; self.last_max_allocated):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;But need:\t&quot;</span>, (self.max_allocated - self.last_allocated)/<span class="number">1024.0</span>/<span class="number">1024.0</span>, <span class="string">&quot; MB&quot;</span>)</span><br><span class="line">        <span class="comment"># 如果之前的最大分配非常大，这次没有超过，是不能得出准确的本进程最大分配的。</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_before</span>(<span class="params">self</span>):</span><br><span class="line">        self.queryGPU()</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_after</span>(<span class="params">self, message = <span class="string">&quot;&quot;</span></span>):</span><br><span class="line">        self.queryGPU()</span><br><span class="line">        self.printMemoryInfo()</span><br><span class="line">        self.printConsume(message)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Relighting Project </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GPU </tag>
            
            <tag> Pytroch </tag>
            
            <tag> Machine Learing </tag>
            
            <tag> Nerual Rendering </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Neural Rendering相关学习笔记(待补充)</title>
      <link href="/2023/07/26/Neural-Rendering-Notes/"/>
      <url>/2023/07/26/Neural-Rendering-Notes/</url>
      
        <content type="html"><![CDATA[<p>记录一些关于Neural Rendering的学习笔记，可能有点乱orz。</p><span id="more"></span><p>Neural Rendering其他参考：</p><ul><li><p><a href="https://www.youtube.com/watch?v=otly9jcZ0Jg">https://www.youtube.com/watch?v=otly9jcZ0Jg</a></p></li><li><p><a href="https://www.youtube.com/watch?v=aboFl5ozImM">https://www.youtube.com/watch?v=aboFl5ozImM</a></p></li><li><p>ICLR 2023：《Light Sampling Field and BRDF Representation for Physically-based Neural Rendering》</p></li><li><p><a href="https://www.researchgate.net/publication/369974931_Light_Sampling_Field_and_BRDF_Representation_for_Physically-based_Neural_Rendering">https://www.researchgate.net/publication/369974931_Light_Sampling_Field_and_BRDF_Representation_for_Physically-based_Neural_Rendering</a></p></li><li><p><a href="https://www.youtube.com/watch?v=qpIgS11DlJE">https://www.youtube.com/watch?v=qpIgS11DlJE</a></p></li><li><p><a href="https://docs.unrealengine.com/4.26/en-US/RenderingAndGraphics/Lightmass/VolumetricLightmaps/#:~:text=The%20Volumetric%20Lightmap%20allows%20previewing%20of%20objects%20with,the%20Volumetric%20Lightmap%20until%20lighting%20is%20built%20again">https://docs.unrealengine.com/4.26/en-US/RenderingAndGraphics/Lightmass/VolumetricLightmaps/#:~:text=The%20Volumetric%20Lightmap%20allows%20previewing%20of%20objects%20with,the%20Volumetric%20Lightmap%20until%20lighting%20is%20built%20again</a>.</p></li><li><p>NeRF：</p></li><li><p><a href="https://www.matthewtancik.com/nerf">https://www.matthewtancik.com/nerf</a></p></li><li><p>NeRV：</p></li><li><p><a href="https://pratulsrinivasan.github.io/nerv/">https://pratulsrinivasan.github.io/nerv/</a></p></li><li><p>NeRD：</p></li><li><p><a href="https://pratulsrinivasan.github.io/nerv/">https://pratulsrinivasan.github.io/nerv/</a></p></li><li><p>State of Art of Neural Rendering</p></li><li><p><a href="https://arxiv.org/abs/2004.03805">https://arxiv.org/abs/2004.03805</a></p></li></ul><p>2023.7.26，终于通读了一遍大名鼎鼎的Nerf，然后准备看一看源码。</p><ul><li>Paper: <a href="https://dl.acm.org/doi/10.1145/3503250">https://dl.acm.org/doi/10.1145/3503250</a></li><li>Code: </li><li>参考：<a href="https://zhuanlan.zhihu.com/p/630948914">https://zhuanlan.zhihu.com/p/630948914</a></li></ul><h3 id="环境配置："><a href="#环境配置：" class="headerlink" title="环境配置："></a>环境配置：</h3><ul><li>删除新建的nerf环境：conda remove -n nerf –all</li><li>新建nerf环境：conda create -n nerf python&#x3D;3.7</li><li>conda install tensorflow-gpu&#x3D;&#x3D;1.15</li><li>conda install numpy</li><li>conda install matplotlib</li><li>conda install imageio</li><li>pip install imageio-ffmpeg</li><li>conda install configargparse</li></ul><h3 id="遇到的问题："><a href="#遇到的问题：" class="headerlink" title="遇到的问题："></a>遇到的问题：</h3><ol><li>vscode不能使用 conda activate：</li></ol><ul><li><a href="https://blog.csdn.net/weixin_45646006/article/details/115066805">https://blog.csdn.net/weixin_45646006/article/details/115066805</a></li></ul><ol start="2"><li>tensorflow 和 tensorflow-estimator版本不一致</li></ol><ul><li>conda install tensorflow-estimator&#x3D;&#x3D;1.15.1</li><li>不要uninstall， uninstall会把tensorflow也uninstall</li><li>conda install tensorboard&#x3D;&#x3D;1.15.0</li></ul><h3 id="其他需要的数据处理"><a href="#其他需要的数据处理" class="headerlink" title="其他需要的数据处理"></a>其他需要的数据处理</h3><ol><li>下载bash中需要的data，并放到对应的文件夹。</li><li>logs文件夹下新建summaries文件夹</li></ol>]]></content>
      
      
      <categories>
          
          <category> Computer Graphics </category>
          
          <category> Neural Rendering </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rendering </tag>
            
            <tag> Neural Rendering </tag>
            
            <tag> Artificial Intelligence </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Games101_notes</title>
      <link href="/2023/07/20/Games101-Notes/"/>
      <url>/2023/07/20/Games101-Notes/</url>
      
        <content type="html"><![CDATA[<p>Games101做作业的过程中遇到的问题及解决。</p><span id="more"></span><ol><li>virual box 共享文件夹设置：</li></ol><ul><li><a href="https://blog.csdn.net/jumpingpig/article/details/104109395">https://blog.csdn.net/jumpingpig/article/details/104109395</a></li></ul><ol start="2"><li>二维三角形内部判定:</li></ol><ul><li><a href="https://blog.csdn.net/KimHyunA4minute/article/details/40079819">https://blog.csdn.net/KimHyunA4minute/article/details/40079819</a></li></ul><ol start="3"><li>Howework2:</li></ol><ul><li>Super Sample部分，只对Depth Buffer进行细分会导致出现两个三角形覆盖交界处出现黑边，应该吧frame buffer也进行细分，输出时直接下采样。</li></ul><ol start="4"><li>Homework3：</li></ol><ul><li>view_pos插值出了问题，view_pos语义应该是在view space的三角形三个点的坐标，但我感觉这个用什么坐标只要统一就可以，比如如果要传入world space就灯光、相机、mesh都传入world space的坐标，或者都传入view space的坐标。思考：Model matrix的变换是应该体现出来的，但是View Matrix的变换是否收到相机横竖比例不同的影响？（不影响，因为View Matrix里面只有内参，都是刚性变换。）</li><li>灯光衰减系数要使用距离的平方，用距离就不太行，太亮了。</li><li>Texture采样的时候因为加了1.0&#x2F;w会溢出，修改Texture类函数，加了：u &#x3D; (u + width)%width; v同理。</li><li>这里我觉得网上的很多代码选择采样hmap后normalize很没有道理，看上去这个hmap更像是一张normal map，所以我取了采样后的z值作为高度。</li><li>还有一个不明白的点：为什么注释里面要把kn和kh都乘到dU上面，在我看来算dUdV的时候乘kh，算displacement顶点位移的时候乘kn比较合理，但是不乘效果不佳，跟题目设置有关系。</li><li>在写作业的过程中重新学习推导了TBN矩阵，并学习Displacement原理。</li><li>Displacement造成的顶点坐标位移应该是沿着插值得到的法线方向，这里我取的值仍然是z分量，然后在bump shader中计算得到的新法向其实是顶点位移造成的法线变换，所以应该先变换顶点坐标，再赋予新的法向值，这也解释了前面我认为只乘kh是不对的，因为这个法向是通过坐标位移得到的，坐标位移的过程中要乘kn。</li><li>在Displacement Shader为了和示例靠近把diffuse计算的*0.5+0.5去掉了。</li><li>用Z值的Displacement效果不对，改成norm就对了，不准备深究了，因为真正的Displacement Texture应该在一开始mvp之前就参与到修改顶点坐标中？起码应该在view space加入计算。</li><li>还有一个易错点：采样texture的时候先v再u。</li><li>image.at采样得到的数据结构里面是int，直接统一用auto会出问题。</li><li>悲惨的de了很久bug，发现是加权权重搞错了，左边的距离应该作为右边的权重。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer Graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Games101 </tag>
            
            <tag> Notes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机视觉HW3 - Harris角点检测</title>
      <link href="/2023/06/02/Harris-Corner-Detection/"/>
      <url>/2023/06/02/Harris-Corner-Detection/</url>
      
        <content type="html"><![CDATA[<p>课程名称：计算机视觉<br>实验项目名称：harris角点检测<br>实验日期：2020 年 12 月 16 日</p><span id="more"></span><h3 id="一、实验目的和要求"><a href="#一、实验目的和要求" class="headerlink" title="一、实验目的和要求"></a>一、实验目的和要求</h3><ul><li>读入摄像头，回放视频。按一下空格键，则暂停回放，并将当前帧图像做 Harris Corner 检测 ，并将检测的结果叠加在原来图像上。<br>1.需要自己写代码实现 Harris Corner 检测算法，不能直接调用OpenCV 里面与 Harris 角点检测相关的函数；<br>2.显示中间的处理结果及最终的检测结果，包括最大特征值图、最小特征值图、R 图 、原图上叠加检测结果等，并将<br>这些中间结果都输出保存为图像文件。</li></ul><h3 id="二、实验原理"><a href="#二、实验原理" class="headerlink" title="二、实验原理"></a>二、实验原理</h3><h4 id="本实验中主要使用了-Harris-角点检测算法-Harris-Corner-Detection-。"><a href="#本实验中主要使用了-Harris-角点检测算法-Harris-Corner-Detection-。" class="headerlink" title="本实验中主要使用了 Harris 角点检测算法(Harris Corner Detection)。"></a>本实验中主要使用了 Harris 角点检测算法(Harris Corner Detection)。</h4><h5 id="1）算法简介"><a href="#1）算法简介" class="headerlink" title="1）算法简介"></a>1）算法简介</h5><p><strong>匹配问题</strong></p><p>Harris角点检测是Chris Harris和Mike Stephens在1988年提出的。主要用于运动图像的追踪。当时的普遍想法是利用边缘进行追踪，但边缘匹配很难达到预期的效果。即使是当时最优秀的边缘检测算子Canny算子，它的边缘检测也依赖于阈值的选取。所以Harris等人放弃了匹配边缘，转而寻找一些特殊的点来匹配，这些点是边缘线段的连接点，它们表征了图像的结构，代表了图像局部的特征。</p><p><strong>什么是角点</strong></p><p>直观的说就是图像轮廓的连接点。不管视角怎么变换，这些点依然存在，是稳定的；它们与领域的点差别比较大。所以角点是一种优良的特征点。</p><img src="https://img-blog.csdn.net/20180114160548608?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxNDQ4NTQ4NQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img" style="zoom: 67%;" /><p>角点往往是两条边缘的交点，它是两条边缘方向变换的一种表示，因此其两个方向的梯度变换通常都比较大并且容易检测到。</p><p>Harris角点检测是通过数学计算在图像上发现角点特征的一种算法，而且其具有旋转不变性的特质。</p><p>OpenCV中的Shi-Tomasi角点检测就是基于Harris角点检测改进算法。</p><h5 id="2）基本原理"><a href="#2）基本原理" class="headerlink" title="2）基本原理"></a>2）基本原理</h5><p>人们通常通过在一个小的窗口区域内观察点的灰度值大小来识别角点，如果往任何方向移动窗口都会引起比较大的灰度变换那么往往这就是我们要找的角点。角点是一幅图像上最明显与重要的特征，对于一阶导数而言，角点在各个方向的变化都比较大，而边缘区域在只是某一方向有明显变化。一个直观的图示如下：</p><img src="https://img-blog.csdn.net/20131123223210125" alt="img" style="zoom: 80%;" /><h5 id="3）-数学原理"><a href="#3）-数学原理" class="headerlink" title="3） 数学原理"></a>3） 数学原理</h5><p>基本数学公式如下：<br>$$<br>E(u,v)&#x3D;\sum _{x,y} w(x,y)[I(x+u,y+v)-I(x,y)]^2<br>$$</p><p>其中$I(x, y)$表示像素灰度值强度，范围为0～255，$W(x, y)$表示移动窗口窗函数，可以是加权函数，也可以是高斯函数。</p><img src="https://images2015.cnblogs.com/blog/995848/201608/995848-20160817051607343-1302549651.png" alt="img" style="zoom:80%;" /><p>对  $f(x,y)$  进行二维泰勒展开：</p><img src="https://images2015.cnblogs.com/blog/995848/201608/995848-20160817052203750-468656927.png" alt="img" style="zoom: 55%;" /> <p> 略去二阶及更高阶项，上式可近似为：<br>$$<br>f(x+u,y+v) \approx f(x,y)+uf_x(x,y)+vf_y(x,y)<br>$$<br>于是对于$E(u,v)$，我们有以下的推导：</p><img src="https://images2015.cnblogs.com/blog/995848/201608/995848-20160817052854937-560342279.png" alt="img" style="zoom: 50%;" /><p>对于较小的位移，$E(u,v)$ 可以近似为：<br>$$<br>E(u,v) \simeq \begin{bmatrix} u &amp; v \end{bmatrix} M\begin{bmatrix} u \v  \end{bmatrix}<br>$$</p><p>其中M为：<br>$$<br>M&#x3D;\sum_{x,y}w(x,y) \begin{bmatrix} I_x^2 &amp; I_xI_y \I_xI_y  &amp;  I_y^2  \end{bmatrix}<br>$$</p><p>二次项本质上可以看成一个椭圆函数，矩阵M有特征值$\lambda_1  ,\lambda_2$，如下图，根据 $\lambda_1  ,\lambda_2$ 的值我们可以把其分为三类：</p><ol><li><p>λ1，λ2都很小且近似，E在所有方向接近于常数；</p></li><li><p>λ1&gt;&gt;λ2,或者λ2&gt;&gt;λ1, E将在某一方向上较大，其他方向较小；</p></li><li><p>λ1，λ2都很大且近似，E将在所有方向上都较大；</p></li></ol><p><img src="https://images2015.cnblogs.com/blog/995848/201608/995848-20160817071907484-972739621.png" alt="img"></p><p>如下图，上述三种情况，分别对应图像中的：</p><ol><li>变换不大，较为平缓的部分</li><li>边缘</li><li>角点</li></ol><img src="https://images2015.cnblogs.com/blog/995848/201608/995848-20160817072647953-1515493698.png" alt="img" style="zoom:50%;" /><p>最后我们通过计算角点响应值R来判断其属于哪个区间，也就是属于平缓区，边缘，还是角点：<br>$$<br>R&#x3D;detM - k (trace M)^2<br>$$</p><p>$$<br>其中，det M &#x3D; \lambda_1 \cdot \lambda_2　　　　trace M&#x3D;\lambda_1 + \lambda_2<br>$$</p><p>其中k一般为常数，一半取在0.04~0.06。</p><h5 id="4）算法详细步骤"><a href="#4）算法详细步骤" class="headerlink" title="4）算法详细步骤"></a>4）算法详细步骤</h5><ol><li>计算图像X方向与Y方向的梯度也就是一阶偏导数： $I_x ,  I_y$</li></ol><p>$$<br>I_x&#x3D;G_{\sigma}^x * I　　I_y&#x3D;G_{\sigma}^y * I<br>$$</p><ol start="2"><li>根据第一步的结果计算每个像素点的梯度平方： $I_x^2,I_y^2,I_xI_y$</li></ol><p>$$<br>I_x^2&#x3D;I_x \cdot I_x　　I_y^2&#x3D;I_y \cdot I_y　　I_xI_y&#x3D;I_x \cdot I_y<br>$$</p><ol start="3"><li>高斯模糊第二步三个值得到Sxx, Syy, Sxy</li></ol><p>$$<br>S_{xx}&#x3D;G_{\sigma’}*I_{x}^2　　S_{yy}&#x3D;G_{\sigma’}*I_{y}^2　　S_{xy}&#x3D;G_{\sigma’}*I_x I_y<br>$$</p><ol start="4"><li>定义在每个像素点的矩阵H，也就是前面的M矩阵</li></ol><p>$$<br>H(x,y)&#x3D;\begin{bmatrix} S_{xx}(x,y) &amp; S_{xy}(x,y) \ S_{xy}(x,y) &amp; S_{yy}(x,y) \end{bmatrix}<br>$$</p><ol start="5"><li>计算每个像素的角点响应值R</li></ol><p>$$<br>R&#x3D;Det(H)-k(Trace(H))^2<br>$$</p><ol start="6"><li>设置阈值找出可能点并进行非极大值抑制</li></ol><h3 id="三、实验内容和过程分析"><a href="#三、实验内容和过程分析" class="headerlink" title="三、实验内容和过程分析"></a>三、实验内容和过程分析</h3><h4 id="1）实现从摄像头读入视频并回放，以及根据按键进行不同的操作。"><a href="#1）实现从摄像头读入视频并回放，以及根据按键进行不同的操作。" class="headerlink" title="1）实现从摄像头读入视频并回放，以及根据按键进行不同的操作。"></a>1）实现从摄像头读入视频并回放，以及根据按键进行不同的操作。</h4><p>读入摄像头，回放视频。按一下空格键，则暂停回放，并将当前帧图像做一次 Harris Corner 检测 ，并将检测的结果叠加在原来图像上。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">VideoCapture <span class="title">capture</span><span class="params">(<span class="number">0</span>)</span></span>; <span class="comment">//打开一个默认的相机</span></span><br><span class="line"><span class="keyword">if</span> (!capture.<span class="built_in">isOpened</span>()) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//检查是否成功打开</span></span><br><span class="line"><span class="type">bool</span> show = <span class="literal">false</span>; <span class="comment">//是否有角点检测结果正在展示</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="comment">//从相机连续读取图像</span></span><br><span class="line">Mat frame;</span><br><span class="line">capture &gt;&gt; frame;</span><br><span class="line">Mat src = frame.<span class="built_in">clone</span>();</span><br><span class="line"><span class="keyword">if</span> (!src.data) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;video&quot;</span>, src);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> c = <span class="built_in">waitKey</span>(<span class="number">30</span>);</span><br><span class="line"><span class="comment">//空格键操作</span></span><br><span class="line"><span class="keyword">if</span> (c == <span class="number">32</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!show) &#123;  <span class="comment">//按下空格键后会对当前帧图像做角点检测</span></span><br><span class="line">string addr_pre=<span class="built_in">Harris</span>(src, <span class="number">0.05</span>, <span class="number">0.001</span>);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;result&quot;</span>, src);</span><br><span class="line"><span class="built_in">imwrite</span>(addr_pre + <span class="string">&quot;Result.png&quot;</span>, src);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;  <span class="comment">//如果当前已经有角点检测结果窗口在展示, 则按空格关闭展示窗口</span></span><br><span class="line"><span class="built_in">destroyWindow</span>(<span class="string">&quot;corner&quot;</span>);</span><br><span class="line"><span class="built_in">destroyWindow</span>(<span class="string">&quot;max&quot;</span>);</span><br><span class="line"><span class="built_in">destroyWindow</span>(<span class="string">&quot;min&quot;</span>);</span><br><span class="line"><span class="built_in">destroyWindow</span>(<span class="string">&quot;result&quot;</span>);</span><br><span class="line"><span class="built_in">destroyWindow</span>(<span class="string">&quot;R&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">show = !show;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;q&#x27;</span> || c == <span class="string">&#x27;Q&#x27;</span>|| c==<span class="number">27</span>)  <span class="comment">//按Q/q或者Esc键关闭结果展示窗口</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">destroyWindow</span>(<span class="string">&quot;corner&quot;</span>);</span><br><span class="line"><span class="built_in">destroyWindow</span>(<span class="string">&quot;max&quot;</span>);</span><br><span class="line"><span class="built_in">destroyWindow</span>(<span class="string">&quot;min&quot;</span>);</span><br><span class="line"><span class="built_in">destroyWindow</span>(<span class="string">&quot;result&quot;</span>);</span><br><span class="line"><span class="built_in">destroyWindow</span>(<span class="string">&quot;video&quot;</span>);</span><br><span class="line"><span class="built_in">destroyWindow</span>(<span class="string">&quot;R&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2）Harris-Corner-Detection"><a href="#2）Harris-Corner-Detection" class="headerlink" title="2）Harris Corner Detection"></a>2）Harris Corner Detection</h4><ol><li>计算图像X方向与Y方向的梯度也就是一阶偏导数： $I_x ,  I_y$</li></ol><p>$$<br>I_x&#x3D;G_{\sigma}^x * I　　I_y&#x3D;G_{\sigma}^y * I<br>$$</p><ol start="2"><li>根据第一步的结果计算每个像素点的梯度平方： $I_x^2,I_y^2,I_xI_y$</li></ol><p>$$<br>I_x^2&#x3D;I_x \cdot I_x　　I_y^2&#x3D;I_y \cdot I_y　　I_xI_y&#x3D;I_x \cdot I_y<br>$$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//转灰度图</span></span><br><span class="line">Mat gray;</span><br><span class="line"><span class="built_in">cvtColor</span>(I, gray, CV_BGR2GRAY);</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算图像X方向与Y方向的一阶偏导Ix、Iy以及Ix^2,Iy^y,IxIy</span></span><br><span class="line"><span class="function">Mat <span class="title">IxIx</span><span class="params">(gray.rows, gray.cols, CV_32FC1)</span></span>;</span><br><span class="line"><span class="function">Mat <span class="title">IyIy</span><span class="params">(gray.rows, gray.cols, CV_32FC1)</span></span>;</span><br><span class="line"><span class="function">Mat <span class="title">IxIy</span><span class="params">(gray.rows, gray.cols, CV_32FC1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化为0 (此部分在报告中省略)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//计算偏导数及Ix^2,Iy^y,IxIy</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">1</span>; y &lt;= I.rows - <span class="number">2</span>; y++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">1</span>; x &lt;= I.cols - <span class="number">2</span>; x++)&#123;</span><br><span class="line">        <span class="type">float</span> ix = (<span class="type">float</span>)gray.<span class="built_in">at</span>&lt;uchar&gt;(y + <span class="number">1</span>, x) - (<span class="type">float</span>)gray.<span class="built_in">at</span>&lt;uchar&gt;(y - <span class="number">1</span>, x);</span><br><span class="line">        <span class="type">float</span> iy = (<span class="type">float</span>)gray.<span class="built_in">at</span>&lt;uchar&gt;(y, x + <span class="number">1</span>) - (<span class="type">float</span>)gray.<span class="built_in">at</span>&lt;uchar&gt;(y, x - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        IxIx.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(y, x) = (<span class="type">float</span>)ix * (<span class="type">float</span>)ix;</span><br><span class="line">        IyIy.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(y, x) = (<span class="type">float</span>)iy * (<span class="type">float</span>)iy;</span><br><span class="line">        IxIy.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(y, x) = (<span class="type">float</span>)ix * (<span class="type">float</span>)iy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>高斯模糊第二步三个值得到Sxx, Syy, Sxy</li></ol><p>$$<br>S_{xx}&#x3D;G_{\sigma’}*I_{x}^2　　S_{yy}&#x3D;G_{\sigma’}*I_{y}^2　　S_{xy}&#x3D;G_{\sigma’}*I_x I_y<br>$$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算图像X方向与Y方向的一阶偏导Ix、Iy以及Ix^2,Iy^2,IxIy</span></span><br><span class="line"><span class="function">Mat <span class="title">Sxx</span><span class="params">(gray.rows, gray.cols, CV_32FC1)</span></span>;</span><br><span class="line"><span class="function">Mat <span class="title">Syy</span><span class="params">(gray.rows, gray.cols, CV_32FC1)</span></span>;</span><br><span class="line"><span class="function">Mat <span class="title">Sxy</span><span class="params">(gray.rows, gray.cols, CV_32FC1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//高斯滤波</span></span><br><span class="line"><span class="built_in">GaussianBlur</span>(IxIx, Sxx, <span class="built_in">Size</span>(<span class="number">5</span>, <span class="number">5</span>), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">GaussianBlur</span>(IyIy, Syy, <span class="built_in">Size</span>(<span class="number">5</span>, <span class="number">5</span>), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">GaussianBlur</span>(IxIy, Sxy, <span class="built_in">Size</span>(<span class="number">5</span>, <span class="number">5</span>), <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><ol start="4"><li>定义在每个像素点的矩阵H，也就是前面的M矩阵</li></ol><p>$$<br>H(x,y)&#x3D;\begin{bmatrix} S_{xx}(x,y) &amp; S_{xy}(x,y) \ S_{xy}(x,y) &amp; S_{yy}(x,y) \end{bmatrix}<br>$$</p><ol start="5"><li>计算每个像素的角点响应值R</li></ol><p>$$<br>R&#x3D;Det(H)-k(Trace(H))^2<br>$$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//R值和最大最小特征值矩阵</span></span><br><span class="line"><span class="function">Mat <span class="title">R</span><span class="params">(gray.rows, gray.cols, CV_32FC1)</span></span>;</span><br><span class="line"><span class="function">Mat <span class="title">Max</span><span class="params">(gray.rows, gray.cols, CV_32FC1)</span></span>;</span><br><span class="line"><span class="function">Mat <span class="title">Min</span><span class="params">(gray.rows, gray.cols, CV_32FC1)</span></span>;</span><br><span class="line"><span class="comment">//最大响应值Rmax</span></span><br><span class="line"><span class="type">float</span> maxResponse = <span class="number">0.0f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化为0 （此部分在此省略）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//计算最大最小特征值以及harris响应值R</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt;I.rows; y++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt;I.cols; x++) &#123;</span><br><span class="line"><span class="type">float</span> aa = <span class="number">0</span>;</span><br><span class="line"><span class="type">float</span> bb = <span class="number">0</span>;</span><br><span class="line"><span class="type">float</span> cc = <span class="number">0</span>;</span><br><span class="line">aa = Sxx.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(y, x);</span><br><span class="line">bb = Syy.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(y, x);</span><br><span class="line">cc = Sxy.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(y, x);</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算当前像素的harris响应值</span></span><br><span class="line"><span class="type">float</span> t = (aa * bb - cc * cc) - k * (aa + bb) * (aa + bb);</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算最大最小特征值</span></span><br><span class="line"><span class="type">float</span> po1 = <span class="built_in">pow</span>(<span class="number">1.0</span> * aa - bb, <span class="number">2</span>);</span><br><span class="line"><span class="type">float</span> po2 = <span class="number">4.0</span> * cc * cc;</span><br><span class="line"><span class="type">float</span> sq = <span class="built_in">sqrt</span>((<span class="type">double</span>)(po2 + po1));</span><br><span class="line"><span class="type">float</span> max = <span class="number">0.5</span> * (aa + bb + sq);</span><br><span class="line"><span class="type">float</span> min = <span class="number">0.5</span> * (aa + bb - sq);</span><br><span class="line"></span><br><span class="line">R.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(y, x) = t;</span><br><span class="line">Max.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(y, x) = max;</span><br><span class="line">Min.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(y, x) = min;</span><br><span class="line"></span><br><span class="line"><span class="comment">//记录最大响应值</span></span><br><span class="line"><span class="keyword">if</span> (t &gt; maxResponse)</span><br><span class="line">maxResponse = t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>设置阈值找出可能点并进行非极大值抑制</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Mat localMax; </span><br><span class="line"><span class="comment">//进行局部非最大值抑制</span></span><br><span class="line"><span class="built_in">localMaxFilter</span>(R, localMax, max_size);</span><br><span class="line"></span><br><span class="line"><span class="comment">//剔除部分局部极大值</span></span><br><span class="line">Mat Corner=localMax;</span><br><span class="line"><span class="built_in">threshold</span>(localMax, Corner, thres_hold * maxResponse, <span class="number">255</span>, THRESH_BINARY);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在原始图像上绘制角点检测结果</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt; Corner.rows - <span class="number">1</span>; y++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; Corner.cols - <span class="number">1</span>; x++)</span><br><span class="line"><span class="keyword">if</span> (Corner.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(y, x))</span><br><span class="line"><span class="built_in">circle</span>(I, <span class="built_in">Point2i</span>(x, y), <span class="number">2</span>, <span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">242</span>, <span class="number">0</span>));</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非局部极大值抑制</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">localMaxFilter</span><span class="params">(Mat&amp; in, Mat&amp; out, <span class="type">int</span> size=<span class="number">3</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Mat dilated;</span><br><span class="line">    <span class="built_in">dilate</span>(in, dilated, <span class="built_in">Mat</span>()); <span class="comment">//对输入进行膨胀操作</span></span><br><span class="line">    <span class="keyword">if</span> (out.<span class="built_in">empty</span>())</span><br><span class="line">        out.<span class="built_in">create</span>(in.rows, in.cols, in.<span class="built_in">type</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt; in.rows; y++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; in.cols; x++) &#123;</span><br><span class="line">            <span class="comment">//如果像素点的值和膨胀操作前相同，证明该点为局部极大值点</span></span><br><span class="line">            <span class="keyword">if</span> (in.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(y, x) == dilated.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(y, x))</span><br><span class="line">                out.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(y, x) = in.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(y, x);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                out.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(y, x) = <span class="number">0.0f</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四、实验结果展示"><a href="#四、实验结果展示" class="headerlink" title="四、实验结果展示"></a>四、实验结果展示</h3><h5 id="1）使用本地图像检测Harris-Corner-Detection效果"><a href="#1）使用本地图像检测Harris-Corner-Detection效果" class="headerlink" title="1）使用本地图像检测Harris Corner Detection效果"></a>1）使用本地图像检测Harris Corner Detection效果</h5><ol><li>原图</li></ol><p><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202306021547.jpg" alt="图片alt" title="图片title"></p><ol start="2"><li>最大特征值图</li></ol><p><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202306021548.jpg" alt="图片alt" title="图片title"></p><ol start="3"><li><p>最小特征值图<br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202306021549.jpg" alt="图片alt" title="图片title"></p></li><li><p>响应值R图<br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202306021550.jpg" alt="图片alt" title="图片title"></p></li><li><p>角点检测结果<br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202306021551.jpg" alt="图片alt" title="图片title"></p></li><li><p>角点检测结果与原图叠加<br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202306021552.jpg" alt="图片alt" title="图片title"></p></li><li><p>原图<br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202306021553.jpg" alt="图片alt" title="图片title"></p></li><li><p>最大特征值图<br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202306021554.jpg" alt="图片alt" title="图片title"></p></li><li><p>最小特征值图<br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202306021555.jpg" alt="图片alt" title="图片title"></p></li><li><p>响应值R图<br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202306021556.jpg" alt="图片alt" title="图片title"></p></li><li><p>角点检测结果<br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202306021557.jpg" alt="图片alt" title="图片title"></p></li><li><p>角点检测结果与原图叠加<br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202306021558.jpg" alt="图片alt" title="图片title"></p></li></ol><h3 id="五、实验思考和感想"><a href="#五、实验思考和感想" class="headerlink" title="五、实验思考和感想"></a>五、实验思考和感想</h3><p>​通过本次实验，我更加深入地学习和体会了Harris角点检测的算法，在实践的过程中，我发现了很多在学习过程中没有注意到的细节，都需要在实践进行调整。</p><p>​在实验初期，调整角点检测的R值阈值给我造成了一定的困扰，对于不同的图像，似乎需要不同的阈值，才能得到较为合理较为优秀的结果，后期，我发现这个阈值由于是一个绝对值，而图像的性质不同会使得R值的范围变化非常大，因此，我将这个阈值设置成为一个函数，在计算图像中每个像素点的R值时，记录下最大的R值，在后续的处理中，以关于这个最大值的一个比例函数，例如K*MaxValue，作为选择角点的阈值，这样处理之后，算法对于不同图像的适应度增强了很多，但由于只获取了最大R值的信息，因此还是不能完全做到自适应，在某些情况下需要对阈值函数进行微调。</p><p>​在实验中，我还发现，计算R值和最大最小特征值时，由于结果数据可能溢出八位，因此不能再采用位深度为8的图像格式变量，因此，我将图像深度改为了32位，float类型，才得以储存原始数据。</p><p>​由于实验需要要求保存进行角点检测的中间结果，且我在本次试验中实现了可以进行通过空格键在一次程序运行期间进行多次的角点检测（具体操作方式见ReadMe），因此我调用了函数，在每次进行角点检测时，得到系统时间，转化成字符串，作为图像输出文件名前缀，后缀则代表着该图像的属性，如Max代表该图像是最大特征值图，Corner代表该图像是得到的角点检测结果图。</p>]]></content>
      
      
      <categories>
          
          <category> Computer Vision </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Homework </tag>
            
            <tag> Computer Vision </tag>
            
            <tag> Harris Corner </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于GPU的渲染Project - 布料真实感实时渲染</title>
      <link href="/2023/05/31/GPUrendering-Porject/"/>
      <url>/2023/05/31/GPUrendering-Porject/</url>
      
        <content type="html"><![CDATA[<p>课程名称：基于GPU的渲染<br>项目主题名称：布料真实感实时渲染<br>日期：2022 年 1 月 10 日 <br><br>PS: 当时还比较年轻，有些问题略弱智。</p><span id="more"></span><div class="tag link"><a class="link-card" title="code" href="https://github.com/YaelCassini/Cloth_Real-Time-Rendering"><div class="left"><img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/256/safari.png"/></div><div class="right"><p class="text">code</p><p class="url">https://github.com/YaelCassini/Cloth_Real-Time-Rendering</p></div></a></div><div class="tag link"><a class="link-card" title="video" href="https://www.bilibili.com/video/BV175411o7t1/"><div class="left"><img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/256/safari.png"/></div><div class="right"><p class="text">video</p><p class="url">https://www.bilibili.com/video/BV175411o7t1/</p></div></a></div><div class="tag link"><a class="link-card" title="report" href="https://yaelcassini.github.io/2023/05/31/GPUrendering-Porject/"><div class="left"><img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/256/safari.png"/></div><div class="right"><p class="text">report</p><p class="url">https://yaelcassini.github.io/2023/05/31/GPUrendering-Porject/</p></div></a></div><h2 id="〇-Part-Zero-基本概述及project组织架构"><a href="#〇-Part-Zero-基本概述及project组织架构" class="headerlink" title="〇.  Part Zero    基本概述及project组织架构"></a>〇.  Part Zero    基本概述及project组织架构</h2><h3 id="基本概述："><a href="#基本概述：" class="headerlink" title="基本概述："></a>基本概述：</h3><p>​本次大程为了实现<strong>布料的实时渲染</strong>，我的主要思路是使用<strong>PBR</strong>的渲染方式，通过使用Albedo、Normal Map、Roughness Map等<strong>贴图</strong>，完成布料的基本着色。</p><p>​阴影部分采用<strong>ShadowMap算法</strong>实现，使用<strong>PCF算法</strong>完成对阴影锯齿状走样的消除和处理，得到软阴影。</p><p>​实验中用到的<strong>贴图</strong>均为本人使用Substance Painter绘制后<strong>烘焙</strong>导出。另外为了使工程文件格式统一，我还对<strong>模型</strong>进行了一些<strong>预处理</strong>。</p><p>​在后文我将对本次大程中的几个重要部分的原理分别阐述。</p><h3 id="Project组织架构："><a href="#Project组织架构：" class="headerlink" title="Project组织架构："></a>Project组织架构：</h3><ul><li><p>实验环境及用到的库：</p><ul><li>Visual Studio 2019</li><li><a href="https://www.glfw.org/">GLFW</a></li><li><a href="https://glad.dav1d.de/">GLAD</a></li><li><a href="https://glm.g-truc.net/0.9.9/index.html">GLM</a></li><li><a href="http://www.assimp.org/">Assimp</a></li><li><a href="https://github.com/nothings/stb">stb_image</a></li><li><a href="https://www.freetype.org/">FreeType</a></li></ul></li><li><p>请使用 <strong>Release x86</strong> 生成解决方案和调试。</p></li><li><p>需要的头文件、lib文件已经打包在项目目录下，并在项目属性配置中用相对路径引用。</p></li></ul><ol start="2"><li>需要的dll文件放在项目目录下。</li></ol><ul><li>main.cpp为主要源文件，主函数入口在其中，核心的渲染过程也在该源文件中。</li><li>Fonts文件夹下是几个字体，字体用于显示Text（比如FPS显示）。</li><li>include文件夹是需要的头文件，主要是Glad、GLFW等库的头文件</li><li>lib文件夹是用到的库的lib文件</li><li>Headers文件夹下是工程中一些模块的头文件，比如Camera模块、Shader模块等等。</li><li>Models文件夹下是用到模型文件，编号表示模型内容、所属人物和姿势。比如”body1_1“表示第一个人物的第一个姿势，”cloth1_1“表示第一件衣服的第一个姿势，cloth1-cloth3属于第一个人物，cloth4-cloth6属于第二个人物。</li><li>Shaders文件夹下是需要的shader源文件，其中PBRShader是本次项目主要使用的shader，RenderTexture是将ShadowMap展示在窗口使用的shader。</li><li>Textures文件夹下是使用的贴图，background为前缀的贴图是背景幕布的贴图。set1文件夹下存放女孩模型使用的贴图，set2文件夹下存放男孩模型使用的贴图，其中，两个body的渲染使用的是一样的贴图。每套贴图共有5张，编号从0到4分别是Albedo、Normal Map、Metallic Map、Roughness Map、AO Map。其中由于没有使用到Metallic和AO贴图，因此有些地方直接将这两张贴图省略了。</li></ul><h2 id="Ⅰ-Part-One-PBR基本原理"><a href="#Ⅰ-Part-One-PBR基本原理" class="headerlink" title="Ⅰ.  Part One    PBR基本原理"></a>Ⅰ.  Part One    PBR基本原理</h2><p>​PBR（Physically Based Rendering），指的是基于物理的渲染，更符合物理学规律，看上去更真实。并且由于其与真实的物理性质非常接近，可以直接用物理参数为依据来编写表面材质。由于基于物理的渲染旨在以一种物理上合理的方式模拟光，因此与我们的原始照明算法（如Phong和Blinn-Phong）相比，它通常看起来更真实，并且非常接近实际物理，我们可以根据物理参数编写表面材料，而不必求助于廉价的技巧和调整来使灯光看起来正确。基于物理参数编写材质的一个更大的优点是，无论照明条件如何，这些材质都会看起来正确。<br>​满足基于物理渲染的三个条件：</p><ul><li>基于微平面（Microfacet）的表面模型</li><li>能量守恒</li><li>应用基于物理的BRDF</li></ul><p></p><h4 id="微平面模型"><a href="#微平面模型" class="headerlink" title="微平面模型"></a>微平面模型</h4><ul><li>达到微观尺度之后，任何平面都可以用被称为微平面的细小镜面来描绘。</li><li>微平面的取向排列的不一致程度，与平面粗糙程度有关。平面越粗糙，微平面排列越混乱。</li><li>对于粗糙平面，入射光线更趋向于向完全不同的方向发散，光滑平面上，入射光线大体上趋向于向同一个方向发射。</li><li>PBR中一般基于光线向量l和视线向量v的中间向量h与微平面平均取向方向的一致性计算镜面反射。</li><li>中间向量计算公式：$h &#x3D; \frac{l+v}{||l+v||}$</li><li>微平面无法逐像素区分，因此应该假设一个粗糙度参数，并使用统计学方法估算微平面的取向方向。</li><li>粗糙度系数取值为0-1之间，可以估算微平面的取向情况。</li><li>粗糙度越高，镜面反射轮廓越大，反之轮廓越小但边缘更锐利。</li></ul><h4 id="能量守恒"><a href="#能量守恒" class="headerlink" title="能量守恒"></a>能量守恒</h4><ul><li>微平面近似法中的能量守恒：出射光线的能量永远不能超过入射光线的能量（发光面除外）。</li><li>一束光线碰撞到一个表面时，会分离成一个折射部分和一个反射部分。反射部分不进入平面直接反射，成为镜面光照。折射部分会进入表面并被吸收，成为漫反射光照。</li><li>金属表面上所有折射光都会被直接吸收而不会散开，因此金属表面不会显示出漫反射颜色。</li><li>折射光与反射光二者是互斥的关系。能量总和永远不会超过入射光线的能量。</li></ul><h4 id="反射率方程"><a href="#反射率方程" class="headerlink" title="反射率方程"></a>反射率方程</h4><ul><li>反射率方程是PBR中一种渲染方程的特化版本</li><li>反射率方程：$L_0(p,\omega_0) &#x3D; \int _\Omega f_r(p,\omega_i,\omega_0)L_i(p,\omega_i)n·\omega_i d \omega_i$</li><li>$L$是辐射率，用来量化单一方向上发射来的光线的大小和强度</li><li>辐射通量$\Phi$：一个光源输出的能量，以瓦特为单位，可以视为这个光源中包含的所有波长的一个函数。</li><li>立体角：三位立体空间中的角度，可以描述为投射到单位球体上的截面大小。</li><li>辐射强度：单位球面上，一个光源向每个单位立体角所投放的辐射通量。计算公式： $I&#x3D;\frac{d\Phi}{d\omega}$。</li><li>辐射率L：一个拥有辐射强度的光源在单位面积A，单位立体角上辐射出的总能量。也就是：$L&#x3D;\frac{d^2\Phi}{dAd\omega cos\theta}$ 。如果把立体角和面积看作无穷小，就可以用辐射率来表示单束光线穿过空间中一个点的通量。</li><li>反射率方程$L_0(p,\omega_0) &#x3D; \int _\Omega f_r(p,\omega_i,\omega_0)L_i(p,\omega_i)n·\omega_i d \omega_i$中：<ul><li>$L_i(p,\omega_i)$表示通过无限小的立体角（可以近似看作一个入射方向向量）投射到点p上的光线总和。</li><li>$n·\omega_i$也就是余弦值$cos\theta$。</li><li>$\omega_0$表示观察方向，也就是光线的出射方向。</li><li>$L_0(p,\omega_0)$表示了从$\omega_0$方向上观察时，光线投射到点p上之后反射出来的辐照度</li><li>$\Omega$表示以点p为球心，以平面法向n为轴所环绕的半球体。为</li><li>$d \omega_i$积分元，在计算中按照一定的步长对反射率方程离散求解。</li><li>$f_r(p,\omega_i,\omega_0)$为双面反射分布函数，也就是BRDF，它的作用时基于表面材质属性来对入射辐射度进行缩放和加权</li></ul></li></ul><h4 id="BRDF"><a href="#BRDF" class="headerlink" title="BRDF"></a>BRDF</h4><ul><li><p>输入参数：入射光方向，出射光方向$\omega_0$，平面法向$n$，表示微平面粗糙程度的参数$\alpha$</p></li><li><p>当平面为理想镜面时，BRDF只对符合反射定律（即入射光、出射光、平面法向在同一平面，入射角等于出射角）的出射方向返回值为1，其他方向返回值都为0。</p></li><li><p>Blinn-Phong模型也可以认为是一个BRDF，但他不能保证能量守恒，因此不是基于物理的渲染。</p></li><li><p><strong>Cook-Torrance BRDF</strong>（包括漫反射和镜面反射两部分）：</p><p>$f_r &#x3D; k_d f_{lambert} + k_s f_{cook-torrance}$</p></li><li><p>$k_s$表示入射光线中被折射部分的比例， $k_d$表示入射光线中被反射部分的比例。</p></li><li><p>漫反射部分：$f_{lambert} &#x3D; \frac{c}{\pi}$ ，其中$c$表示表面的颜色。</p></li><li><p>镜面反射：$f_{cook-torrance} &#x3D; \frac{DFG}{4(\omega_0·n)(\omega_i·n)}$</p><ul><li>$D$：正态分布函数估算在当前的表面粗糙度下，取向方向与中间向量一致的微平面的数<br>量。</li><li>$G$：几何函数<br>描述了微平面自成阴影的属性，当平面较粗糙时，微平面可能会互相遮挡从而减少表面所反射的光线。</li><li>$F$：菲涅尔方程<br>描述不同表面角下表面所反射的光线所占比例</li></ul></li></ul><h4 id="正态分布函数"><a href="#正态分布函数" class="headerlink" title="正态分布函数"></a>正态分布函数</h4><ul><li>也称为镜面分布，从统计学上近似地表示了与某向量（一般是中间向量h）取向<br>一致的微平面的比例。</li><li>计算公式：$NDF_{GGXTR}(n.h,\alpha) &#x3D; \frac{\alpha^2}{\pi((n·h)^2 (\alpha_2-1) + 1)^2}$</li><li>其中：$h$表示中间向量， $\alpha$表示表面粗糙度</li></ul><h4 id="几何函数"><a href="#几何函数" class="headerlink" title="几何函数"></a>几何函数</h4><ul><li><p>从统计学上近似求得微平面之间相互遮挡的比例，这种遮挡会损耗光线能量。</p></li><li><p>计算公式：$G_{SchlickGGX}(n,v,k) &#x3D; \frac{n·v}{(n·v)(1-k)+k}$</p></li><li><p>其中，$k$是粗糙度$\alpha$的重映射</p><ul><li>针对直接光照：$k_{direct} &#x3D; \frac{(\alpha+1)^2}{8}$</li><li>针对<strong>IBL</strong>（<strong>image based lighting</strong>，一种间接光照技术）光照：$k_{IBL} &#x3D; \frac{\alpha^2}{2}$</li></ul></li><li><p>微平面相互遮挡包括：</p><ul><li>观察方向上：几何遮蔽</li><li>光线方向上：几何阴影</li></ul></li><li><p>同时考虑两种遮挡的几何函数计算公式：</p><p>$G(n,v,l,k) &#x3D; G_{sub}(n,v,k)G_{sub}(n,l,k)$</p></li></ul><h4 id="菲涅尔方程"><a href="#菲涅尔方程" class="headerlink" title="菲涅尔方程"></a>菲涅尔方程</h4><ul><li><p>描述被反射的光线对比光线被折射部分所占的比例，该值会随着观察角度的不同而不同。</p></li><li><p>菲涅尔方程根据观察角度得出被反射的光线所占的百分比。</p></li><li><p>垂直观察时，任何物体和材质表面都有一个基础反射率，而如果从和法线夹角近似90度的方向观察，理论上所有的平面都能完全反射光线，因此反光会变得明显很多。</p></li><li><p>菲涅尔方程的近似解公式：$F_{Schlick}(h,v,F_0) &#x3D; F_0 + (1-F_0)(1-(h·v))^5$</p><ul><li>该近似只对电解质或者说非金属表面有定义，因为使用IOR计算基础反射率对导体表面并不能计算出正确结果。</li><li>对金属材质需要预先计算平面对法向入射的反应，然后基于相应观察叫的近似对这个值进行插值</li><li>$F_0$：平面基础反射率，利用折射指数IOR算出，用RGB三原色来表示，因为对于道题该基础反射率一般是带有颜色的。</li></ul></li><li><p>因为金属表面会吸收所有折射光线而没有漫反射，因此可以直接使用表面纹理来作为他们的基础反射率。</p></li></ul><h4 id="Cook-Torrance反射率方程"><a href="#Cook-Torrance反射率方程" class="headerlink" title="Cook-Torrance反射率方程"></a>Cook-Torrance反射率方程</h4><ul><li>计算公式：$L_0(p,\omega_0) &#x3D; \int _\Omega (k_d\frac{c}{\pi} + k_s \frac{DFG}{4(\omega_0·n)(\omega_i·n)})L_i(p,\omega_i)n·\omega_i d \omega_i$</li></ul><h4 id="PBR渲染管线中的纹理列表"><a href="#PBR渲染管线中的纹理列表" class="headerlink" title="PBR渲染管线中的纹理列表"></a>PBR渲染管线中的纹理列表</h4><ul><li>反照率（Albedo）：每一个金属的纹理像素，指定表面的颜色或者基础反射率</li><li>法线（Normal）：使得我们可以逐片段值得独特的法线，制造表面的起伏感。</li><li>金属度（Metallic）：逐个像素指定是否是金属质地。</li><li>粗糙度（Roughness）：以纹理像素为单位指定表面的粗糙度，粗糙度数值会影响微平面统计学上的取向度。</li><li>环境光遮蔽（AO）：为表面和周围潜在的几何图形指定了一个额外的阴影因子。</li></ul><h4 id="PBR渲染管线中的纹理列表（Metal-x2F-Roughness-Workflow）"><a href="#PBR渲染管线中的纹理列表（Metal-x2F-Roughness-Workflow）" class="headerlink" title="PBR渲染管线中的纹理列表（Metal&#x2F;Roughness Workflow）"></a>PBR渲染管线中的纹理列表（Metal&#x2F;Roughness Workflow）</h4><p>​在本流程中，金属的反射率值和电解质的反射颜色一起被放置在Base color贴图<br>中。金属贴图就像一个Mask一样来区分Base color中的金属和电介质数据。</p><p>​常见介电材料的F0被硬编码为0.04。</p><ul><li><p>反照率（Albedo）</p><p>每一个金属的纹理像素，指定表面的颜色或者基础反射率。在色调上比较平坦，对比度低于传统的漫反射贴图。亮度范围最低不应该低于30-50sRGB，最高不应该高于240sRGB。</p></li><li><p>法线（Normal）</p><p>使得我们可以逐片段计算得到独特的法线，制造表面的起伏感。</p></li><li><p>金属度（Metallic）</p><p>金属贴图用于定义材料的哪些区域表示原始的金属，它类似于一个遮罩。0.0表示非金属，1.0表示金属。</p><p>原始金属的灰度范围在金属贴图中定义为235-255sRGB，落在此范围内的金属需要在Base color中有70%-100%的反射率范围。金属上的涂层或者污垢等远低于金属70%-100%的反射率所需要的值，因此在金属贴图低于235sRGB的范围内，可以在介电和金属反射率值之间创建适当的混合。</p></li><li><p>粗糙度（Roughness）</p><p>Roughness贴图以纹理像素为单位指定表面的粗糙度，描述了表面的不规则性，粗糙度数值会影响微平面统计学上的取向度。反射光方向会根据表面粗糙度变化，但强度保持不变。粗糙度高的表面具有范围更大看起来更暗的高光，而较光滑的表面则有范围较小而看起来更亮的高光。</p><p>黑色（0.0）表示光滑的表面，白色（1.0）表示粗糙的表面。</p></li><li><p>环境光遮蔽（AO）：为表面和周围潜在的几何图形指定了一个额外的阴影因子。</p></li></ul><h2 id="Ⅱ-Part-Two-Bump-Mapping基本原理"><a href="#Ⅱ-Part-Two-Bump-Mapping基本原理" class="headerlink" title="Ⅱ.  Part Two    Bump Mapping基本原理"></a>Ⅱ.  Part Two    Bump Mapping基本原理</h2><p>​Bump Mapping（也叫Normal Mapping）也就是法线映射，简单的讲就是通过读取一张存储着法线信息的纹理来计算光照（而不直接简单地通过顶点法线的插值），这样可以明显增强图像的真实感。</p><h4 id="法线贴图（Normal-Map）"><a href="#法线贴图（Normal-Map）" class="headerlink" title="法线贴图（Normal Map）"></a>法线贴图（Normal Map）</h4><p>　　法线贴图是<strong>存储法线</strong>的一张贴图，法线的 <strong>xyz</strong> 的值经过<strong>归一化</strong>之后再被<strong>映射</strong>成为对应的 <strong>RGB</strong> 值。归一化的法线值范围为[-1,1]，而RGB的每一个分量为无符号的8位组成，范围为[0,255]。即法线的分量需要从由[-1，1]映射成[0，255]。法线贴图一般呈蓝色，因为大多数朝向 (0, 0, 1) 的法线被映射成为了 (0, 0, 255)。</p><h4 id="切空间及其变换矩阵"><a href="#切空间及其变换矩阵" class="headerlink" title="切空间及其变换矩阵"></a>切空间及其变换矩阵</h4><p>　　我们需要注意的是，法线贴图中储存的法线是在<strong>切空间</strong>中的法线值。切空间是在某一点由顶点法向和切向量组成的线性空间。在模型每个顶点中，都存在这样的一个切空间坐标系，以模型顶点为中心，以TBN三个方向分别为为3个轴（Tangent，Binormal，Normal）。其中，N是顶点的法线方向，T、B两个向量是顶点切平面的2个向量，一般T的方向是纹理坐标u的方向，B的方向（副切线方向）通过TN叉乘计算得到。</p><p>​从切空间到模型空间的变换矩阵，由T、B、N三个向量组成，也叫TBN矩阵。Tangent，Binormal，Normal三个向量中，我们在模型顶点中已知Tangent和Normal的值，则Binormal可以通过前2个向量的叉乘来取得。特别的，我们需要首先将Tangent进行<a href="https://www.cnblogs.com/jqm304775992/p/4914126.html">Gram-Schmidt向量正交化</a>，使之与法线垂直。</p><h4 id="Normal-Mapping主要流程"><a href="#Normal-Mapping主要流程" class="headerlink" title="Normal Mapping主要流程"></a>Normal Mapping主要流程</h4><p>​因此，我们进行Normal Mapping的主要流程就是：</p><ul><li>根据顶点的Normal和Tangent计算TBN矩阵</li><li>根据顶点UV从Normal Map采样，并将其映射回到[-1,1]，从而得到切空间下的法线信息。</li><li>使用TBN矩阵将法线信息变换到模型空间</li><li>进行后续的光照计算（或许需要对法线做进一步变换转换到世界空间）</li></ul><p>　</p><h2 id="Ⅲ-Part-Three-Shadow-Map基本原理"><a href="#Ⅲ-Part-Three-Shadow-Map基本原理" class="headerlink" title="Ⅲ.  Part Three    Shadow Map基本原理"></a>Ⅲ.  Part Three    Shadow Map基本原理</h2><p>​（本部分由于是课堂学习内容，因此在此不再赘述，只描述基本原理。）</p><p>​阴影图(Shadow Map)算法是渲染时用于计算阴影的算法，也是现在使用最为广泛的阴影计算方法。</p><p>​Shadow Map算法计算阴影的基本原理是：从光源可以看到场景中所有的被光照亮的表面。在光源方向不可见的表面都处于阴影区域。</p><p><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305312239.jpg" alt="图片alt" title="图片title"></p><ul><li><p>为了判断Fragment是否对于光源是可见的，需要分三步：</p><ul><li><p>以光源的位置作为视点，对场景进行一次渲染，这次绘制不会将着色显示在屏幕上，而只取深度信息，得到一张深度图Shadow Map。这张纹理上的每一个像素都记录了第一个可见表面的深度值（也就是与光源的距离）。</p></li><li><p>从真实的视点对场景进行渲染，在渲染的过程中，逐片元进行矩阵变换，求出当前片元在光源为视点的空间下的深度值和UV值（也就是xy坐标值）。</p></li><li><p>使用xy坐标值从第一步生成的Shadow Map中采样，并与当前片元深度值比较。如果当前深度值大于采样得到的深度值，则证明当前片元应该是阴影，反之则证明当前片元可以被光源照亮。</p></li></ul></li><li><p>其中，第一步中以光源为视点进行渲染时，如果使用的是平行光则应该采用正交投影，如果使用的是点光源则应该采用透视投影。</p></li><li><p>使用上述方法得到的阴影会有明显的锯齿状，因此在项目中我还使用了老师上课介绍的PCF算法，以期望得到软阴影，柔化阴影边缘，消除锯齿状走样。</p><ul><li>PCF方法的主要原理是，在从Shadow Map采样时，不仅采样当前UV，还要采样周围的像素（比如一个以当前UV为中心的3*3的窗口），将当前片元的深度值分别与这个窗口内的每一个深度值比较，如果大于当前片元深度值就取值为1，否则取值为0。之后再对这样得到的一个由0和1组成的窗口进行卷积操作（一般是求平均），从而得到当前片元的阴影系数，这样就实现了软阴影。</li></ul></li></ul><h2 id="Ⅳ-Part-Four-模型处理及贴图烘焙"><a href="#Ⅳ-Part-Four-模型处理及贴图烘焙" class="headerlink" title="Ⅳ.  Part Four    模型处理及贴图烘焙"></a>Ⅳ.  Part Four    模型处理及贴图烘焙</h2><h4 id="对模型的预处理："><a href="#对模型的预处理：" class="headerlink" title="对模型的预处理："></a>对模型的预处理：</h4><ul><li>使用Maya对模型的大小和旋转方向做了预先处理，这部分在代码里实际上也能通过ModelMatrix来实现，但是由于加入了其他的模型（比如点光源、背景幕布），为了统一，便使用了在Maya中预先处理好的方法。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305312240.jpg" alt="图片alt" title="图片title"></p><p><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305312241.jpg" alt="图片alt" title="图片title"></p><ul><li>两个模型的人体部分是硬边，也就是每个顶点有多个法线，这样会使得最终的渲染效果皮肤表面有棱角，不够平滑，因此我对两个模型的身体部分在Maya中进行了软化边操作。（下图展示软化边操作前后的模型效果及顶点法线）</li></ul><p><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305312242.jpg" alt="图片alt" title="图片title"><br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305312243.jpg" alt="图片alt" title="图片title"><br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305312244.jpg" alt="图片alt" title="图片title"><br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305312245.jpg" alt="图片alt" title="图片title"></p><p>  如上图，没有做软化边的模型每个顶点有多个法线，软化边之后的模型每个顶点只有一个法线</p><ul><li><p>自行建模得到了一个幕布，并同样为其制作贴图，对其进行PBR流程渲染。（见上图）</p></li><li><p>有些模型的UV没有展开（比如身体部分），对这些模型进行了UV自动展开（因为皮肤部分对UV排布方式的要求不高）</p></li><li><p>其他模型（衣物等）虽然有展开好的UV，但是该UV并没有在0-1的范围内，因此使用Maya将该展开后的UV放在0-1之内的范围内。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305312246.jpg" alt="图片alt" title="图片title"><br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305312247.jpg" alt="图片alt" title="图片title"></p><h4 id="贴图的烘焙制作："><a href="#贴图的烘焙制作：" class="headerlink" title="贴图的烘焙制作："></a>贴图的烘焙制作：</h4><ul><li>自行使用Substance Painter完成模型贴图的制作，PBR流程中导出的贴图有Albedo、Normal Map、Metallic Map、Roughness Map、Height Map五张。其中每个模型都使用的有Albedo、Normal Map、Roughness Map。由于本次渲染实验中没有模型有金属度，因此所有的Metallic Map都是一张黑色贴图，可以直接不添加该帖图，Shader会自动使用默认值0。另外，本次实验中也暂时没有烘焙和使用AO贴图。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305312248.jpg" alt="图片alt" title="图片title"><br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305312249.jpg" alt="图片alt" title="图片title"><br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305312250.jpg" alt="图片alt" title="图片title"></p><h2 id="Ⅴ-Part-Five-效果展示"><a href="#Ⅴ-Part-Five-效果展示" class="headerlink" title="Ⅴ.  Part Five    效果展示"></a>Ⅴ.  Part Five    效果展示</h2><p>​工程运行效果可以查看”录屏展示“文件，本处展示一些运行截图。（截图效果可能因为截图软件分辨率不够等因素，效果并没有直接看的好。）由于设备显卡比较陈旧，渲染FPS似乎较低。</p><p><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305312251.jpg" alt="图片alt" title="图片title"><br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305312252.jpg" alt="图片alt" title="图片title"><br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305312253.jpg" alt="图片alt" title="图片title"><br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305312254.jpg" alt="图片alt" title="图片title"></p><h2 id="Ⅵ-Part-Six-参考资料"><a href="#Ⅵ-Part-Six-参考资料" class="headerlink" title="Ⅵ.  Part Six    参考资料"></a>Ⅵ.  Part Six    参考资料</h2><ol><li><a href="https://learnopengl-cn.github.io/07%20PBR/01%20Theory/">LeanOpenGL CN官网的PBR理论教程</a></li><li><a href="https://academy.substance3d.com/courses/the-pbr-guide-part-1">Adobe官方提供的PBR Guide</a></li><li><a href="https://blog.csdn.net/ronintao/article/details/51649664">Shadow Map算法原理</a></li><li><a href="https://zhuanlan.zhihu.com/p/384446688">Shadow Map算法及其延伸</a></li><li><a href="https://zhuanlan.zhihu.com/p/382202359">三种Shadowmap改进算法的原理</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Computer Graphics </category>
          
          <category> Rendering </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Homework </tag>
            
            <tag> Rendering </tag>
            
            <tag> GPU </tag>
            
            <tag> Real-Time Rendering </tag>
            
            <tag> PBR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>场景设计课程建模作业</title>
      <link href="/2023/05/31/Scene-Design/"/>
      <url>/2023/05/31/Scene-Design/</url>
      
        <content type="html"><![CDATA[<p>课程名称：场景设计</p><span id="more"></span><h3 id="场景漫游展示"><a href="#场景漫游展示" class="headerlink" title="场景漫游展示"></a>场景漫游展示</h3><p><a href="https://www.bilibili.com/video/BV1hb4y1778m/">https://www.bilibili.com/video/BV1hb4y1778m/</a></p><h3 id="参考原画"><a href="#参考原画" class="headerlink" title="参考原画"></a>参考原画</h3><p><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/scene/ref.png" alt="图片alt" title="图片title"></p><h3 id="高模在maya中的展示效果"><a href="#高模在maya中的展示效果" class="headerlink" title="高模在maya中的展示效果"></a>高模在maya中的展示效果</h3><p><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/scene/gaomo_1.png" alt="图片alt" title="图片title"><br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/scene/gaomo_2.png" alt="图片alt" title="图片title"><br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/scene/gaomo_3.png" alt="图片alt" title="图片title"><br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/scene/gaomo_4.png" alt="图片alt" title="图片title"><br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/scene/gaomo_5.png" alt="图片alt" title="图片title"><br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/scene/gaomo_6.png" alt="图片alt" title="图片title"><br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/scene/gaomo_7.png" alt="图片alt" title="图片title"><br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/scene/gaomo_8.png" alt="图片alt" title="图片title"></p><h3 id="在substance-painter中设置材质球后的展示"><a href="#在substance-painter中设置材质球后的展示" class="headerlink" title="在substance painter中设置材质球后的展示"></a>在substance painter中设置材质球后的展示</h3><p><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/scene/final_1.png" alt="图片alt" title="图片title"><br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/scene/final_2.png" alt="图片alt" title="图片title"><br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/scene/final_3.png" alt="图片alt" title="图片title"><br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/scene/final_4.png" alt="图片alt" title="图片title"><br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/scene/final_5.png" alt="图片alt" title="图片title"><br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/scene/final_6.png" alt="图片alt" title="图片title"><br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/scene/final_7.png" alt="图片alt" title="图片title"></p><h3 id="将painter中的贴图导出后在maya中设置材质球的效果"><a href="#将painter中的贴图导出后在maya中设置材质球的效果" class="headerlink" title="将painter中的贴图导出后在maya中设置材质球的效果"></a>将painter中的贴图导出后在maya中设置材质球的效果</h3><p><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/scene/dimo_inmaya_1.png" alt="图片alt" title="图片title"><br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/scene/dimo_inmaya_2.png" alt="图片alt" title="图片title"><br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/scene/dimo_inmaya_3.png" alt="图片alt" title="图片title"><br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/scene/dimo_inmaya_4.png" alt="图片alt" title="图片title"><br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/scene/dimo_inmaya_5.png" alt="图片alt" title="图片title"></p><h3 id="配置好贴图的低模在场景中的效果"><a href="#配置好贴图的低模在场景中的效果" class="headerlink" title="配置好贴图的低模在场景中的效果"></a>配置好贴图的低模在场景中的效果</h3><p><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/scene/changjing_1.jpg" alt="图片alt" title="图片title"><br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/scene/changjing_2.jpg" alt="图片alt" title="图片title"><br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/scene/changjing_3.jpg" alt="图片alt" title="图片title"><br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/scene/changjing_4.jpg" alt="图片alt" title="图片title"></p><h3 id="整个场景截图展示"><a href="#整个场景截图展示" class="headerlink" title="整个场景截图展示"></a>整个场景截图展示</h3><p><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/scene/all_1.jpg" alt="图片alt" title="图片title"><br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/scene/all_2.jpg" alt="图片alt" title="图片title"><br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/scene/all_3.jpg" alt="图片alt" title="图片title"><br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/scene/all_4.jpg" alt="图片alt" title="图片title"><br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/scene/all_5.jpg" alt="图片alt" title="图片title"><br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/scene/all_6.jpg" alt="图片alt" title="图片title"><br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/scene/all_7.jpg" alt="图片alt" title="图片title"><br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/scene/all_8.jpg" alt="图片alt" title="图片title"><br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/scene/all_9.jpg" alt="图片alt" title="图片title"><br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/scene/all_10.jpg" alt="图片alt" title="图片title"><br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/scene/all_11.jpg" alt="图片alt" title="图片title"><br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/scene/all_12.jpg" alt="图片alt" title="图片title"></p>]]></content>
      
      
      <categories>
          
          <category> Design&amp;Art </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Homework </tag>
            
            <tag> Art </tag>
            
            <tag> Scene Degign </tag>
            
            <tag> Modeling </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git Management Problems</title>
      <link href="/2023/05/23/Git-Management-Problems/"/>
      <url>/2023/05/23/Git-Management-Problems/</url>
      
        <content type="html"><![CDATA[<p>git 管理相关问题及解决</p><span id="more"></span><h3 id="git-submodule-如何push-代码"><a href="#git-submodule-如何push-代码" class="headerlink" title="git submodule 如何push 代码"></a>git submodule 如何push 代码</h3><ul><li>cd your_submodule</li><li>git checkout master</li><li>git commit -a -m “commit message”</li><li>git push</li><li>cd ..</li><li>git add your_submodule</li><li>git commit -m “Update submodule”</li><li>git submodule update –remote</li><li>git pull –recurse-submodules</li></ul><h3 id="在一台新的电脑上使用exchange服务器无法git-pull-git-push-操作"><a href="#在一台新的电脑上使用exchange服务器无法git-pull-git-push-操作" class="headerlink" title="在一台新的电脑上使用exchange服务器无法git pull git push 操作"></a>在一台新的电脑上使用exchange服务器无法git pull git push 操作</h3><ul><li>git config –global –add safe.directory</li><li>打开新的电脑上用户名文件夹下的config文件，查看其中的路径是否正确。示例：%(prefix)&#x2F;&#x2F;&#x2F;192.168.16.73&#x2F;exchange&#x2F;DDBlender插件&#x2F;3.3&#x2F;ddblender。其中%(prefix)应该是服务器路径的一种语法规定，要按照这种形式输入才有效，另外，中文路径注意编码问题。</li><li>出现访问受限无法push的情况，可以使用<code>git config --system --unset credential.helper</code>重置git的认证设置，在push时手动输入用户名和密码，然后再使用<code>git config --global credential.helper store</code>保存用户密码。</li></ul><h3 id="hexo-d报错无法连接到远程主机"><a href="#hexo-d报错无法连接到远程主机" class="headerlink" title="hexo d报错无法连接到远程主机"></a>hexo d报错无法连接到远程主机</h3><ul><li>报错：<br>ssh: connect to host github.com port 22: Connection timed out<br>fatal: Could not read from remote repository.</li></ul><p>Please make sure you have the correct access rights<br>and the repository exists.</p><ul><li>解决参考：</li><li><ul><li><a href="https://blog.csdn.net/qq_36408085/article/details/104117293%EF%BC%8C%E6%B2%A1%E7%94%A8">https://blog.csdn.net/qq_36408085/article/details/104117293，没用</a></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> Submodule </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动画设计短片作业</title>
      <link href="/2023/05/22/Animation-short-film/"/>
      <url>/2023/05/22/Animation-short-film/</url>
      
        <content type="html"><![CDATA[<p>课程名称：动画设计<br>制作日期：2021 年 6-7 月</p><span id="more"></span><h3 id="一、课程目的"><a href="#一、课程目的" class="headerlink" title="一、课程目的"></a>一、课程目的</h3><p>制作30-60秒的三维动画短⽚。</p><h3 id="二、使用软件"><a href="#二、使用软件" class="headerlink" title="二、使用软件"></a>二、使用软件</h3><ol><li>前期-动画分镜：</li></ol><ul><li>PhotoShop</li></ul><ol start="2"><li>中期-动画制作（包括人物动作设置及镜头移动实现）：</li></ol><ul><li>Unity</li></ul><ol start="3"><li>后期-动画剪辑（包括动画录屏的剪辑和音效的添加）：</li></ol><ul><li>Premiere Pro</li></ul><h3 id="三、制作流程"><a href="#三、制作流程" class="headerlink" title="三、制作流程"></a>三、制作流程</h3><ol><li><pre><code>前期</code></pre><p>构想剧本，灵感来源于野生动物遭受猎杀的新闻，希望能够表达爱护野生动物，禁止猎捕野生动物，人与自然和谐共生的愿景。因此我设置了一个猎人的角色，他在捕猎野生动物的任务中跌下山崖，但却被一只小狐狸所救，因此她被深深地感动，最终改邪归正，成为了森林的守护者。<br>由于时间限制，无法做到所有的资源都由自己制作，因此我在Unity的官方资源网站下载了一些符合  故事情节的资源文件，并根据剧情需要对他们进行了修改和重新整理。比如说对人物的贴图进行修改，和使用Unity状态机对人物的动作状态（如下图）进行修改等。<br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305222031.jpg" alt="图片alt" title="图片title"> </p></li><li><pre><code>中期</code></pre><p>使用Unity引擎进行动画的制作，其中，人物的动画完成和动作切换使用Unity提供的Animator动画 状态机完成，镜头的移动和拉伸使用C#代码编写镜头移动路径及改变相机参数完成。由于不同场景下需 要的人物动画差异较大，整体较难控制，因此我以分镜为单位对动画进行切割，对每个镜头进行分开的  录制。录制成果如下图：<br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305222032.jpg" alt="图片alt" title="图片title"></p></li><li><pre><code>后期</code></pre><p>使用Premiere完成对之前录制的动画镜头的剪辑和后期处理，并自行寻找合适的音频素材添加，最  终合成演示短片。工作截图：<br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305222033.jpg" alt="图片alt" title="图片title"></p></li></ol><h3 id="四、总结和心得"><a href="#四、总结和心得" class="headerlink" title="四、总结和心得"></a>四、总结和心得</h3><p>通过这次作业，我学习了动画的一些基本概念，对三维动画的整体制作流程有了一个全面的认识和<br>了解，学习了在Unity中控制人物状态机来制作流畅连贯的人物动画以及镜头的切换和拉伸。</p><p>在制作中，我遇到的最大问题就是不知如何在短暂有限的镜头中完成自己想进行的表达，由于我采用的是Unity录制的方法，经常在镜头变换的过程中，使得分镜的市场大大超出自己的预期，只能回头调整分镜时长，另外，我也意识到，自己表达和提炼故事核心要点的能力还是不够强，会容易在一些可能不是特别重要的地方浪费短片时长。<br>由于时间限制，在这次作业中一些流程并没有完全由自己完成，而是一定程度上借用了网络上的开源素材完成自己的故事展现，因此我认为今后有机会的话，还应该深度地学习流程中的每一个细节，在练习中精进自己的能力。</p>]]></content>
      
      
      <categories>
          
          <category> Design&amp;Art </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Homework </tag>
            
            <tag> Computer Animation </tag>
            
            <tag> Art </tag>
            
            <tag> Design </tag>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>造型基础课程绘画作业</title>
      <link href="/2023/05/22/Design-and-From/"/>
      <url>/2023/05/22/Design-and-From/</url>
      
        <content type="html"><![CDATA[<p>课程名称：造型基础<br>绘制日期：2019 年</p><span id="more"></span><h3 id="HW1"><a href="#HW1" class="headerlink" title="HW1"></a>HW1</h3><p><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/design/hw1_01.jpg" alt="图片alt" title="图片title"><br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/design/hw1_02.jpg" alt="图片alt" title="图片title"><br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/design/hw1_03.jpg" alt="图片alt" title="图片title"><br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/design/hw1_04.jpg" alt="图片alt" title="图片title"><br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/design/hw1_05.jpg" alt="图片alt" title="图片title"><br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/design/hw1_06.jpg" alt="图片alt" title="图片title"><br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/design/hw1_07.jpg" alt="图片alt" title="图片title"><br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/design/hw1_08.jpg" alt="图片alt" title="图片title"><br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/design/hw1_09.jpg" alt="图片alt" title="图片title"><br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/design/hw1_10.jpg" alt="图片alt" title="图片title"><br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/design/hw1_11.jpg" alt="图片alt" title="图片title"><br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/design/hw1_12.jpg" alt="图片alt" title="图片title"></p><h3 id="HW2"><a href="#HW2" class="headerlink" title="HW2"></a>HW2</h3><p><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/design/hw2_01.jpg" alt="图片alt" title="图片title"><br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/design/hw2_02.jpg" alt="图片alt" title="图片title"><br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/design/hw2_03.jpg" alt="图片alt" title="图片title"><br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/design/hw2_04.jpg" alt="图片alt" title="图片title"><br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/design/hw2_05.jpg" alt="图片alt" title="图片title"><br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/design/hw2_06.jpg" alt="图片alt" title="图片title"></p><h3 id="HW3"><a href="#HW3" class="headerlink" title="HW3"></a>HW3</h3><p><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/design/hw3_01.jpg" alt="图片alt" title="图片title"><br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/design/hw3_02.jpg" alt="图片alt" title="图片title"><br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/design/hw3_03.jpg" alt="图片alt" title="图片title"><br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/design/hw3_04.jpg" alt="图片alt" title="图片title"></p><h3 id="HW4"><a href="#HW4" class="headerlink" title="HW4"></a>HW4</h3><p><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/design/hw4_01.jpg" alt="图片alt" title="图片title"><br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/design/hw4_02.jpg" alt="图片alt" title="图片title"><br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/design/hw4_03.jpg" alt="图片alt" title="图片title"><br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/design/hw4_04.jpg" alt="图片alt" title="图片title"><br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/design/hw4_05.jpg" alt="图片alt" title="图片title"></p>]]></content>
      
      
      <categories>
          
          <category> Design&amp;Art </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Homework </tag>
            
            <tag> Art </tag>
            
            <tag> Degign </tag>
            
            <tag> Hand-painted </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机视觉HW2 - 直线检测和圆检测</title>
      <link href="/2023/05/19/Hough-Circle/"/>
      <url>/2023/05/19/Hough-Circle/</url>
      
        <content type="html"><![CDATA[<p>课程名称：计算机视觉<br>实验项目名称：直线检测和圆检测</p><span id="more"></span><h3 id="一、实验目的和要求"><a href="#一、实验目的和要求" class="headerlink" title="一、实验目的和要求"></a>一、实验目的和要求</h3><p><strong>对输入的一张彩色图像，检测其中的圆形与直线，并将检测结果显示在原图上。</strong></p><ol><li>检测算法的核心功能需要自己 写代码实现， 不能调用 OpenCV 或其他SDK里与圆形直线检测 相关的函数；如果要用到边缘检测，这个可以调用 OpenCV 函数。</li><li>在原图上显示最终的检测结果。</li><li>单独显示一些关键的中间结果</li><li>必须对指定的三张测试图像（ coin 、seal 、highway ）调试结果。此外，自己还可以自愿加一些测试图像。</li></ol><h3 id="二、实验原理"><a href="#二、实验原理" class="headerlink" title="二、实验原理"></a>二、实验原理</h3><h4 id="1）Hough-变换"><a href="#1）Hough-变换" class="headerlink" title="1）Hough 变换"></a>1）Hough 变换</h4><p><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305191646.jpg" alt="图片alt" title="图片title"><br>$$$<br>y&#x3D;mx+c   　　\Rightarrow　　c&#x3D;-xm+y<br>$$$<br>如上图，对于笛卡尔坐标系内的一条直线：$y&#x3D;mx+c$</p><p>以$(x_0,y_0)$点为例，固定$x_0,y_0$为自变量，$(m,c)$为变量，则每个点$(x_0,y_0)$对应于空间$(m,c)$上的一条直线：$c&#x3D;-xm+y$</p><p>通过变换坐标系，将直线和点相互转换，从而将求直线转化为求多条直线的交点。</p><p>但是上述转换存在直线垂直时，斜率是无穷大的情况，因此我们换用极坐标系。</p><p>直角坐标系中的点是极坐标系中的线，直角坐标系中的线是极坐标系中的点。</p><p>如下图所示，想要检测图像中的直线，可以使用Hough变换，转化为检测极坐标系中的点  $(\theta, \rho)$  。</p><p><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305191647.jpg" alt="图片alt" title="图片title"></p><h4 id="2）直线Hough变换"><a href="#2）直线Hough变换" class="headerlink" title="2）直线Hough变换"></a>2）直线Hough变换</h4><p>笛卡尔坐标系中的直线，由斜率和截距表示，而极坐标中用 $(\theta, \rho)$ 表示，并且存在下式关系：<br>$$$<br>\rho &#x3D; cos(\theta)\cdot x + sin(\theta)\cdot y<br>$$$<br>对于点 $(x_0,y_0)$，代入上式，在极坐标中就是一条线（很多对 $(\theta, \rho)$ 点）：<br>$$$<br>r &#x3D; cos(\theta)\cdot x_0 + sin(\theta)\cdot y_0<br>$$$<br> $(\theta, \rho)$ 就是一对Hough空间的变量表示。一个点 $(x_0,y_0)$, 就是一个正弦曲线。</p><p><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305191648.jpg" alt="图片alt" title="图片title"></p><p>如下图，直角坐标系中的多个点，对应于 $\rho - \theta$ 空间的多条正弦曲线。</p><p><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305191649.jpg" alt="图片alt" title="图片title"></p><p><strong>直角坐标系的三点共线，对应于 $\rho - \theta$ 空间的多线共点</strong>。</p><p>因此，我们可以通过检测 $\rho - \theta$ 空间的交集点，来检测原始空间的线段。</p><p>接下来，就是要考虑 将 $\rho - \theta$ 离散化，形成离散化的Hough空间，用于统计交集点的个数。</p><h4 id="3）累加器"><a href="#3）累加器" class="headerlink" title="3）累加器"></a>3）累加器</h4><p><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305191650.jpg" alt="图片alt" title="图片title"></p><p>将参数空间离散化，从而得到一个二维数组累加器，记录 $\rho - \theta$ 空间每对参数 $(\theta, \rho)$ 出现的次数，大于某个阈值的，就证明有线相交于该点，也就证明原笛卡尔坐标系中有直线。</p><h4 id="4）圆的Hough变换"><a href="#4）圆的Hough变换" class="headerlink" title="4）圆的Hough变换"></a>4）圆的Hough变换</h4><p>给定一个圆弧有三个参数，$a,b$用来确定圆心位置，$\rho$确定半径。<br>$$$<br>b&#x3D;atan\theta-xtan\theta+y<br>$$$</p><p>类似直线，将$(x_0,y_0)$固定，而将$(a,b,\rho)$作为变量：<br>$$$<br>x&#x3D;a+\rho cos \theta   　　 \Rightarrow　　  a&#x3D;x-\rho cos \theta  \<br>y&#x3D;b+\rho sin \theta     　　　　　　          b&#x3D;y-\rho sin \theta<br>$$$<br>因此可以创建hough三维累加器，对于圆图像中的每一个点计算对应的$(a,b,\rho)$点对。</p><p>但由于是三维累加器，会大大增加计算量。因此我们采用霍夫梯度法，先找出圆心的坐标。</p><p>我们令$\rho$为边缘点处的梯度角，则上面的公式可以变换为：<br>$$$<br>b &#x3D; a tan\theta-x tan\theta+y<br>$$$<br>如下图，圆的边缘点切线的垂直方向,也就是梯度方向经过圆点。所以我们可以建立关于$(a,b)$的二位累加器，遍历图像的所有点，对每个像素点计算梯度（本实验中使用Sobel算子），对该直线上的所有像素点进行投票，最后选取超过阈值的像素点作为阈值，为了避免选取过多的圆心，把距离小于某一个阈值的圆心当做同一个圆心。</p><p><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305191651.jpg" alt="图片alt" title="图片title"></p><p>下一步，对于每一个投票选出的圆心，遍历整个图像，计算他们与该圆心的距离，然后将距离值排序，在某一个距离范围区间内，点超过一定数量的，就可以将该距离作为该圆心对应的一个半径。</p><p>全部遍历完成后，就可以得到$(a,b,\theta)$点对表示的圆检测结果。</p><h3 id="三、实验内容和过程分析"><a href="#三、实验内容和过程分析" class="headerlink" title="三、实验内容和过程分析"></a>三、实验内容和过程分析</h3><h4 id="1-主函数及图像读入和预处理流程分析"><a href="#1-主函数及图像读入和预处理流程分析" class="headerlink" title="1) 主函数及图像读入和预处理流程分析"></a>1) 主函数及图像读入和预处理流程分析</h4><p>本实验中，读入图像后我对图像做了一下预处理：</p><ol><li>转化为灰度图</li><li>高斯滤波以及均值滤波，图像去噪，防止噪声干扰边缘检测</li><li>使用Canny算子计算图像边缘并展示</li><li>将边缘图像作为掩码拷贝源图像，从而展示彩色的边缘图像</li></ol><p>预处理之后进入正式的直线和圆形检测，调用“HoughLine”以及“HoughCircle”模块中的函数</p><ol><li>使用Hough变换检测直线并返回结果，在源图像上绘制结果直线</li><li>使用Hough梯度法检测原型并返回结果，在源图像上绘制结果圆</li></ol><p>以下是简化版的主函数代码，其中包括图像预处理以及直线和圆检测函数的调用（篇幅限制，仅展示主要内容）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;Vec3f&gt; circles;</span><br><span class="line">vector&lt;Line&gt; lines;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读入图像</span></span><br><span class="line">Mat src = <span class="built_in">imread</span>(<span class="string">&quot;1.jpg&quot;</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (!src.data)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;图像不存在！&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;source&quot;</span>, src);  <span class="comment">//展示源图像</span></span><br><span class="line"><span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">Mat src_edge;</span><br><span class="line"><span class="built_in">cvtColor</span>(src, src_gray, CV_BGR2GRAY);  <span class="comment">//转换为灰度图</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//高斯滤波，减弱噪声，避免检测时产生干扰</span></span><br><span class="line"><span class="built_in">GaussianBlur</span>(src_gray, src_gray, <span class="built_in">Size</span>(<span class="number">9</span>, <span class="number">9</span>), <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;guass&quot;</span>, src_gray);</span><br><span class="line"><span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//对灰度图再做一次均值滤波</span></span><br><span class="line"><span class="built_in">blur</span>(src_gray, src_edge, <span class="built_in">Size</span>(<span class="number">3</span>, <span class="number">3</span>));</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;mean&quot;</span>, src_edge);</span><br><span class="line"><span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用Canny算子计算图像边缘并展示</span></span><br><span class="line">Mat edges;</span><br><span class="line"><span class="type">int</span> canny_threshold = <span class="number">40</span>;</span><br><span class="line"><span class="built_in">Canny</span>(src_edge, edges, <span class="built_in">MAX</span>(canny_threshold / <span class="number">2</span>, <span class="number">1</span>), canny_threshold, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;edges&quot;</span>, edges);</span><br><span class="line"><span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用Canny算子输出的边缘图，edges作为掩码，</span></span><br><span class="line"><span class="comment">//来将原图image拷贝到目标图dst中，从而显示彩色的边缘图像</span></span><br><span class="line">Mat image = src.<span class="built_in">clone</span>();</span><br><span class="line">Mat dst;</span><br><span class="line">dst.<span class="built_in">create</span>(image.<span class="built_in">size</span>(), image.<span class="built_in">type</span>());</span><br><span class="line">dst = Scalar::<span class="built_in">all</span>(<span class="number">0</span>);</span><br><span class="line">image.<span class="built_in">copyTo</span>(dst, edges);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;colorful_edge&quot;</span>, dst);</span><br><span class="line"><span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//hough检测圆形并返回结果</span></span><br><span class="line"><span class="built_in">houghcircles</span>(src_gray, edges, circles, <span class="number">10</span>, <span class="number">40</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//在原图像上绘制检测到的圆形并输出结果</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; circles.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line"><span class="function">Point <span class="title">center</span><span class="params">(cvRound(circles[i][<span class="number">0</span>]), cvRound(circles[i][<span class="number">1</span>]))</span></span>;</span><br><span class="line"><span class="type">int</span> radius = <span class="built_in">cvRound</span>(circles[i][<span class="number">2</span>]);</span><br><span class="line"><span class="built_in">circle</span>(src, center, <span class="number">3</span>, <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">-1</span>, <span class="number">8</span>, <span class="number">0</span>);  <span class="comment">//圆心</span></span><br><span class="line"><span class="built_in">circle</span>(src, center, radius, <span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">2</span>, <span class="number">8</span>, <span class="number">0</span>);  <span class="comment">//圆</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//hough检测直线并返回结果</span></span><br><span class="line"><span class="built_in">houghlines</span>(edges, lines, <span class="number">110</span>);</span><br><span class="line"><span class="comment">//在原图像上绘制检测到的直线并输出结果</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; lines.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">Point s = lines[i].start;</span><br><span class="line">Point e = lines[i].end;</span><br><span class="line"><span class="built_in">line</span>(src, s, e, <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//展示绘制结果后的图像</span></span><br><span class="line"><span class="built_in">namedWindow</span>(<span class="string">&quot;Result&quot;</span>, CV_WINDOW_AUTOSIZE);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Result&quot;</span>, src);</span><br><span class="line"><span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><h4 id="2）Hough变换检测直线"><a href="#2）Hough变换检测直线" class="headerlink" title="2）Hough变换检测直线"></a>2）Hough变换检测直线</h4><ol><li><strong>HoughLine模块结构体及函数原型</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ρ-θ空间累加器</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Polar</span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//用于返回直线两端的坐标</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Line</span>&#123;</span><br><span class="line">    Point start;</span><br><span class="line">    Point end;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">polar_order</span><span class="params">(Polar a, Polar b)</span></span>;  <span class="comment">//用于排序</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_position</span><span class="params">(Mat img, <span class="type">int</span> ii, <span class="type">int</span> jj, <span class="type">int</span> flag)</span></span>;  <span class="comment">//对于水平和垂直的直线，找回Hough变换时损失的信息</span></span><br><span class="line"><span class="comment">//hough变换检测直线</span></span><br><span class="line"><span class="comment">//img：输入的边缘图像（灰度图，只有0,255两个值）</span></span><br><span class="line"><span class="comment">//lines：储存最后检测出的直线起始点</span></span><br><span class="line"><span class="comment">//threshold：累加器阈值，只有累加器中的值大于该值，该参数对才会被选中</span></span><br><span class="line"><span class="comment">//rho：ρ参数的分辨率（遍历步长）</span></span><br><span class="line"><span class="comment">//theta：θ参数的分辨率（遍历步长）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">houghlines</span><span class="params">(Mat img,vector&lt;Line&gt;&amp; lines, <span class="type">int</span> threshold, <span class="type">double</span> rho = <span class="number">1</span>, <span class="type">double</span> theta = <span class="number">1</span>)</span></span>;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>适当地量化参数空间（合适的精度即可）</strong></li></ol><p>根据图像大小及分辨率（精度）计算累加器大小</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//图像长宽</span></span><br><span class="line"><span class="type">int</span> w = img.cols;</span><br><span class="line"><span class="type">int</span> h = img.rows;</span><br><span class="line"><span class="comment">//累加器大小</span></span><br><span class="line"><span class="type">int</span> add_w = <span class="number">180</span>/theta;</span><br><span class="line"><span class="type">int</span> add_h = <span class="number">1.5</span> * (w + h) /rho ;</span><br><span class="line"><span class="comment">//消除值为负的ρ</span></span><br><span class="line"><span class="type">int</span> center_h = add_h / <span class="number">2</span>;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>假定参数空间的每一个单元都是一个累加器，把累加器初始化为零</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为累加器分配空间</span></span><br><span class="line">   <span class="type">int</span>** add = (<span class="type">int</span>**)<span class="built_in">malloc</span>(add_h * <span class="built_in">sizeof</span>(<span class="type">int</span>*));</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; add_h; i++)</span><br><span class="line">       add[i] = (<span class="type">int</span>*)<span class="built_in">malloc</span>((add_w + <span class="number">1</span>) * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">   <span class="comment">//累加器赋值为0</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; add_h; i++)</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; add_w; j++)</span><br><span class="line">           add[i][j] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>对图像空间的每一点，在其所满足的参数方程对应的累加器上加1</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//累加器投票</span></span><br><span class="line">   <span class="type">int</span> threshold_pix = <span class="number">200</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; h; i++)</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; w; j++)</span><br><span class="line">           <span class="keyword">if</span> ((<span class="type">int</span>)img.<span class="built_in">at</span>&lt;uchar&gt;(i, j) &gt; threshold_pix)</span><br><span class="line">               <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">180</span>; k=k+theta) &#123;</span><br><span class="line">                   <span class="type">double</span> angle = (<span class="type">double</span>)k / <span class="number">180</span> * PI;  <span class="comment">//角度制转换为弧度值</span></span><br><span class="line">                   <span class="type">double</span> dr = (<span class="type">double</span>)j * <span class="built_in">cos</span>(angle) + (<span class="type">double</span>)i * <span class="built_in">sin</span>(angle);</span><br><span class="line">                   <span class="type">int</span> r = <span class="built_in">round</span>(dr)/rho;</span><br><span class="line">                   <span class="type">int</span> kk = k/theta;</span><br><span class="line">                   add[r + center_h][kk]++;  <span class="comment">//r可为负值，加上矩阵中心                  </span></span><br><span class="line">               &#125;</span><br></pre></td></tr></table></figure><ol start="5"><li><strong>累加器阵列的超过阈值的点对应直线的参数</strong></li></ol><p>在这里对原算法进行了改进，判断累加器是，需要该点同时满足值超过阈值和大于自身周围的点的累加器值，才将该点选中。</p><p>并且在选中点之后，对其做一个聚合操作，即将其周围一定区间内的累加器的值也看做是一条直线，同时累加给该点。</p><p>（原理相似处代码此处省略）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历累加器，选出符合规定的ρ-θ点对作为检测到的直线参数</span></span><br><span class="line">vector&lt;Polar&gt; v;  </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">1</span>; y &lt; add_h - <span class="number">1</span>; y++)<span class="comment">//模长</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; add_w; x++)<span class="comment">//角度</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//如果当前点在累加器边界处</span></span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> (add[y][x] &gt; threshold &amp;&amp; add[y][x] &gt; add[y][x + <span class="number">1</span>] &amp;&amp; </span><br><span class="line">                add[y][x] &gt; add[y - <span class="number">1</span>][x] &amp;&amp; add[y][x] &gt; add[y + <span class="number">1</span>][x]) flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x == add_w - <span class="number">1</span>) <span class="comment">//此处省略</span></span><br><span class="line">        <span class="comment">//如果当前的值大于阈值，并在4邻域内它是最大值，则该点被认为是圆心</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (add[y][x] &gt; threshold &amp;&amp; add[y][x] &gt; add[y][x - <span class="number">1</span>] &amp;&amp;</span><br><span class="line">            add[y][x] &gt; add[y][x + <span class="number">1</span>] &amp;&amp; add[y][x] &gt; add[y - <span class="number">1</span>][x] &amp;&amp;</span><br><span class="line">            add[y][x] &gt; add[y + <span class="number">1</span>][x])  flag = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//选择该点表示的参数作为一条直线的参数</span></span><br><span class="line">        <span class="keyword">if</span> (flag)</span><br><span class="line">        &#123;</span><br><span class="line">            Polar po;</span><br><span class="line">            po.x = y;    <span class="comment">//ρ</span></span><br><span class="line">            po.y = x;    <span class="comment">//θ</span></span><br><span class="line">            po.count = add[y][x];</span><br><span class="line">            <span class="comment">//聚合，如果当前参数对被选中，则把相邻(-5,5)区间内的累加器值都加给它</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> p = y - <span class="number">5</span>; p &lt;= y + <span class="number">5</span>; p++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> q = x - <span class="number">5</span>; q &lt;= x + <span class="number">5</span>; q++)</span><br><span class="line">                    <span class="keyword">if</span> (p &gt;= <span class="number">0</span> &amp;&amp; p &lt;= add_h - <span class="number">1</span> &amp;&amp; q &gt;= <span class="number">0</span> &amp;&amp; q &lt;= add_w - <span class="number">1</span>)</span><br><span class="line">                        po.count += add[p][q];</span><br><span class="line"></span><br><span class="line">            v.<span class="built_in">push_back</span>(po); <span class="comment">//当前点符合要求，作为圆心</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li><p><strong>将结果记录到lines</strong></p><p>对已经被选中的点降序排列后，反推计算出其在原图像中对应的直线的起始点坐标，并记录到lines中。（此处代码简化）</p><p>在这里分四种情况处理：</p><ul><li>水平直线</li><li>垂直直线</li><li>$\theta$  较小</li><li>$\theta$  较大</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对检测到的参数对按照累加器中的值大小降序排列</span></span><br><span class="line">   <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), polar_order);</span><br><span class="line">   <span class="comment">//将投票数最多的直线转换到笛卡尔坐标系计算出起始点坐标并存入名为lines的vector</span></span><br><span class="line">   vector&lt;Polar&gt;::iterator iter;</span><br><span class="line">   <span class="keyword">for</span> (iter = v.<span class="built_in">begin</span>(); iter != v.<span class="built_in">end</span>(); iter++) &#123;</span><br><span class="line">       <span class="keyword">if</span> (iter-&gt;y == <span class="number">0</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           y1 = <span class="number">0</span>;</span><br><span class="line">           y2 = h - <span class="number">1</span>;</span><br><span class="line">           x1 = x2 = <span class="built_in">get_position</span>(img, iter-&gt;x, iter-&gt;y, <span class="literal">false</span>);</span><br><span class="line">           Line temp;</span><br><span class="line">           temp.start = <span class="built_in">Point</span>(x1, y1);</span><br><span class="line">           temp.end = <span class="built_in">Point</span>(x2, y2);</span><br><span class="line">           lines.<span class="built_in">push_back</span>(temp);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (iter-&gt;y == <span class="number">90</span>)&#123;<span class="comment">//此处省略&#125;</span></span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (iter-&gt;y &gt;= <span class="number">45</span> &amp;&amp; iter-&gt;y &lt;= <span class="number">135</span>) &#123;<span class="comment">//在这个范围内sin值比较大，使用sin做分母误差较小</span></span><br><span class="line">           x1 = <span class="number">0</span>;</span><br><span class="line">           y1 = (iter-&gt;x - center_h) / si; <span class="comment">//加上之前为了消除ρ的负值减去的值</span></span><br><span class="line">           x2 = w - <span class="number">1</span>;</span><br><span class="line">           y2 = ((iter-&gt;x - center_h) - (<span class="type">double</span>)x2 * co) / si;</span><br><span class="line">           Line temp;</span><br><span class="line">           temp.start = <span class="built_in">Point</span>(x1, y1);</span><br><span class="line">           temp.end = <span class="built_in">Point</span>(x2, y2);</span><br><span class="line">           lines.<span class="built_in">push_back</span>(temp);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> &#123; <span class="comment">//在这个范围内cos值比较大，使用cos做分母误差较小     //此处省略 </span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="3）Hough梯度法检测圆形"><a href="#3）Hough梯度法检测圆形" class="headerlink" title="3）Hough梯度法检测圆形"></a>3）Hough梯度法检测圆形</h4><ol><li><strong>HoughCircle模块结构体及函数原型</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PI  3.14159265358979</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOUGH_CIRCLE_RADIUS_MIN10  <span class="comment">//圆最小半径</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOUGH_CIRCLE_RADIUS_MIN_DIST2   <span class="comment">//同心圆两个半径最小差</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOUGH_CIRCLE_INTEGRITY_DEGREE0.6  <span class="comment">//用于判断圆周上的点是否足够多（是否能成圆）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOUGH_CIRCLE_SAMEDIRECT_DEGREE0.99  <span class="comment">//用于梯度检测</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOUGH_CIRCLE_GRADIENT_INTEGRITY_DEGREE0.9   <span class="comment">//用于梯度检测</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//记录圆心</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Centers2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">center_order</span><span class="params">(Centers2 a, Centers2 b)</span></span>;  <span class="comment">//用于排序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//记录其他点与圆心的距离和内积</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Radius</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> dist2;</span><br><span class="line">    <span class="type">double</span> inner_product;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">radius_order</span><span class="params">(Radius a, Radius b)</span></span>;  <span class="comment">//用于排序</span></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">normalization</span><span class="params">(<span class="type">float</span> x)</span></span>;  <span class="comment">//用于归一化圆心检测图像并放大差异，从而使圆心识别效果更好</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//hough梯度法检测圆形</span></span><br><span class="line"><span class="comment">//src_gray：灰度图像</span></span><br><span class="line"><span class="comment">//edges：边缘图像</span></span><br><span class="line"><span class="comment">//circles：储存结果圆参数</span></span><br><span class="line"><span class="comment">//min_dist：两圆心之间的最小距离，小于该距离两圆心将被合并</span></span><br><span class="line"><span class="comment">//add_threshold：阈值，累加器中大于该值的点才能被选定为圆心</span></span><br><span class="line"><span class="comment">//min_Radius：圆最小半径</span></span><br><span class="line"><span class="comment">//min_Radius：圆最大半径</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">houghcircles</span><span class="params">(cv::Mat&amp; src_gray, Mat edges, std::vector&lt;cv::Vec3f&gt;&amp; circles,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">double</span> min_dist, <span class="type">int</span> param2, <span class="type">int</span> minRadius = <span class="number">0</span>, <span class="type">int</span> maxRadius = <span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>量化关于a，b的参数空间到合适精度，创建并初始化累加器</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据分辨率计算累加器的大小 dp为分辨率，此处为1</span></span><br><span class="line"><span class="type">int</span> add_rows = (<span class="type">double</span>)src_gray.rows / dp + <span class="number">0.5</span>;</span><br><span class="line"><span class="type">int</span> add_cols = (<span class="type">double</span>)src_gray.cols / dp + <span class="number">0.5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建累加器矩阵并为累加器分配内存</span></span><br><span class="line"><span class="type">int</span>** add = (<span class="type">int</span>**)<span class="built_in">malloc</span>(add_rows * <span class="built_in">sizeof</span>(<span class="type">int</span>*));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; add_rows; i++)</span><br><span class="line">add[i] = (<span class="type">int</span>*)<span class="built_in">malloc</span>((add_cols) * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//累加器赋值为0</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; add_rows; i++) </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; add_cols; j++) </span><br><span class="line">add[i][j] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><ol start="3"><li><p><strong>计算图像空间中边缘点的梯度幅度和角度，遍历边缘图像，若边缘点参数坐标满足则该参数坐标对应的累加器加1</strong></p><p>使用Sobel算子计算边缘图像梯度，并根据分辨率遍历边缘图像计算累加器（篇幅限制，部分细节代码省略）。</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用Sobel算子计算水平梯度和垂直梯度</span></span><br><span class="line">cv::<span class="built_in">Sobel</span>(src_gray, dx, CV_16SC1, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">cv::<span class="built_in">Sobel</span>(src_gray, dy, CV_16SC1, <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">Point pt;</span><br><span class="line"><span class="comment">//记录累加器中的最大值</span></span><br><span class="line"><span class="type">int</span> accum_max = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//遍历边缘图像</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt; rows; y++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; cols; x++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//如果当前的像素不是边缘点，或者水平梯度值和垂直梯度值都为0</span></span><br><span class="line"><span class="keyword">if</span> (!edges_row[x] || (dx_now == <span class="number">0</span> &amp;&amp; dy_now == <span class="number">0</span>))<span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">//计算当前点的梯度模长</span></span><br><span class="line"><span class="type">float</span> length = <span class="built_in">sqrt</span>(dx_now * dx_now + dy_now * dy_now);</span><br><span class="line"><span class="comment">//单位梯度向量所对应的水平和垂直的位移，作为遍历时的步长</span></span><br><span class="line">sx = <span class="built_in">cvRound</span>((dx_now / dp) / length * ONE );</span><br><span class="line">sy = <span class="built_in">cvRound</span>((dy_now / dp) / length * ONE );</span><br><span class="line"><span class="comment">//当前点的坐标按照相同比例映射到累加器坐标</span></span><br><span class="line"><span class="type">int</span> x_now = <span class="built_in">cvRound</span>((x / dp) * ONE); </span><br><span class="line"><span class="type">int</span> y_now = <span class="built_in">cvRound</span>((y / dp) * ONE);</span><br><span class="line"><span class="comment">//在梯度向量的正反两个方向分别计算累加器</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> times = <span class="number">0</span>; times &lt; <span class="number">2</span>; times++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//初始化坐标值，最小半径对应的位移</span></span><br><span class="line">x1 = x_now + minRadius * sx;</span><br><span class="line">y1 = y_now + minRadius * sy;</span><br><span class="line"><span class="comment">//控制圆的半径在一定范围之内</span></span><br><span class="line"><span class="keyword">for</span> (r = minRadius; r &lt;= maxRadius; x1 += sx, y1 += sy, r++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x2 = x1 &gt;&gt; SHIFT, y2 = y1 &gt;&gt; SHIFT; <span class="comment">//按照比例缩放回真实大小</span></span><br><span class="line">add[y2][x2]++;  <span class="comment">//在累加器的相应位置上加1</span></span><br><span class="line"><span class="keyword">if</span> (add[y2][x2] &gt; accum_max) accum_max = add[y2][x2]; <span class="comment">//记录累加器中最大的值</span></span><br><span class="line">&#125;</span><br><span class="line">sx = -sx; sy = -sy; <span class="comment">//把位移量设置为反方向</span></span><br><span class="line">&#125;</span><br><span class="line">pt.x = x; pt.y = y;</span><br><span class="line">points.<span class="built_in">push_back</span>(pt);  <span class="comment">//记录边缘图像中的当前点</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>选出累加器的值大于一定阈值且局部最大的点，所在的坐标即为图像空间中的圆心之所在，并展示圆心选择结果</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对累加器做归一化和放大差异</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">1</span>; y &lt; add_rows - <span class="number">1</span>; y++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">1</span>; x &lt; add_cols - <span class="number">1</span>; x++)</span><br><span class="line">add[y][x] = <span class="built_in">normalization</span>((<span class="type">float</span>)add[y][x] / accum_max) * <span class="number">256</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历累加器</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">1</span>; y &lt; add_rows - <span class="number">1</span>; y++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">1</span>; x &lt; add_cols - <span class="number">1</span>; x++)</span><br><span class="line"><span class="comment">//当前值是阈值且局部最大</span></span><br><span class="line"><span class="keyword">if</span> (add[y][x] &gt; add_threshold &amp;&amp; add[y][x] &gt; add[y][x - <span class="number">1</span>] &amp;&amp;</span><br><span class="line">add[y][x] &gt; add[y][x + <span class="number">1</span>] &amp;&amp; add[y][x] &gt; add[y - <span class="number">1</span>][x] &amp;&amp;</span><br><span class="line">add[y][x] &gt; add[y + <span class="number">1</span>][x])  &#123;</span><br><span class="line">Centers2 temp; <span class="comment">//将当前点作为圆心</span></span><br><span class="line">temp.x = x;</span><br><span class="line">temp.y = y;</span><br><span class="line">temp.count = add[y][x];</span><br><span class="line">centers2.<span class="built_in">push_back</span>(temp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//展示选择圆心的图像</span></span><br><span class="line">Mat center_img = <span class="built_in">Mat</span>(add_rows, add_cols, CV_32SC1);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows; i++)</span><br><span class="line"><span class="type">int</span>* ptmp = center_img.<span class="built_in">ptr</span>&lt;<span class="type">int</span>&gt;(i);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; cols; j++)</span><br><span class="line">center_img.<span class="built_in">at</span>&lt;<span class="type">int</span>&gt;(i, j) = add[i][j];</span><br><span class="line">cv::<span class="built_in">normalize</span>(center_img, center_img, <span class="number">0</span>, <span class="number">255</span>, cv::NORM_MINMAX);</span><br><span class="line">center_img.<span class="built_in">convertTo</span>(center_img, CV_8UC1);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;centers&quot;</span>, center_img);</span><br><span class="line"><span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><ol start="5"><li><p><strong>得到圆心坐标之后，反求圆心对应的半径ρ</strong></p><p>外层遍历得到的圆心，内层遍历所有参与计算的边缘图像中的点，计算他们与当前圆心的距离，并记录所有距离数据在名为Radius的vector中，对vector进行排序，之后遍历vector，对于在参数min_Radius范围内，圆周上的点数目大于一定阈值的半径，则作为该圆心对应的半径之一（考虑同心圆）。（代码部分省略）</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将圆心序列按照累加器中的数目降序排序</span></span><br><span class="line"><span class="built_in">sort</span>(centers2.<span class="built_in">begin</span>(), centers2.<span class="built_in">end</span>(), center_order);</span><br><span class="line"><span class="comment">//最小距离的平方</span></span><br><span class="line">min_dist *= min_dist;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按照累加器中的值由大到小的顺序遍历整个圆心序列</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; centers2.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">radius.<span class="built_in">clear</span>();</span><br><span class="line"><span class="type">int</span> y = centers2[i].y;</span><br><span class="line"><span class="type">int</span> x = centers2[i].x;</span><br><span class="line"><span class="comment">//计算圆心在输入图像中的坐标位置</span></span><br><span class="line"><span class="type">float</span> cx = (<span class="type">float</span>)((x + <span class="number">0.5f</span>) * dp), cy = (<span class="type">float</span>)((y + <span class="number">0.5f</span>) * dp);</span><br><span class="line"><span class="type">float</span> start_dist, dist_sum;</span><br><span class="line"><span class="comment">//判断当前的圆心是否之前已经输出过（如果距离小于min_dist，则判定为同一个圆心）</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; circles.<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">cv::Vec3f center = circles[j];</span><br><span class="line"><span class="keyword">if</span> ((center[<span class="number">0</span>] - cx) * (center[<span class="number">0</span>] - cx) + (center[<span class="number">1</span>] - cy) * (center[<span class="number">1</span>] - cy) &lt; min_dist) </span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (j &lt; circles.<span class="built_in">size</span>())<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历之前记录的边缘图像中的所有点</span></span><br><span class="line"><span class="keyword">for</span> (j = k = <span class="number">0</span>; j &lt; points_count; j++)&#123;</span><br><span class="line">cv::Point pt;</span><br><span class="line">pt = points[j];</span><br><span class="line"><span class="comment">//计算边缘图像中的点与当前圆心的距离</span></span><br><span class="line"><span class="type">float</span> _dx = cx - pt.x;  <span class="type">float</span> _dy = cy - pt.y;</span><br><span class="line"><span class="type">float</span> _r2 = _dx * _dx + _dy * _dy;</span><br><span class="line"><span class="type">short</span> sx = dxdy_row[<span class="number">0</span>];</span><br><span class="line"><span class="type">short</span> sy = dxdy_row[<span class="number">1</span>];</span><br><span class="line"><span class="comment">//记录所有在范围内的距离</span></span><br><span class="line"><span class="keyword">if</span> (minRadius2 &lt;= _r2 &amp;&amp; _r2 &lt;= maxRadius2)&#123;</span><br><span class="line">k++;</span><br><span class="line">Radius temp;</span><br><span class="line">temp.dist2 = _r2;</span><br><span class="line">radius.<span class="built_in">push_back</span>(temp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//k表示一共有多少个圆周上的点</span></span><br><span class="line"><span class="type">int</span> point_cnt1 = k, start_idx = point_cnt1 - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (point_cnt1 == <span class="number">0</span>) <span class="keyword">continue</span>;       </span><br><span class="line"><span class="comment">//求平方根</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> t = <span class="number">0</span>; t &lt; point_cnt1; ++t) </span><br><span class="line">radius[t].dist2 = <span class="built_in">pow</span>(radius[t].dist2, <span class="number">0.5</span>);</span><br><span class="line">       </span><br><span class="line"><span class="comment">//对圆半径进行排序，按累加器中的值降序排列</span></span><br><span class="line"><span class="built_in">sort</span>(radius.<span class="built_in">begin</span>(), radius.<span class="built_in">end</span>(), radius_order);</span><br><span class="line"></span><br><span class="line">start_dist = radius[<span class="number">0</span>].dist2;</span><br><span class="line"><span class="comment">//遍历之间计算的半径，选择符合条件的半径</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt;point_cnt1; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">float</span> dist2 = radius[j].dist2;</span><br><span class="line"><span class="type">float</span> inner_product = radius[j].inner_product;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dist2 &gt; maxRadius) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (dist2 - start_dist &lt; HOUGH_CIRCLE_RADIUS_MIN_DIST * dr)&#123;    </span><br><span class="line">cur_r_count++; <span class="comment">//记录圆周点个数</span></span><br><span class="line">cur_r_dist_sum += dist2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//边缘图像上的圆周点足够多，判断圆是否合格</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">float</span> r_mean = cur_r_dist_sum / cur_r_count; <span class="comment">//计算平均半径</span></span><br><span class="line"><span class="keyword">if</span> (cur_r_count &gt;= HOUGH_CIRCLE_INTEGRITY_DEGREE * <span class="number">2</span> * PI * r_mean) &#123;</span><br><span class="line">cv::Vec3f c;</span><br><span class="line">c[<span class="number">0</span>] = cx;    <span class="comment">//圆心的横坐标</span></span><br><span class="line">c[<span class="number">1</span>] = cy;    <span class="comment">//圆心的纵坐标</span></span><br><span class="line">c[<span class="number">2</span>] = (<span class="type">float</span>)r_mean;    <span class="comment">//所对应的圆的半径</span></span><br><span class="line">circles.<span class="built_in">push_back</span>(c);    <span class="comment">//压入序列circles内</span></span><br><span class="line">&#125;</span><br><span class="line">cur_r_count = <span class="number">1</span>;</span><br><span class="line">cur_r_dist_sum = dist2;</span><br><span class="line">start_dist = dist2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四、实验结果展示"><a href="#四、实验结果展示" class="headerlink" title="四、实验结果展示"></a>四、实验结果展示</h3><h5 id="1）直线检测（以highway图像为例）"><a href="#1）直线检测（以highway图像为例）" class="headerlink" title="1）直线检测（以highway图像为例）"></a>1）直线检测（以highway图像为例）</h5><p>​该图像由于噪点较多，影响检测，因此实际实验时将高斯滤波和均值滤波的参数调大。</p><ol><li>源图像</li></ol><p><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305191652.jpg" alt="图片alt" title="图片title"></p><ol start="2"><li>滤波结果（此处仅展示高斯滤波结果，提交的压缩包中将含有高斯滤波和均值滤波）</li></ol><p><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305191653.jpg" alt="图片alt" title="图片title"></p><ol start="3"><li>边缘图像（此处仅展示黑白边缘图像，提交的压缩包中将含有黑白和彩色两种格式）</li></ol><p><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305191654.jpg" alt="图片alt" title="图片title"></p><ol start="4"><li>直线检测结果</li></ol><p><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305191655.jpg" alt="图片alt" title="图片title"></p><h5 id="2）圆形检测（以coins图像为例）"><a href="#2）圆形检测（以coins图像为例）" class="headerlink" title="2）圆形检测（以coins图像为例）"></a>2）圆形检测（以coins图像为例）</h5><ol><li>源图像</li></ol><p><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305191656.jpg" alt="图片alt" title="图片title"></p><ol start="2"><li>滤波结果（此处仅展示高斯滤波结果，提交的压缩包中将含有高斯滤波和均值滤波）</li></ol><p><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305191657.jpg" alt="图片alt" title="图片title"></p><ol start="3"><li>边缘图像（此处仅展示黑白边缘图像，提交的压缩包中将含有黑白和彩色两种格式）</li></ol><p><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305191658.jpg" alt="图片alt" title="图片title"></p><ol start="4"><li>圆心累加器结果</li></ol><p><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305191659.jpg" alt="图片alt" title="图片title"></p><ol start="5"><li>圆形检测结果</li></ol><p><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305191700.jpg" alt="图片alt" title="图片title"></p><h5 id="3）同时检测直线和圆（以seal图像为例）"><a href="#3）同时检测直线和圆（以seal图像为例）" class="headerlink" title="3）同时检测直线和圆（以seal图像为例）"></a>3）同时检测直线和圆（以seal图像为例）</h5><p>1.源图像</p><p><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305191701.jpg" alt="图片alt" title="图片title"></p><ol start="2"><li>滤波结果（此处仅展示高斯滤波结果，提交的压缩包中将含有高斯滤波和均值滤波）</li></ol><p><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305191702.jpg" alt="图片alt" title="图片title"></p><ol start="3"><li>边缘图像（此处仅展示黑白边缘图像，提交的压缩包中将含有黑白和彩色两种格式）</li></ol><p><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305191703.jpg" alt="图片alt" title="图片title"></p><ol start="4"><li><p>圆心累加器结果<br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305191704.jpg" alt="图片alt" title="图片title"></p></li><li><p>直线和圆形检测结果<br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305191705.jpg" alt="图片alt" title="图片title"></p></li></ol><h3 id="五、实验思考和感想"><a href="#五、实验思考和感想" class="headerlink" title="五、实验思考和感想"></a>五、实验思考和感想</h3><p>​</p><p>​通过本次实验，我更加深入地学习和体会了hough变换检测图形的算法，在实践的过程中，我发现了很多在学习过程中没有注意到的细节，都需要在实践进行调整。</p><p>​在实验初期，调整hough变换检测的阈值是一件非常困难的事情，不合适的阈值对检测结果的影响非常大，后期，我发现这个阈值由于是一个绝对值，而图像大小会导致不同的图像适合的阈值有非常大的差别，因此我将其中的highway图像大小进行了调整，使其与其他两张图像大小差别缩小，因此最后的实验结果中，不必人为调整阈值，就可以同时对三张图像进行检测。</p><p>​在实验中，我还发现，在进行直线检测时，由于hough变换时转换计算有误差，可能会导致变换后的线（对应原来的共线的点）不准确相交于一个点，而是在一个很小的范围内波动，因此我对算法进行了改进，在检测到累加器中的局部极大值后，在一个小范围区间内，对累加器的值做一个聚合，就会很大程度上避免这种情况，也能使得检验结果更加清晰准确。</p><p>​另外，由于highway图像较模糊，清晰度较低，因此两旁的数目对检测结果的影响非常大，这是因为树木范围中很多点都被识别成了边缘点，因此，对于这张图像，我增大了均值滤波的参数，成功降低了树木中的边缘点数目，也最终非常明显地改善了检测结果。</p><p>​在识别圆形时，我发现算法对于同心圆的检测效果不是那么优秀，我对算法进行了一定的改进，调整了宏定义的 “HOUGH_CIRCLE_RADIUS_MIN_DIST” 参数，使得计算半径时的半径区间范围稍微放大一些，从而使得半径的容错率更高，改善了半径计算不准确导致的无法识别出圆，将其舍弃的情况。但是该参数调整反馈非常敏感，稍微调整一点都会很明显地影响到检测结果（可能识别出一些不合适的结果，如下图），因此最后很遗憾地是还是没能识别出胶带最外圈的圆形，而只识别出了两圈（见上文图片）。但是经过对原图像和边缘图像的分析，我们也可以看出，出现这种结果的原因可能是因为：胶带内圈的两个圆太密集，从而使得算法可能检测出小圆的左半圈和右半圈为一个整圆，才会出现下图的结果。因此最后还是将该参数调回了原来的值。</p><p><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305191706.jpg" alt="图片alt" title="图片title"></p><p><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305191707.jpg" alt="图片alt" title="图片title"></p>]]></content>
      
      
      <categories>
          
          <category> Computer Vision </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Homework </tag>
            
            <tag> Computer Vision </tag>
            
            <tag> Hough Transformation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟现实课程报告 - 眼球追踪技术</title>
      <link href="/2023/05/18/EyeTracking/"/>
      <url>/2023/05/18/EyeTracking/</url>
      
        <content type="html"><![CDATA[<p>课程名称：虚拟现实与数字娱乐<br>报告名称：眼球跟踪技术<br>日期：2021 年 5 月 20 日</p><span id="more"></span><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>​眼球追踪是一项科学应用技术，主要是研究<strong>眼球运动信息的获取、建模和模拟</strong>。实现眼球追踪有三种方式：一是根据眼球和眼球周边的特征变化进行跟踪，二是根据虹膜角度变化进行跟踪，三是主动投射红外线等光束到虹膜来提取特征。获取眼球运动信息的设备可以是红外设备之外，也可以是图像采集设备，甚至可以是一般电脑或手机上的摄像头。</p><p>​目前的虚拟现实和增强现实<strong>交互方式</strong>仍然存在一些比较大的局限。3D手势操作很有前景，但手臂和肩膀很快就会感觉很累。疲惫的手臂会让人们的交互慢下来，并丢失追踪精度。声控适合于某些场景，但这种控制方式的响应速度很慢和不准确。头部运动现在正作为主要的控制方式，但不停地转动头部和倾斜脖子也会让人感到疲惫，并可能会造成脖子损伤。而眼球运动的精细肌肉则对疲劳免疫。并且眼动追踪技术的<strong>响应速度很快</strong>，对视线的追踪很<strong>准确</strong>。</p><p>​在VR领域中，对人眼位置的检测能够为当前所处视角提供<strong>最佳的3D效果</strong>，使VR头显呈现出的图像更自然、延迟更小。同时，由于眼球追踪技术可以获知人眼的真实注视点，从而得到<strong>虚拟物体上视点位置的景深</strong>。眼球追踪与头部转动协同控制视角变化，可让人摆脱不自然头部转动产生的画面晃动。因此，眼球追踪技术被大部分VR研究者认为，这是<strong>解决VR头显设备眩晕问题</strong>的突破之处。</p><p>​通过<strong>“注视点渲染技术”（Foveated Rendering）</strong>，眼动追踪技术可以节省设备的运算资源。在现实生活中，我们观看事物的时候，通常都是聚焦于某一个事物上，而边缘环境的分辨率则会大幅度降低。虚拟现实和增强现实系统可以通过对注视点的获取，只渲染焦点的全分辨率，对于其他边缘区域则以较低分辨率进行渲染，从而大幅度节省了运算资源。</p><p>​并且眼球追踪可以生成<strong>凝视数据</strong>，提供用户状态和眼动行为的信息。凝视数据可以用来准确地理解用户如何互动以及互动的原因，可以实现用户通过眼睛注视位置的移动和凝视时间来控制设备实现点击、滚动等功能（<strong>Gaze Interface</strong>）；也可以通过凝视数据分析用户的注意力集中点以及分析用户的兴趣点等（<strong>Gaze Analysis</strong>）。</p><h2 id="二、基本原理"><a href="#二、基本原理" class="headerlink" title="二、基本原理"></a>二、基本原理</h2><p>​人看向不同方向时，眼部会有细微的变化，这些<strong>变化</strong>会产生可以提取的<strong>特征</strong>，计算机可以通过图像捕捉或扫描等方式，提取这些特征，从而实时追踪眼睛的变化。</p><p>​</p><p>​人类的眼球结构决定了，单眼的实现方向可以通过<strong>眼球中心和瞳孔的连线</strong>来得到，而瞳孔的位置可以通过对虹膜识别和提取中心点得到。而同时得到两只眼睛的实现方向，就可以通过两线交点得到用户的注视点。</p><p>​对于VR中的注视点提取，还有一个关键的问题，如下图，用户的成像屏幕可能在离自己较近的地方，但由于VR中<strong>立体视觉</strong>的应用，用户真正的注视点可能并不在成像屏幕上，我们可以通过结合虚拟现实环境中虚拟物体的<strong>深度信息</strong>，构建一条虚拟线，可以从眼睛的方向追踪到虚拟世界中用户正在注释的物体上。</p><p><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305181642.jpg" alt="图片alt" title="图片title"></p><h2 id="三、应用领域"><a href="#三、应用领域" class="headerlink" title="三、应用领域"></a>三、应用领域</h2><p>​视线追踪技术在VR领域的应用方式有：</p><h4 id="1-图形渲染资源分配："><a href="#1-图形渲染资源分配：" class="headerlink" title="1. 图形渲染资源分配："></a>1. 图形渲染资源分配：</h4><p>​通过使用VR中的眼动跟踪信息，可以执行所谓的<strong>“中心凹形渲染”</strong>，即在用户注视的方向分配更多的图形渲染资源。这样可以使得给定的渲染功率可以提供更高质量的输出，降低所需的处理能力，还可以创建一个更加身临其境的环境，在其中虚拟世界可以更紧密地表示现实世界。同时，这样的渲染方式还可以在VR虚拟环境中实现景深效果，更贴近人眼在现实世界中的成像特点。</p><p><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305181643.jpg" alt="图片alt" title="图片title"></p><h4 id="2-数据预取："><a href="#2-数据预取：" class="headerlink" title="2. 数据预取："></a>2. 数据预取：</h4><p>​某些VR<strong>数据的读取和修改</strong>等操作需要一定的时间才能完成。如果用户在特定方向上扫视，那在用户选择要与之交互之前，数据读取可以在后台提前进行。</p><h4 id="3-多模式智能3D对象选择："><a href="#3-多模式智能3D对象选择：" class="headerlink" title="3. 多模式智能3D对象选择："></a>3. 多模式智能3D对象选择：</h4><p>​对于VR中的虚拟场景，用户很难在杂乱的环境中选定特定的小对象。通过把视线信息与控制器输入组合结合，可以一定程度上<strong>消除选择歧义</strong>，让用户更准确地选择对象。</p><h4 id="4-自动头显校准："><a href="#4-自动头显校准：" class="headerlink" title="4. 自动头显校准："></a>4. 自动头显校准：</h4><p>​获取用户眼睛注视位置，可以使得头显设备可以更好地调整自己的<strong>图像输出参数</strong>，以获得最佳的用户舒适度。</p><h4 id="5-平衡操作："><a href="#5-平衡操作：" class="headerlink" title="5. 平衡操作："></a>5. 平衡操作：</h4><p>​<strong>前庭眼反射</strong>是一种众所周知的自动反应，会把眼球运动与前庭系统的变化联系起来。获取眼睛运动和头显运动将可以对用户前庭系统的可能状态进行判断，可能可以实现在VR使用期间减少晕动症。</p><h2 id="四、具体算法"><a href="#四、具体算法" class="headerlink" title="四、具体算法"></a>四、具体算法</h2><h3 id="1-视线估计方法综述："><a href="#1-视线估计方法综述：" class="headerlink" title="1. 视线估计方法综述："></a>1. 视线估计方法综述：</h3><p>​视线估计系统是典型的机器视觉系统，即让机器通过图像或者视频数据，计算出使用者的视线方向。视线估计方法根据对人体的侵害性可以分为<strong>侵入式</strong>视线估计方法和<strong>非侵入式</strong>视线估计方法。</p><p>​侵入式视线估计方法包括机械记录法、电流记录法、电磁感应法和反射光记录法。这些方法大多具有<strong>较高的测量精度</strong>，但是由于在测试过程中与被测试者产生身体接触，而且设备复杂昂贵，作用距离短，因此<strong>降低了使用舒适性和应用范围</strong>。所以在实际应用领域中，这些方法逐渐被其更加舒适自然的非侵入视线估计方法所取代。</p><p>​非侵入式视线估计技术由于能够兼顾<strong>精度</strong>和<strong>舒适性</strong>，并且适合嵌入到产品中，具有广泛的应用前景和实用价值，因此是目前研究的主要方向。但是这种基于图像信息的视线估计方法的精度容易受到诸如图像分辨率、光照环境、使用者个体差异和头部运动等因素的影响。非侵入式视线估计方法通常使用摄像机或照相机记载眼部运动，包括：</p><p>​1. 基于角膜反射光斑方法</p><p>​2. 基于神经网络的映射函数方法</p><p>​3. 基于投影变换方法</p><p>​基于角膜反射光斑方法需要外加照明光源，由于角膜的凸型结构，当视线发生变化时，角膜对来自固定光源发出的光的反射光斑也是变化的。利用相机采集到的角膜上反射光斑的分布就能得到眼球运动信息，进而得到视线方向。这种方法精度较高，是目前比较常用视线测量方法之一。日本开发的眼控鼠标就是基于这种原理。这种方法的缺点是外加光源对测试者有一定的干扰性，视线估计精度也容易受到环境光线的影响。</p><p><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305181644.jpg" alt="图片alt" title="图片title"></p><p>​上图给出了基于神经网络的映射函数进行视线估计的神经网络结构，将眼睛区域图像作为神经网络的输入，并利用高斯编码处理输出单元得到视线方向估计。这种方法并不借助眼睛的生理解剖模型，而是利用整幅图像的信息构造与注视点之间的单一映射。但是这类方法不仅需要大量的训练样本，而且样本维数较大，因此网络训练时间较长。同时训练好的网络缺少一定的适应能力，外界条件稍有改变都会显著影响映射的结果，因此不具备良好的推广性。</p><p>​根据眼球结构和成像原理，人们提出了多种用于视线估计的3D模型。在Le Grand模型中，光轴定义为从瞳孔中心到角膜曲率中心的连线。在Wang的模型中，视线近似认为是眼球中心与虹膜中心连线。基于投影变换的视线估计方法只要根据二维图像信息求出视线在3D空间中的方向，再根据测试者和相机的相对位置，就可以得到视线在空间中的位置。但这类方法对头部和眼睛运动比较敏感，如果图像分辨率较低，则会极大的影响最终结果，同时这种方法涉及的模型较为复杂，计算量较大。</p><p>​上述方法中，精度较高的基于角膜反射光斑方法需要外加光源照射眼睛区域，存在一定的<strong>侵入性</strong>和<strong>伤害性</strong>，对测试距离和测试环境也有严格的<strong>限制</strong>；映射方法适合处理注视与否问题，但是作为视线估计方法<strong>精度较低</strong>，而且<strong>缺少适应能力</strong>，外界条件稍有改变都会显著影响映射的结果；基于投影变换方法涉及的<strong>模型较为复杂</strong>，<strong>计算量较大</strong>，而且要求图像具有较高的分辨率。</p><p>​我阅读的论文针对上述方法中的不足，提出了一种结合了投影变换和神经网络的视线方向估算方法。在<strong>无特殊光源和头部固定装置</strong>的条件下仅使用<strong>单相机</strong>作为采集设备。计算模拟结果表明该算法可以有效地提高人眼视线估计精度。</p><h3 id="2-视线估计流程："><a href="#2-视线估计流程：" class="headerlink" title="2. 视线估计流程："></a>2. 视线估计流程：</h3><p>​视线估计系统工作流程图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305181645.jpg" alt="图片alt" title="图片title"></p><p>​本次技术点分析，我针对以上的流程重点学习了<strong>虹膜定位</strong>和<strong>视线估计</strong>的原理和算法。</p><h3 id="4-虹膜定位"><a href="#4-虹膜定位" class="headerlink" title="4. 虹膜定位"></a>4. 虹膜定位</h3><p>​由于我们在进行视线分析时需要获取瞳孔位置，因此我们在进行人眼定位之后，需要进行虹膜的定位（虹膜中心既是瞳孔）。东方人的虹膜颜色大都为黑色或深褐色，灰度值较低，和皮肤、巩膜的灰度值差异较大，因此利用恰当的<strong>阈值</strong>二值化分割出虹膜区域是最直观简单的方法。<strong>二值化</strong>计算代价小、速度快，非常具有实用价值。从输入图像 $f$ 到输出图像 $f’$ 的二值变换可以表示为（其中 $T$ 是阈值）：</p><p><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305181646.jpg" alt="图片alt" title="图片title"></p><p>​</p><p>​选择<strong>恰当的阈值</strong>是图像分割和提取虹膜的关键，但是由于图像的噪声、环境光强的变化或其他一些因素，采用<strong>恒定的阈值</strong>对所有的图像进行去二值化处理是不合理的，对每幅图像找到一个<strong>全局自适应阈值</strong>分割虹膜区域比较合理。</p><p>​自适应阈值可以通过<strong>图像灰度的直方图</strong>找到。灰度直方图是灰度级的函数，它表示图像中具有每种灰度级的像素的个数，反映图像中每种灰度出现的频率。在得到图像直方图后，图像阈值由以下公式计算：<br>$$<br>\theta_e &#x3D; \frac{H}{3}　　　　　　　　<br>H &#x3D; \frac{\sum(gN_g)}{\sum N_g}<br>$$<br>​其中 $g$ 为像素灰度， $N_g$ 为图像中灰度为 $g$ 的像素个数， $\theta_e$ 为图像阈值。当某一个像素的灰度值低于 $\theta_e$ 时，则令该像素灰度为0，反之为1。然后利用形态学算子（比如闭操作），将虹膜区域中可能存在的空隙填满。</p><p>​二值化后的图像中虹膜区域的像素值都为0，将图像像素值<strong>沿纵向进行累加</strong>，以最小值对应的水平位置为中心，用边长为图像宽度的矩形窗口完成对虹膜的定位。</p><p><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305181647.jpg" alt="图片alt" title="图片title"></p><p>​在对虹膜进行定位之后，通常我们还需要对虹膜进行<strong>椭圆拟合</strong>，拟合时可以使用Hough变换。</p><p>​Hough变换是1962年由Paul Hough提出的用来检测直线的一种方法，其本质上是一种<strong>聚类方法</strong>，通过建立图像空间与参数空间的对应关系，将图像空间像素点转化到<strong>参数空间</strong>，图像空间中的同在一条曲线上的点对应参数空间相交于一点的多条曲线，通过在参数空间统计交点分布来确定图像空间曲线参数。</p><p>​在拟合参数过程中还使用到了<strong>RANSAC</strong>方法，RANSAC方法的核心思想是：先随机取出少量的点来构造一个解，然后验证这个解的可靠性，多次重复这个过程，选出最可靠的结果作为最终的拟合结果。这样做就可以从<strong>包含大量异常点的数据</strong>中得到较为可靠的模型参数。RANSAC的<strong>基本假设</strong>是：数据是由“<strong>内点</strong>’’、“<strong>外点</strong>’’和“<strong>噪声点</strong>’’组成，其中“内点”分布符合某种数学模型，而“外点”不符合这种数学模型，其余的可以视为“噪声点”。</p><p>​我阅读的论文中，基于改进的RANSAC方法的虹膜轮廓拟合算法步骤如下：</p><p>​（1）从虹膜的边缘图像中随机选择5个点，并验证是否每条边缘中至少有一个点被选中，如果不是，则重复步骤（1）。</p><p>​（2）用这5个点<strong>拟合</strong>出唯一的一个<strong>椭圆</strong>，如果不能拟合，则返回（1）。</p><p>​（3）计算<strong>所有数据点</strong>与（2）中拟合出的椭圆方程的<strong>距离</strong>，根据给定的阈值，距离大于阈值的<strong>划分</strong>为“外点”，反之为“内点”；</p><p>​（4）重复（1）—（3）k次，记录下所有满足下面两个条件的椭圆：</p><p>​（1）“内点”个数占所有数据个数的比重大于25％的椭圆对应的随机点组合</p><p>​（2）短半轴 $b$、长半轴 $a$ 和虹膜半径 $R$ 满足 $\alpha R&gt;a&gt;b&gt;\beta R$，$\alpha$ 和 $\beta$ 为自定义的合理阈值。</p><p>​（5）计算（4）中得到的所有椭圆方程对其内点的误差平方和，取误差平方和最小的椭圆所对应的<strong>内点</strong>作为<strong>数据点</strong>，用<strong>最小二乘法</strong>重新拟合椭圆作为最终结果。</p><h3 id="5-基于中心投影的视线估计"><a href="#5-基于中心投影的视线估计" class="headerlink" title="5. 基于中心投影的视线估计"></a>5. 基于中心投影的视线估计</h3><p>​人眼模型：</p><p><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305181648.jpg" alt="图片alt" title="图片title"></p><p>​眼球是一个复杂的天然光学器件。眼球的形状近似球形，眼球壁外层的前 1&#x2F;6 为角膜，其余 5&#x2F;6 为白色的巩膜。角膜是透明的，其折射率约为1.367，它是光束进入眼睛的门户。角膜后面的空间称为前房，其中充满折射率与水相近的水状液。前房之后有一中心带圆孔的彩色盘状膜，称为<strong>虹膜</strong>。<strong>虹膜的中心圆孔即为瞳孔</strong>。虹膜后面是晶状体，它的外形如双凸透镜，并附着在睫状肌上。睫状肌的伸缩能调节晶状体的曲率，以达到调节焦距的目的。晶状体后面的空间称为后房，后房充满一种胶性透明体，叫玻璃体。玻璃体的折射率约为1.336，其透明外膜与视网膜紧贴着。</p><p>​从几何光学的角度来看，眼睛是一个由多界面组成的复杂的<strong>共轴光学系统</strong>。瞳孔可以看作光圈，角膜、晶状体等可以看作透镜系统，眼底视网膜就是感光底片。进入眼睛的光线通过一系列界面的折射，最后成像于视网膜。与光学设备不同的是：光学设备通常是通过改变<strong>透镜之间距离</strong>来改变焦距，而眼睛是靠调节<strong>晶状体的弯曲程度</strong>来改变眼睛焦距。</p><p>​下文是 Wang J G 等人提出的眼球模型。该模型将眼球视为一个半径为 R 的<strong>标准球体</strong>，并可以围绕着其中心转动。虹膜位于球体的前端，其轮廓是一个半径为 r 的<strong>圆盘状椭球</strong>，眼球中心到虹膜所在平面的距离为 d 。基于这个模型，Wang 等人提出了<strong>单眼视线估计方法</strong>和<strong>双眼视线估计方法</strong>，其精度在非侵入视线估计方法中仅次于基于角膜反射光斑的方法。这两种方法的思想都是将视线估计问题转化为<strong>求解空间中具有圆形特征物体的姿态问题</strong>，通过虹膜在图像上的<strong>椭圆轮廓</strong>求出其在三维空间中所在平面，并将虹膜平面的<strong>法向量</strong>作为对视线方向的估计。在双眼视线估计问题中，Wang充分利用<strong>双眼视线交汇一点</strong>的眼动模式作为约束条件求出注视点的空间位置。在单眼视线估计中，由于缺少了这个约束条件，所以还必须知道<strong>屏幕距离测试者的距离</strong>，才能得到注视点的位置。</p><p><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305181649.jpg" alt="图片alt" title="图片title"></p><p>​Wang的方法虽然在理论上非常完美，但是实验效果却不是很理想。总的来说Wang的方法存在以下两个问题：</p><p>​第一，在计算过程中涉及到空间中锥方程求解以及解的可能性的讨论等问题，<strong>计算较为复杂繁琐</strong>；</p><p>​第二，方法的精度<strong>受到图像分辨率限制</strong>，如果不能保证得到足够多的虹膜边缘像素，视线估计精度会大大降低。</p><p>​因此我阅读的论文中针对上述问题提出了新的方法。</p><p>​当人眼正视前方时，虹膜的轮廓接近圆形，而当视线方向发生偏移的时候，虹膜轮廓的在相机中所成像的形状会发生形变，成为一个椭圆。该方法利用这一点，依据虹膜轮廓的<strong>畸变程度</strong>得到视线方向的初步估计。</p><p>​为了避免Wang方法中的复杂计算，我们将视线方向的<strong>立体角分解</strong>成两个角度：一个为人眼分别注视目标和注视相机时两个视线方向之间的夹角$\theta$；另一个为视线在图像平面的投影与像平面水平坐标轴之间的夹角$\gamma$。</p><p><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305181650.jpg" alt="图片alt" title="图片title"></p><p>​考虑任意一个过眼球中心和相机的平面，假设视线在这个平面上发生偏转（如下图），虹膜 $\overline {DJ}$ 在物平面的投影 $\overline {BC}$ 可以表示为：</p><p><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305181651.jpg" alt="图片alt" title="图片title"></p><p>​可以看出 $ \overline {BC}$ 同时也是物平面上虹膜轮廓拟合椭圆的短轴。虹膜中心在物平面上的偏移量可以表示为</p><p><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305181652.jpg" alt="图片alt" title="图片title"></p><p>​其中 $R$ 为眼球半径，$r$ 为虹膜半径， $l$ 为物距，$R$、$r$ 和 $\alpha$ 之间关系满足 $sin \alpha &#x3D; r&#x2F;R$ ，通常把 $r&#x2F;R$ 的值看作一个固定的解剖结构常量，约为0.4。</p><p>​第二个角度 $\gamma$ ，可以从像平面上的虹膜轮廓拟合的<strong>椭圆方程</strong>得到。当视线方向发生偏转时，虹膜轮廓拟合椭圆的短轴就是视线在像平面上的投影，因此第二个角度 $\gamma$ 就是椭圆短轴与图像坐标系中水平轴的夹角。</p><p><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305181653.jpg" alt="图片alt" title="图片title"></p><p>​从上图可以发现，当第一个角度 $\theta$ 确定，而第二个角度 $\gamma$ 相差 $\pi$ 时，虹膜的畸变程度是一样的，无法给出正确的注视方向，因此还需要借助其他信息处理这个<strong>歧义问题</strong>。Wang在2001的文章中提出一种基于眼角点位置的判断方法，其原理是：假设眼球中心不改变，并认为视线方向是由眼球中心指向虹膜中心，因此不管视线如何改变，从眼球中心到两个眼角的距离应该是近似相等的。这样就可以唯一确定眼球中心，从而确定视线方向。</p><p><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305181654.jpg" alt="图片alt" title="图片title"></p><p>​在我阅读的论文中，作者通过对大量实验数据的统计，发现当视线发生偏转时，虹膜中心位移要大于瞳孔中心位移，但事实上，瞳孔就是虹膜中心的圆孔。产生这一现象的原因是由于眼球特殊的结构，在角膜与虹膜之间有一个充满无色液体的空腔结构叫做<strong>前房</strong>，虹膜就紧贴在前房的后面。前房的形状是中间厚，两边薄，可以将其看作是一个<strong>凸透镜</strong>。因此我们看到的虹膜实际上是虹膜的<strong>虚像</strong>，并且由于像场弯曲，使得瞳孔的虚像位于虹膜虚像的后方。因此当视线发生转动时，<strong>虹膜中心位移要大于瞳孔中心位移</strong>。<br>​依据这个规律，作者提出一种从两个可能解中找出真实解的方法。由虹膜中心和瞳孔中心的坐标可以得到向量 $\overline {O_{pupil} O_{iris} }$ ，将这个向量与两个可能的视线方向向量 $\overline {v(\gamma)}$做内积，y的真实解应满足条件 $&lt;\overline{v(\gamma)}，\overline{O_{pupil} O_{iris}}&gt;0$。并且通过作者的实验结果分析，对于视线角(相对于注视相机)在5°​以上的情况，这种方法可以完全正确的找出正确解；对于视线角(相对于注视相机)在5°以下的情况，这种方法准确度在92％左右。</p><p><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305181655.jpg" alt="图片alt" title="图片title"></p><h2 id="五、应用中的细节设计问题"><a href="#五、应用中的细节设计问题" class="headerlink" title="五、应用中的细节设计问题"></a>五、应用中的细节设计问题</h2><h3 id="1-碰撞检测的范围"><a href="#1-碰撞检测的范围" class="headerlink" title="1. 碰撞检测的范围"></a>1. 碰撞检测的范围</h3><p>​基于目前眼球追踪技术，无法做到100%准确识别出注视物体，会存在一定的<strong>误差</strong>。因此视线与物体进行碰撞检测时，不应该将视线视为一个无限细的射线进行检测，一般需要设置一定的<strong>扩展范围</strong>，最好是将视线设置为一个圆锥形。</p><p><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305181656.jpg" alt="图片alt" title="图片title"></p><h3 id="2-碰撞检测并不等同于注视"><a href="#2-碰撞检测并不等同于注视" class="headerlink" title="2. 碰撞检测并不等同于注视"></a>2. 碰撞检测并不等同于注视</h3><p>​<strong>人眼有两种常见的运动模式：</strong>眼跳和注视。<strong>检测到视线物体的碰撞和用户在注视这个物体并不是等同的。</strong></p><p>​眼跳的速度非常快，这时检测到视线和物体的碰撞，产生交互是没有必要的。视线落在某个物体上超过一定的时间才是注视，因此在交互设计中，一般需要通过一定的<strong>延迟判定</strong>才能认为是注视。</p><p><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305181657.jpg" alt="图片alt" title="图片title"></p><h3 id="3-避免米达斯接触"><a href="#3-避免米达斯接触" class="headerlink" title="3. 避免米达斯接触"></a>3. 避免米达斯接触</h3><p>​在眼球追踪技术应用中，还有一个问题：<strong>米达斯接触</strong>问题。</p><p>​所谓米达斯接触（Midas Touch）问题（米达斯是希腊神话中的一位能点石成金的国王）指的是由于用户视线运动的随意性而造成计算机对<strong>用户意图识别</strong>的困难。用户有时只是单纯地观察一个物体，而不希望引发该物体对应的功能。</p><p>​为了解决这个问题，一般不会采用注视后马上触发功能的方式，而是使用以下两种方式：</p><p>​<strong>1. 延迟触发：</strong>在被观察物体上，显示一个不影响正常浏览的时间进度条，当进度条完成设定时间的计时时，产生触发行为。</p><p>​<strong>2. 二次眼控触发：</strong>在被观察物体旁边，显示“真正的”触发元素，用户余光可以看到，但不影响观察主体。当需要触发时，看那个“真正的”触发元素即可。</p><h3 id="4-与其他输入工具结合"><a href="#4-与其他输入工具结合" class="headerlink" title="4. 与其他输入工具结合"></a>4. 与其他输入工具结合</h3><p>​在VR应用中，只用眼睛进行所有交互并不是最好的交互模式，结合其他输入工具，如手柄、语音、手势等进行<strong>多重交互</strong>，才是比较自然的。</p><p>​比如在一个菜单界面上，眼睛的运动轨迹能够反应在菜单项中，使选项处于待激活状态，此状态下不触发场景切换或其他功能，然后配合语音交互或者特定手势交互，才触发功能，这种多重交互协作方式将会有效得避免误触。</p><h4 id="References："><a href="#References：" class="headerlink" title="References："></a>References：</h4><p>［1］ 张雯.人眼注视方向识别的数字图像处理技术研究[D]. 博士, 南开大学, 2011. [学位论文]</p><p><span name = "ref1">［2］ Rachel Albert, Anjul Patney, David Luebke, and Joohwan Kim. 2017. Latency Requirements for Foveated Rendering in Virtual<br>Reality. ACM Trans. Appl. Percept. 14, 4, Article 25 (September 2017), 13 pages.</span></p><p><span name = "ref1">［3］ Linus Franke,1 Laura Fink,1 Jana Martschinke,1 Kai Selgrad2 and Marc Stamminger1[Lq1] .Time-Warped Foveated Rendering for Virtual Reality Headsets［J］.COMPUTER GRAPHICS forum, 2021,Volume 40 :110-123. [期刊] </span></p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphics </category>
          
          <category> Virtual Reality </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Homework </tag>
            
            <tag> EyeTracking </tag>
            
            <tag> Virtual Reality </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>研究生计算机图形学HW - 不同ZBuffer 算法的实现和效率比较</title>
      <link href="/2023/05/16/ZBuffer-Report/"/>
      <url>/2023/05/16/ZBuffer-Report/</url>
      
        <content type="html"><![CDATA[<p>课程名称：计算机图形学（研究生）<br>报告主题：不同ZBuffer 算法的实现和效率比较<br>提交日期：2023 年 1 月 11 日 </p><span id="more"></span><div class="tag link"><a class="link-card" title="code" href="https://github.com/YaelCassini/Z-Buffer"><div class="left"><img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/256/safari.png"/></div><div class="right"><p class="text">code</p><p class="url">https://github.com/YaelCassini/Z-Buffer</p></div></a></div><div class="tag link"><a class="link-card" title="report" href="https://yaelcassini.github.io/2023/05/16/ZBuffer-Report/"><div class="left"><img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/256/safari.png"/></div><div class="right"><p class="text">report</p><p class="url">https://yaelcassini.github.io/2023/05/16/ZBuffer-Report/</p></div></a></div><h2 id="一、-实现功能及运行说明"><a href="#一、-实现功能及运行说明" class="headerlink" title="一、 实现功能及运行说明"></a>一、 实现功能及运行说明</h2><p>因为我个人想借这个项目的机会进行一些底层类的实现，为之后的希望能完成的图形引擎开发工作打一下基础，所以本项目没有依赖除了 C++标准库之外的其他库，一些基础的功能由自己个性化实现，比如说向量 Vector 的管理和计算<br>（可以管理坐标、颜色、法向等信息），Obj 格式的 Mesh 读入，便于本项目展示的简单的坐标变换（有参考网络上项目的思路），四叉树以及八叉树的建立和管理等。</p><h3 id="（一）主要算法实现了以下几种-ZBuffer："><a href="#（一）主要算法实现了以下几种-ZBuffer：" class="headerlink" title="（一）主要算法实现了以下几种 ZBuffer："></a>（一）主要算法实现了以下几种 ZBuffer：</h3><ol><li>普通的Zbufer 算法（Naive ZBuffer）</li><li>扫描线Zbuffer 算法（ScanLine ZBuffer）</li><li>简单版本的层次ZBuffer 算法（Naive ZBuffer + Hierarchical ZBuffer）</li><li>完整版本的层次 Zbuffer 算法（Naive ZBuffer + Hierarchical ZBuffer + Octree Scene）</li></ol><h3 id="（二）为了支持效果自己完成的一些功能"><a href="#（二）为了支持效果自己完成的一些功能" class="headerlink" title="（二）为了支持效果自己完成的一些功能"></a>（二）为了支持效果自己完成的一些功能</h3><ol><li>读入OBJ 格式的 Mesh 文件，且同时支持三角形和四边形面片的读入，并且支持不同格式的 OBJ 文件，比如只包含坐标、包含坐标和纹理坐标和法向等。</li><li>为了方便展示不同尺度的模型，实现一个基于窗口大小进行的简单的坐标变换，保证任何 Mesh 都能完整展示在窗口中。</li><li>简单的模型着色功能，支持基于点光源的 Diffuse 和随机面片颜色两种着色方式。</li><li>实现了四叉树和八叉树的建立和管理，分别用于 Hierarchical 的 ZBuffer和场景面片的管理。</li><li>简单的向量管理类，支持不同的向量计算。</li><li>受渲染管线中Fragment Shader 的启发，建立了面向对象的场景面片管理， 包含面片的坐标、Z 值、颜色等信息。</li><li>在自己思考下加入了ZBuffer 遍历中的提前剪枝。</li></ol><h2 id="二、-开发与运行环境"><a href="#二、-开发与运行环境" class="headerlink" title="二、 开发与运行环境"></a>二、 开发与运行环境</h2><p>操作系统：Microsoft Windows 10 Pro64bit CPU：Intel(R) i5-12400F2.50 GHz<br>内存：DDR48G<br>IDE：Microsoft Visual Studio2022<br>配置平台：ReleaseX64<br>正常运行效果效果演示：<br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305161756.jpg" alt="图片alt" title="图片title"></p><h2 id="三、-项目架构及数据面向对象管理"><a href="#三、-项目架构及数据面向对象管理" class="headerlink" title="三、 项目架构及数据面向对象管理"></a>三、 项目架构及数据面向对象管理</h2><p>本实验使用 C++面向对象式地进行开发，为了更形象地展示，其中项目各个类之间的依赖关系和组织架构我画了一张图来展示：<br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305161757.jpg" alt="图片alt" title="图片title"><br>得益于面向对象的管理，main 函数的结构非常清晰：<br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305161758.jpg" alt="图片alt" title="图片title"><br>其中各个类实现的功能基本都可以从类名称清晰的看出，源代码的类定义中也有相关注释，在此就不再赘述，需要解释的一点是：我使用了一个 Fragment 类来管理光栅化之后的单个面片，这个面片与 Model 中的 Face 的区别是，Face 包含的是点坐标、法向等信息的索引值，而 Fragment 类中则直接记录的是面片的顶点坐标，并且是光栅化之后的像素坐标，该类同时还支持根据重心坐标对深度值进行插值，从而得到某一个具体像素处的深度值。<br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305161759.jpg" alt="图片alt" title="图片title"></p><h2 id="四、-实验步骤细节及问题解决"><a href="#四、-实验步骤细节及问题解决" class="headerlink" title="四、 实验步骤细节及问题解决"></a>四、 实验步骤细节及问题解决</h2><p>具体的程序实现细节过于复杂，我不会在此一一赘述，但是在这个部分我会把其中几个我认为有价值的点拿出来简单展示一下。</p><h3 id="1-八叉树和层次-ZBuffer-的对应问题"><a href="#1-八叉树和层次-ZBuffer-的对应问题" class="headerlink" title="1. 八叉树和层次 ZBuffer 的对应问题"></a>1. 八叉树和层次 ZBuffer 的对应问题</h3><p>在实现完整版本的层次 ZBuffer 时，需要同时管理场景面片的八叉树，和ZBuffer 的四叉树两个数据结构，并且需要遍历八叉树，使用层次 ZBuffer 进行深度测试，在这里的实现细节时，需要将八叉树的遍历和层次 ZBuffer 的遍历同步进行，为了实现这种遍历，在构建八叉树的时候，我用的是下面这种顺序：<br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305161800.jpg" alt="图片alt" title="图片title"><br>从 Z 轴来看，前面四个子节点索引分别是 0，2，4，6，后面的子节点则是 1， 3，5，7。这样，在遍历的时候，如果需要进入到下一层子节点，就只需要从 0-7 遍历，而层次ZBuffer 对应的子节点下表只需要用八叉树下标&#x2F;2 做寻址即可。<br>另外一个细节是，在简单模式下的 ZBuffer，如果只有左右两个像素需要剖分，就只会增加两个子节点，而不是严格意义上的四叉树，这样会减小遍历的压力，但在完整版本下，为了保证和八叉树的同步，我把层次ZBuffer 做成了严格的四叉树，没有子节点的地方使用空指针 NULL 占位。<br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305161801.jpg" alt="图片alt" title="图片title"><br>上图的情况是由于八叉树的子节点索引和层次 ZBuffer 的子节点索引没有在空间上对齐，导致遍历的时候出现整个子节点的面片都通不过深度测试（其实是因为xy 坐标不在范围内被深度测试强行拒绝）。</p><h3 id="2-层次-ZBuffer-绘制单个面片时的提前剪枝"><a href="#2-层次-ZBuffer-绘制单个面片时的提前剪枝" class="headerlink" title="2. 层次 ZBuffer 绘制单个面片时的提前剪枝"></a>2. 层次 ZBuffer 绘制单个面片时的提前剪枝</h3><p>在寻找到层次 ZBuffer 无法拒绝，但是子节点又无法完全包裹面片时，就需要对面片进行绘制，如下图。但是我实现时发现这样非常非常耗时，具体的时间对比在下一部分。因此我加入了一种剪枝方式。层次ZBuffer 结构本身包含的剪枝是如果面片没有通过较大块的深度测试，就直接剪枝这块 Buffer，但是在绘制时，同样需要剪枝。如下图，由于这个面片跨越四个子节点，因此这四个节点都需要对该面片进行绘制，但是再向下一层，就有一些 Buffer 块不包含面片了，我在此时对这些Buffer 块进行剪枝，程序运行的速度大大加快。<br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305161802.jpg" alt="图片alt" title="图片title"><br>具体实现代码：<br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305161803.jpg" alt="图片alt" title="图片title"></p><h3 id="3-ScanLine-的边界控制问题"><a href="#3-ScanLine-的边界控制问题" class="headerlink" title="3. ScanLine 的边界控制问题"></a>3. ScanLine 的边界控制问题</h3><p>因为 ScanLine 在切换下一条扫描线的时候需要使用提前计算好的 dx、dy、dzx、dzy 等递增量进行数据的递增，因此非常受到数据精度的影响，需要使用float 类型储存数据，但是由于光栅化为单个像素，又必须有 dy 等 int 类型的变量，在计算 dy 时，我一开始采用的是 round 函数进行绘制，但是这样可能会导致由于递增量的误差，在最后一条线绘制的时候，左边的 x 值已经超过了右边的x 值导致绘制错误，但是使用 ceil-floor 的方式又可能会在边界处绘制超过的像素部分，因此我最后对上界和下界都使用了floor 取整。<br>在实践中由于数据精度问题还导致下面这种绘制错误的产生：<br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305161804.jpg" alt="图片alt" title="图片title"><br>这个问题的出现是由于在计算 dx 时，为了保证精度，我首先使用了下图中上面那种方式计算，这样会导致对于某些几乎平行于 x 轴，但是又没有被浮点判断消除掉的线，计算出的 dx 值会非常大，这就导致递增计算时出现很大的误差， 最终我改为了下图中下面那种计算方法。<br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305161805.jpg" alt="图片alt" title="图片title"><br>另外，ScanLine 算法中的边界控制这部分我认为说起来容易但是最容易出错，在实践中也耗费了我很多时间。比如，在判断活化边的结束条件部分我也出现了一些问题，一开始我担心如果用 dy&lt;0 来作为删除活化边的条件，会有一些情况整个三角形太小只占了一个元素，但是思考后认为应该用 dy&lt;0，因为只占一个元素的情况应该初始 dy&#x3D;0。而当活化边一边 dy&#x3D;0 的时候，就应该去对应的活化多边形中寻找下一条边替代并更新活化边的 dxl 和 dxr 了，这样才能保证活化边不被删除且下一次绘制时已经使用了新的递增量。</p><h2 id="五、-实验结果与效率对比分析"><a href="#五、-实验结果与效率对比分析" class="headerlink" title="五、 实验结果与效率对比分析"></a>五、 实验结果与效率对比分析</h2><h3 id="（一）实验结果展示"><a href="#（一）实验结果展示" class="headerlink" title="（一）实验结果展示"></a>（一）实验结果展示</h3><p>在不同着色模型下不同模型的绘制结果展示：<br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305161806.jpg" alt="图片alt" title="图片title"><br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305161807.jpg" alt="图片alt" title="图片title"><br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305161808.jpg" alt="图片alt" title="图片title"><br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305161809.jpg" alt="图片alt" title="图片title"><br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305161810.jpg" alt="图片alt" title="图片title"><br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305161811.jpg" alt="图片alt" title="图片title"><br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305161812.jpg" alt="图片alt" title="图片title"></p><h3 id="（二）算法效率对比分析"><a href="#（二）算法效率对比分析" class="headerlink" title="（二）算法效率对比分析"></a>（二）算法效率对比分析</h3><p>在 800*600 的分辨率下，分别进行了不同面片数的 Mesh 绘制，并记录下不同算法的耗时（ms）：（为了方便比较这里把所有面片都预先转化成三角形模式，但是四边形也可以绘制）<br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305161813.jpg" alt="图片alt" title="图片title"></p><p>而在 1600*1200 的分辨率下：<br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305161814.jpg" alt="图片alt" title="图片title"></p><p>可以看出相比于ScanLine Zbuffer 算法，层次 ZBuffer 在面片较少时是没有太多优势的，但是在面片数逐渐增加时，其优势就逐渐体现出来了，并且，面片越多，完整的层次ZBuffer 相较于没有Octree 的简单版本优势越大。另外，没有额外剪枝的Hierarchical ZBuffer 算法速度非常慢，此处的ZBuffer 不是指的是在遍历过程中，由于面片被较大的ZBuffer 块深度测试拒绝而导致的剪枝，而是在上一部分提出的，遍历时根据 Zbuffer 覆盖范围和面片覆盖范围比较而进行的剪枝。</p><p>另外，在实验中，我发现层次ZBuffer 对于普通的Naïve ZBuffer 加速比效果不太理想，即使我同时绘制了五个模型也没有很好的加速效果，我推测可能是由于目前的场景还是不够复杂，没有很多那种被大范围遮挡的情况，而此时不需要遍历复杂的数据结构的Naïve ZBuffer 就稍占据了一些优势。</p><h2 id="六、-总结与改进方向"><a href="#六、-总结与改进方向" class="headerlink" title="六、 总结与改进方向"></a>六、 总结与改进方向</h2><p>通过本次实验，我对几种基础的 ZBuffer 算法都有了更深入的理解，“纸上得来终觉浅，绝知此事要躬行”。亲自上手编程实现算法和仅仅通过眼睛学习效果是完全不同的，在这次实践中，我也发现自己对于一些编程上的技巧，数据结构的组织等仍有进步的空间，需要继续努力。我也深刻地意识到面向对象的编程的优势，将需要实现的功能拆分成不同模块，能大大提高编程和Debug 的效率。<br>在具体实践的时候，ScanLine 耗费了我最多的时间和经历，主要因为这个算法个性化的程度比较高，相比于层次ZBuffer 本质上是利用到八叉树和四叉树， 结构比较清晰，ScanLine 算法则需要花费很多精力在控制边界调节、控制浮点数精度等细节上面。另外从我的实验结果来看，ScanLine 算法由于是用递增量去控制的，无论如何都会存在误差的累计，绘制的效果在某些情况下不太理想。<br>但同时我也发现了很多程序中存在的问题，有一些已经解决了，在上文中也已经说明，但我认为还有一些可以改进的方向，只是由于事件原因没能实践。比如说，可以考虑使用 GPU 硬件加速八叉树和四叉树的结构，比如并行计算同一个八叉树的不同子节点，这样应该会大大加快程序访问八叉树的速度。<br>另外，使用层次Zbuffer 绘制面片时，如果某个层次Zbuffer 不能拒绝面片， 但是单个子节点又都不能包含整个面片，那就只能从这个节点开始逐级向下绘制这个面片，但是这样可能会导致拒绝较大面片的效率不高，我认为后续可以进行改进的方法是对面片进行切割，因为这个阶段使用到的面片都是已经光栅化之后的屏幕空间的面片了，再进行平行于 xy 轴的面片切割应该不难实现，切割后就可以用切割的面片分别与子节点进行深度测试了。</p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphics </category>
          
          <category> Rendering </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Homework </tag>
            
            <tag> ZBuffer </tag>
            
            <tag> ScanLine ZBuffer </tag>
            
            <tag> Octree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>研究生计算机图形学HW - 图形处理器(GPU)的历史、现状和展望</title>
      <link href="/2023/05/16/GPU-Development-History/"/>
      <url>/2023/05/16/GPU-Development-History/</url>
      
        <content type="html"><![CDATA[<p>课程名称：计算机图形学（研究生）<br>报告主题：图形处理器(GPU)的历史、现状和展望<br>提交日期：2023 年 1 月 1 日</p><span id="more"></span><h2 id="零、前言"><a href="#零、前言" class="headerlink" title="零、前言"></a>零、前言</h2><p>首先，我的报告选择 GPU 发展历史该选题的原因是：在平时的学习研究中发现自己的硬件知识其实非常薄弱，几乎没有相关的硬件原理了解。虽然今后并不打算从事硬件相关的工作，但我认为“纸上得来终觉浅”——软件终究必须依靠当前的硬件工具进行运行，没有硬件知识终究会导致我的思路有很大的局限性，很多时候无法开发出效果更好、性能更高的系统、软件或者算法。因此我希望借此机会，通过查阅资料和自己的思考，使自己能对硬件知识、GPU 基础构架有一个广泛的了解。同时，GPU 的硬件设计制作发展和计算机图形学的发展也是相辅相成，无法分割的，因此本文也会带到一些图形学的发展历史，这样也算是在发展脉络上把两者结合了起来，我相信也能对自己有所帮助。 </p><h2 id="一、GPU-发展历史"><a href="#一、GPU-发展历史" class="headerlink" title="一、GPU 发展历史"></a>一、GPU 发展历史</h2><h3 id="（1）-GPU-简介"><a href="#（1）-GPU-简介" class="headerlink" title="（1） GPU 简介"></a>（1） GPU 简介</h3><p>GPU 全称是 Graphics Processing Unit，中文名称是图形处理器。又被称为显示核心、显卡、视觉处理器、显示芯片或绘图芯片，是一种微处理器，专门用于在 PC、工作站、游戏机和一些移动设备（如平板电脑、智能手机等）上运行绘图运算工作。其最初发明时仅仅是为了处理图形计算工作，减轻 CPU 的负担，后来著名的科技公司 Nvidia 最早看到其在通用计算中的巨大潜力，推出了 CUDA 平台，使得 GPU 在具备强大的图形计算能力的同时，成为当前的人工智能、深度学习等热点研究领域不可或缺的硬件支持。<br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305161700.jpg" alt="图片alt" title="图片title"></p><p>我们目前市面上比较常见的 Geforce GTX20、30、40 系列显卡，本质上都是以 GPU 为核<br>心的，其包括一块 GPU 核心芯片，一块 PCB 主板，以及其他集成在板上的显存、金手指、供电系统和散热等模块。如下图所示。<br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305161701.jpg" alt="图片alt" title="图片title"></p><h3 id="（2）-图形学的奠基"><a href="#（2）-图形学的奠基" class="headerlink" title="（2） 图形学的奠基"></a>（2） 图形学的奠基</h3><p>1962 年麻省理工学院(MIT)的博士 Ivan E. Sutherland 发表的论文《SKETPAD: A MAN- MACHINE GRAPHICAL COMMUNICATION SYSTEM》以及他的画板程序演示为计算机图形学奠定了根基，这篇论文中首次使用了计算机图形学“Computer Graphics”这个术语，其也因此被称为计算机图形学之父。下图是该论文的一些绘制结果。<br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305161702.jpg" alt="图片alt" title="图片title"></p><p>此后近 20 年的时间里，计算机图形学不断有新的发展，完成了基础研究的部分。60 年代早期 MIT 的教授 Steven A. Coons 提出了通过插值四条任意的边界曲线来构造曲面，法国雷诺汽车公司的工程师 Pierre Bézier 也在 60 年代发明了 Bézier 曲线、曲面的理论。<br>上世纪 70 年代，区域填充、裁剪、消隐这些基础的图形学概念被先后提出，真实感图形学和实体造型技术也随之产生，不同的光照模型比如简单光照模型 Phong 模型也已经诞生。同时，图形学的标准制定也有标志性的进展， ACM 专门成立了图形标准化委员会，并先后于 1977、1979 年制定和修改了“核心图形系统”（Core Graphics System）。ISO 随后又发布了 CGI(Computer Graphis Interface，计算机图形接口)、CGM（Computer Graphics Metafile，计算机图形元文件标准）、GKS(Graphics Kernel system，计算机图形核心系统)、PHIGS（Programmer’s Hierarchical Interactive Graphics Standard，面向程序员的层次交互图形标准）等。<br>而在上世纪 80 年代，Whitted 提出了光线追踪算法，美国 Cornell 大学和日本广岛大学的学者引入了热辐射工程中的辐射度方法，标志着真实感图形的显示算法已逐渐成熟。 </p><p>但是在图形学研究过程的最初 20 年中，计算机却没有配备专门的图形处理芯片，图形处理任务都是 CPU 来完成的。硬件的性能不足，在一定程度上也限制了图形学技术的实际落地。在 80 年代，专门的图形处理硬件终于开始逐渐出现和发展。 </p><h3 id="（3）-GPU-与显卡的发展（产品脉络）"><a href="#（3）-GPU-与显卡的发展（产品脉络）" class="headerlink" title="（3） GPU 与显卡的发展（产品脉络）"></a>（3） GPU 与显卡的发展（产品脉络）</h3><p>GPU 的发展史伴随着各种不同领域的科技公司的竞争和发展，比如半导体科技公司、硬件生产公司、软件开发公司、互联网公司等等，这些公司或许在发展的过程中都或多或少地参与过 GPU 的发展，因此下面将首先从各个不同的公司发布的产品来展示 GPU 的发展史。<br>（但是由于篇幅限制，本篇读书报告中将会省略一些没有那么标志性的产品。） </p><h4 id="早期显卡概念及发展"><a href="#早期显卡概念及发展" class="headerlink" title="早期显卡概念及发展"></a>早期显卡概念及发展</h4><p>1981 年，当时还没有显卡的概念，相应的名称叫做适配器或者寻址器。IBM 公司（国际商业机器股份有限公司）发布了首款黑白图形适配器（MDA），其物理外观如下图所示。其没有像素寻址的图形模式，而只具有单色的文本显示模式。只能显示 80 列 25 行的文本字符或者符号，用于绘制图表。<br>同年，IBM 发布彩色图形适配器（CGA）具有 16kb 视频内存，能在 80<em>25 或 40</em>25 分辨率下支持 16 种颜色输出，或者在 320<em>200 分辨率下支持 4 种颜色输出。同时 IBM 发布的这两种图形适配器可以被安装在同一台电脑上，当时的操作系统 DOS 中包含的命令是用户可以在 CGA 和 MDA 之间切换显示。<br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305161703.jpg" alt="图片alt" title="图片title"><br>1982 年，NEC(日本电气股份有限公司)发布了全球首款图形集成控制芯片 𝜇PD7220，该芯片可以绘制弧形、线条、圆形等图形基础元素，拥有高达 4Mbit 的图形内存，支持1024</em>1024 的分辨率和四种颜色输出，并且建立了易于使用的低级指令集，使得应用程序的开发者可以通过嵌入这些指令到程序里实现个性化的操作。 </p><p>1985 年，著名的 ATI 公司成立，该公司也是当前市面上流行的 A 卡的初创者，同年该公司发布了第一款产品 ATI Graphics Solution Rev.1，如下图所示。1987 年 ATI 发布了ATI EGA Wonder 系列显卡，配备 256K 显存，采用 8 位 ISA 插槽。1990 年 ATI 推出升级款产品 ATI VGA Wonder+，采用全新的 28800-2&#x2F;4&#x2F;5 主芯片，该芯片当时采用的晶体管制造工艺为 800nm。1988 年，ATI 大力推广 ATI VGA Wonder 系列显卡，该系列显卡采用了后面一度被广泛使用的图形输出接口——VGA 接口，支持 1024*768 以上的分辨率，色彩支持达到 1600 多万色，就是我们常说的 24 位真彩色。<br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305161704.jpg" alt="图片alt" title="图片title"></p><p>1990 年，Trident 9685 发布，能采用软件模拟来实现 DCI 和 DirectDraw 软 3D 加速，<br>标志着显卡步入 3D 时代，随后发布的 Trident 9750&#x2F;9850 两款芯片则可以支持硬件 3D 加速。在 90 年代初期，功能比较均衡的 Trident 8900&#x2F;9000 系列（16-bit ISA）为当时绝对的主流卡。 </p><p>在 90 年代初期，1991 年 ATI 发布 ATI Graphics Ultra 系列显卡，此时微软的 Windows 操作系统已经炙手可热，因此该系列显卡也是面向 Windows 系统推出的。该显卡配备 2D 显示处理核心和 Mach8 协处理器，主要作用是分担 CPU 对图形处理的工作。1994 年 相继推出了 Mach 32 、Mach 64 和 Mach 64-VT，支持 32 位色彩和 VESA 标准，Mach64 更是加入了视频加速、 YUV&#x2F;RGB 颜色转换和硬件缩放等功能，使得电脑 AVI 和 MPEG 视频不再需要 CPU 加速。但以上这些 GPU 主要还是面对 2D 图形处理的。 </p><p>在 80 年代到 90 年代初期的这段时间里，GPU 的研发和设计基本处于一个群雄逐鹿的态势。除了上面提到的之外，还有很多公司参与过 GPU 的发展，比如 SGI（Silicon Graphics， 美国硅图公司）推出的高端图形工作站、苹果推出的具有图形化操作界面的个人电脑、TI（德州仪器，一家全球化半导体设计与制造企业）推出的 CPU 和 GPU 结合的完整 32 位处理器， Inter 的图形协处理器等。 </p><h4 id="VooDoo-开启的个人电脑时代的显卡发展"><a href="#VooDoo-开启的个人电脑时代的显卡发展" class="headerlink" title="VooDoo 开启的个人电脑时代的显卡发展"></a>VooDoo 开启的个人电脑时代的显卡发展</h4><p>但前期的很多显卡设备并没有在个人电脑上得到很好的推广，直到 1994 年 3Dfx 公司创立，并于 1995 年推出了他们的第一款显卡 3Dfx VooDoo（国内音译为巫毒），这是第一款真正意义上的消费级 3D 显卡，他将个人电脑真正意义上地带入了 3D 世界，也是一个极具标志性的时间节点。 </p><p>1993 年，黄仁勋联合自己的技术伙伴一起成立了后来的显卡巨头 Nvidia。1995 年， Nvidia 推出了首款以 NV1 图形芯片为核心的多媒体解决方案。但是他们试图抛弃三角形绘制改用四边形绘制，并不兼容当时主流的图形绘制库 OpenGL 和 Direct3D（直到现在仍然是主流的图形绘制解决方案）。这使得他们的方案不被市场所接纳，几乎无人问津。<br>但 Nvidia 很快做出了调整，1997 年，Nvidia RIVA 128 诞生，从此 Nvidia 放弃了自己的 API 接口，转而支持微软的 Direct3D 技术。RIVA 128 拥有 128 位内存总线，像素填充速率达到 100Mpixel&#x2F;s，并且性能已经强于 VooDoo。<br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305161705.jpg" alt="图片alt" title="图片title"><br>而在几乎同期的 1996 年，ATI 推出了他们第一款 3D 图形处理器 ATI 3D Rage 系列， 该卡性能一般且兼容性较差，但紧接着推出的 3D Rage Ⅱ 就解决了兼容性问题，并提供了两倍的 3D 性能。 </p><p>之后，3Dfx 于 1998 年推出 VooDoo2，增加了一个纹理处理单元，允许一次处理两个纹理，并推出了著名的 SLI 技术（Scalable Link Interface），可以并联两块 VooDoo2 使用，但其本质上是 3D 子卡，需要配合 2D 卡使用。该技术在之后 3Dfx 被 Nvidia 收购后仍被迭代使用过。<br>1999 年 3Dfx 推出了第一款真正全新设计的 2D+3D 显卡 VooDoo3，但由于其不支持当时流行的卡槽 AGP 2X 的绝大多数特性，仅仅拥有 16bit 显存带宽和 16MB 显存容量，加之 3Dfx 收购 STB System 后不再授权芯片给第三方厂家生产，很多厂商转而与 Nvidia 合作。 </p><p>1999 年年底,Nvidia 显卡核心代号从 NV5 飞升到 NV10，正式推出 Geforce 256 显卡， 他是首款完全支持 DirectX 3.0 的显卡，也第一次支持使用 T&amp;L 光影转换引擎进行复杂的坐标处理和光源映像的运算。伴随着该显卡的推出，Nvidia 首次提出了 GPU 的概念。<br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305161706.jpg" alt="图片alt" title="图片title"></p><p>同年，ATI 推出 Rage 128 和 Rage 128 Pro 显卡，并开启“曙光女神”计划推出 ATI<br>Rage Fury MAXX，将两颗 Rage 128 Pro 的核心集成在一张 PCB 上面，使用类似 SLI 的技术， 实现显卡性能翻倍，但其性能仍然没有超过 Nvidia。 </p><p>2000 年，3Dfx 公司在多次跳票后先后推出采用单 VSA-100 芯片方案的中低端第四代显卡 VooDoo4 4500 和采用两块 VSA-100 芯片的 VooDoo5 5500，但旗下的 STB 工厂产能低下， 不能满足市场需要，最终 3Dfx 被 Nvidia 收购。自此，Nvidia 和 ATI 两分天下的局势基本形成。 </p><h4 id="Nvidia-和-AMD-两分天下的-GPU-发展（由于更新迭代速度较快，因此本部分尽量选取重要的节点，并不会囊括所有产品）"><a href="#Nvidia-和-AMD-两分天下的-GPU-发展（由于更新迭代速度较快，因此本部分尽量选取重要的节点，并不会囊括所有产品）" class="headerlink" title="Nvidia 和 AMD 两分天下的 GPU 发展（由于更新迭代速度较快，因此本部分尽量选取重要的节点，并不会囊括所有产品）"></a>Nvidia 和 AMD 两分天下的 GPU 发展（由于更新迭代速度较快，因此本部分尽量选取重要的节点，并不会囊括所有产品）</h4><p>2001 年，Nvidia 发布 Geforce 3 系列显卡，核心包含 5700 万个晶体管，支持 Direct8.0 和可编程的 Pixel Shaders；AVI 发布基于 RV200 核心的 Radeon 7500，RV200 本质上是 RV100的频率提高版本。 </p><p>2002 年，Nvidia 发布 Geforce 4 系列，完整支持 Direct8.0，引入 NfiniteFX 引擎， 且配备了两个顶点着色引擎；ATI 推出基于 R300 核心的 Radeon 9000 系列，首次引入 VPU 视觉处理器技术，率先支持 Direct9.0，并且基于先进的 150nm 制程技术，晶体管数据多达1.1 亿个。 </p><p>2004 年，Nvidia 于 4 月发布全新采用 NV40 系列核心的 Geforce 6800 系列显卡，其中Geforce 6800 Ultra 具有 16 条渲染管线，全面支持 Direct9.0c，且加入大量新技术，比如 Pure Video 和从收购的 3Dfx 公司演变而来的 SLI 多卡互联技术。 </p><p>2006 年，Nvidia 8000 系列发布，使用 G80 核心，65nm 工艺制程，内部集成了大量流处理器，具有更大的显存带宽和更高的频率，是首批支持 DX10.0 的产品，且从 G80 核心开始 SLI 技术支持 3 显卡互联，如下图；ATI 推出核心代号 R500 的 Radeon X1000 系列，支持Direct9.0c、HDR、CrossFire 双卡互联，且完美兼容 SM3.0 技术，同年 ATI 被 AMD 收购， 但人们对 A 卡的称呼仍然没有变。<br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305161707.jpg" alt="图片alt" title="图片title"></p><p>2008 年，Nvidia 发布了采用第二代统一渲染架构的显卡 GTX260 和 GTX280，其 GPU 核心代号为 Tesla，也正是在这时 Nvidia 意识到 GPU 不应该局限于图形计算，而应该走向通用计算，因此 Nvidia 同时推出了 Cuda 计算平台和 PhysX 物理引擎等技术。 </p><p>2010 年，AMD 发布 Radeon 6000 系列显卡；Nvidia 发布 Geforce300 和 Gefore400 系列，核心研发代号为 Fermi，其中 GTX480 拥有 30 亿个晶体管，480 个 Cuda 核心，显存首次使用GDDR5，支持 DX11 且加入 PolyMorph 引擎技术，拥有强大的曲面细分能力。 </p><p>2012，Nvidia 的 Geforce600 系列，核心研发代号为 Kepler，增加了 Cuda 核心数，并升级至第二代 PolyMorph 引擎以及纹理单元等；同年，AMD 彻底改良 GPU 核心架构，推出了著名的 GCN 架构，最早采用 28nm 制程技术。囊括了全新的 AMD  Enduro（显卡切换技术），AMD ZeroCore 电源技术以及 DDM Audio 独立数字多点音频等技术。 </p><p>2016 年，Nividia 推出使用全新 Pascal 架构的新显卡 Geforce Rtx 10 系列，同时使用台积电 16nm 和三星的 14nm 制程技术；而 AMD 推出基于第四代 GCN 架构 Polaris 北极星的显卡 Radeon RX400 系列 </p><p>2018 年，Nvidia 推出 RTX 20 系显卡，首次使用 Turing GPU 的实时光线追踪技术。<br>2020 年，AMD 推出基于第二代 RDNA 架构的 RX6000 系列，支持光线追踪。而 Nividia 发布基于全新 Ampre 安培架构的 RTX30 显卡。<br>2022 年，AMD 发布了 RX7000 系列，Nvidia 则发布了 RTX40 系列。 </p><h3 id="（4）-GPU-与显卡的发展（核心技术脉络）"><a href="#（4）-GPU-与显卡的发展（核心技术脉络）" class="headerlink" title="（4） GPU 与显卡的发展（核心技术脉络）"></a>（4） GPU 与显卡的发展（核心技术脉络）</h3><p>GPU 的发展，离不开核心技术的支持，可以说，等不到背后技术的发展，仅依靠一方的力量无法开创现在 GPU 的发展程度，我们必须关注核心技术的发展，才能在当前中国技术发展被卡脖子的时候，更好地找到突破的方向。 </p><h4 id="晶体管制作工艺发展"><a href="#晶体管制作工艺发展" class="headerlink" title="晶体管制作工艺发展"></a>晶体管制作工艺发展</h4><p>GPU 芯片的核心元件是半导体。当今的半导体领域，不同的芯片中只有 GPU 芯片可以以三倍于摩尔定律的速度快速迭代发展。（摩尔定律是英特尔创始人之一戈登·摩尔根据自己的经验总结的半导体发展规律，其核心内容为：集成电路上可以容纳的晶体管数目在每经过大概 18-24 个月便会增加一倍。也就是说，芯片处理器的性能大约每两年能翻一倍。）<br>集成电路从产生到成熟大致经历了这样几个过程：电子管——晶体管——集成电路—— 超大规模集成电路。由于集成电路的发展历史过于庞大，因此这里只对近年来的集成电路和晶体管制作技术作介绍。芯片是由晶体管作为最小单元组成的，一块有限大小的芯片上能集成多少晶体管，一定程度上就决定了芯片的性能。而想集成更多晶体管，就需要更先进的技术将晶体管做的更小，我们平时说的 22nm 制程也就是一个晶体管的大小。<br>以下是近年来制程技术的历史发展情况：<br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305161708.jpg" alt="图片alt" title="图片title"></p><h4 id="GPU-核心架构发展"><a href="#GPU-核心架构发展" class="headerlink" title="GPU 核心架构发展"></a>GPU 核心架构发展</h4><p>晶体管制作工艺限制了芯片计算强度的上线，但芯片的电路设计同样至关重要，决定着能否将芯片上的晶体管利用率最大化。在 GPU 几十年的发展史中，每一次核心架构的变迁都意味着一次较大的技术更迭和跨越。从 2008 年开始，Nvidia 的 GPU 架构几乎保持了每 2 年一次大更新，带来更多更新的运算单元和更好的 API 适配性，也使得 GPU 的性能不断攀升。AMD 也在近些年不止一次进行过核心架构的整体换血更新。在核心架构每次的大换代之间， 也会针对性地进行一些小升级，比如采用 Kepler 二代微架构的 GK110 核心相较于采用初代Kepler 微架构的 GK104 核心，升级了显卡智能动态超频技术，提升了 CUDA 运算能力，极致流式多处理器（SMX）的浮点运算单元提升 8 倍，加入了 Hyper-Q 技术，提高 GPU 的利用率， 更新了网格管理单元（Grid Management Unit），为动态并行技术提供了灵活性。下图展示了近年来 Nvidia 的 GPU 核心架构的变迁（图源网络）：<br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305161709.jpg" alt="图片alt" title="图片title"></p><h4 id="接口类型变迁"><a href="#接口类型变迁" class="headerlink" title="接口类型变迁"></a>接口类型变迁</h4><p>接口类型是指显卡连接主板所采用的接口种类。接口的决定了 GPU 和 CPU 数据传输的最大带宽。PCI 是 Peripheral Component Interconnect（外设部件互连标准）的缩写，几乎所有的主板产品上都带有这种插槽，它是个人电脑中使用最为广泛的接口。PCI 插槽也是主板数量最多的插槽类型，在流行的台式机主板上，ATX 结构的主板一般带有 5～6 个 PCI 插槽，M-ATX 主板也都带有 2～3 个 PCI 插槽，可见其应用的广泛性。<br>显卡发展过程中，出现过 ISA、PCI、AGP（发展过程包括 AGP1X、AGP2X、AGP4X、AGP Pro、AGP8X）等几种接口，所能提供的数据带宽依次增加。2004 年，PCI Express 接口标准被正式提出，目前的显卡大多使用 PCI-e 接口。<br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305161710.jpg" alt="图片alt" title="图片title"></p><h4 id="显存技术发展"><a href="#显存技术发展" class="headerlink" title="显存技术发展"></a>显存技术发展</h4><p>计算机运行中需要内存，而图形计算单元同样需要显存。目前比较常看到的 DDR、GDDR、HBM 都是动态随机存储器，即都是内存。DDR 和 GDDR 是我们日常计算机中使用的内存，相对加工工艺成熟，技术标准体系健全，其中 GDDR 是面向显卡和 GPU 的显存。DDR 是 Double Data Rate 的缩写，指的是在一个时钟周期内传输两次数据的双倍速率同步动态随机存储器。GDDR 是用在显卡上的内存，目前也已经发展到了第五代。相对于 GDDR3、GDDR4 而言，GDDR5 显存拥有诸多技术优势，拥有更高的带宽、更低的功耗、更高的性能。<br>而 HBM 是同样是用在显卡中的内存（显存），和 GDDR 区别是采用垂直堆叠半导体工艺生</p><p>产的的存储芯片，通过被称为“硅透”(TSV)的线相互连接，实现低功耗、超宽带通信通道， 相比 GDDR5 减少了通信成本，单位带宽能耗更低，制作工艺更高，所以极大减少晶元空间。但加工成本更高。 </p><h4 id="DirectX-及-Shader-Model-发展"><a href="#DirectX-及-Shader-Model-发展" class="headerlink" title="DirectX 及 Shader Model 发展"></a>DirectX 及 Shader Model 发展</h4><p>上文中曾经提到的 SM3.0 是 Shader Model 3.0 的缩写，该技术随 DirectX 更新。更好的 Shader Model 支持在很大程度上丰富了游戏研发时的编程模型。<br>SM3.0 中 3.0 像素渲染引擎 3.0 和顶点渲染引擎 3.0 的最大指令数分别从上一代的 256<br>个和 96 个提升到 65535 个。<br>SM4.0 放弃之前版本中分离的像素渲染引擎以及顶点渲染引擎架构，而是通过统一渲染架构实现像素或者顶点渲染的功能，大幅度地提高 GPU 的资源利用率。加入了新的几何渲染引擎，首次允许 GPU 动态创建或者删除图等。<br>SM5.0 在指令集方面进行了扩充和改进，DirectX 11 采用了针对 HDR 的 BC6H 压缩算法和针对 RGB 的 BC7 压缩算法。并且支持多线程处理技术，通过引入延迟执行这一指令，将一个渲染进程拆分成多个线程，实现了多线程处理一个渲染进程的效果。 </p><h2 id="二、GPU-发展现状"><a href="#二、GPU-发展现状" class="headerlink" title="二、GPU 发展现状"></a>二、GPU 发展现状</h2><p>Nvidia 在 2019 年举办的中国 GTC 大会上，设置了两大主题，具体主题如下图所示。可以预见，在未来的发展方向上，以 AI 深度学习等为代表的 GPU 通用计算将会大大增加其权重， GPU 的未来趋势无外乎 3 个：大规模扩展计算能力的高性能计算（GPGPU）、人工智能计算（AIGPU）、更加逼真的图形展现（光线追踪 Ray Tracing GPU)。<br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305161711.jpg" alt="图片alt" title="图片title"></p><p>在高性能计算方面，NVIDIA 于 最 新 发 布 的 NVIDIA A100 显卡可针对 AI、数据分析和 HPC 应用场景，在不同规模下实现出色的加速，有效助力更高性能的弹性数据中心。A100 的芯片是使用 NVIDIA Ampere 架构的 Tensor 核心。Tensor 核心借助 Tensor 浮点运算 (TF32) 精度，能在不更改代码的前提下，提供比之前的 Volta 核心 高 20 倍之多的性能；若使用自动混合精度和 FP16，性能可进一步提升 2 倍。与 NVIDIA® NVLink®、NVIDIA NVSwitch™、PCIe 4.0、NVIDIA® InfiniBand® 和 NVIDIA Magnum IO™ SDK 结合使用时，它能扩展到数千个 A100 GPU。A100 提供 40GB 和 80GB 显存两种版本，其中的 80GB 版本由于 GPU 显存增加，且提供超快速的显存带宽（每秒超过 2 万亿字节 [TB&#x2F;s]），拥有处理超大型模型和数据集的能力。<br>在光线追踪和图形显示方面，Nvidia 最新发布的RTX4090 作为一款性能出众的 GeForce GPU，在性能、效率和 AI 驱动的图形领域实现了质的飞跃。这款 GPU 采用 NVIDIA Ada Lovelace 架构，配备 24 GB 的 G6X 显存，可为游戏玩家和创作者带来出众的体验。<br>RTX 30 使用的三星 8nm 工艺本质是 10nm，而 RTX 4090 则是采用的台积电定制 4nm 工</p><p>艺，至少进步了 2 代半。RTX 4090 拥有 763 亿晶体管，就说每 mm2 有 1.25 亿晶体管，相比<br>0.45 亿的 RTX 3090 Ti 密度提升了 178%，核心频率也从 1860 上升到 2520MHz，提升幅度高达 35%。 </p><h3 id="（1）-芯片制程技术发展现状"><a href="#（1）-芯片制程技术发展现状" class="headerlink" title="（1） 芯片制程技术发展现状"></a>（1） 芯片制程技术发展现状</h3><p>2022 年 6 月 30 日，三星电子宣布：3 纳米芯片量产！根据三星官网的数据，3nm 芯片相比之前的 5nm 芯片，性能提升 23%，功耗降低 45%，芯片面积缩小 16%。<br>2022 年 7 月 1 日，长电科技宣布实现 4nm 手机芯片封装，以及 CPU，GPU 和射频芯片的集成封装。 </p><p>中国芯片现状：<br>全产业链国产化可实现 90nm（中国目前最顶级的、完全自主知识产权的量产化光刻机： 上微电（SMEE）的 SSA600&#x2F;20 型 90nm 光刻机）；<br>全产业链去美化可实现 28nm（中芯国际稳定制程 28nm，使用 ASML 的 DUV 光刻机）； 全产业链最先进的制程是 14nm（中芯国际目前最先进的制程是 14nm，2019 年 14nm 制<br>程工艺量产，代工华为的麒麟 710A 芯片)。 </p><h3 id="（2）-国内-GPU-产品线发展现状"><a href="#（2）-国内-GPU-产品线发展现状" class="headerlink" title="（2） 国内 GPU 产品线发展现状"></a>（2） 国内 GPU 产品线发展现状</h3><p>近些年国产 GPU 蓬勃发展，由于在芯片技术上被卡脖子，国内必须加紧 GPU 芯片的研发和设计发展。其中，发展比较快的有以下几个公司： </p><h4 id="景嘉微"><a href="#景嘉微" class="headerlink" title="景嘉微"></a>景嘉微</h4><p>成立于 2006 年 4 月的长沙景嘉微公司是目前唯一专注于国产GPU 芯片设计的上市公司。2014 年 4 月，景嘉微成功研发出国内首款具有完全自主知识产权的高可靠、低功耗 GPU 芯片-JM5400，打破了中国 GPU 市场长期被国外产品垄断的局面。<br>景嘉微 GPU 已完成与龙芯、飞腾、麒麟软件、统信软件、道、天脉等国内主要 CPU 和操作系统厂商的适配工作；与中国长城、超越电子等十余家国内主要计算机整机厂商建立合作关系并进行严格的产品测试；与麒麟、长城、苍穹、宝德、超图、昆仑、中科方德、中科可控、宁美等多家软硬件厂商进行互相认证，共同构建国产化本土化的计算机应用生态。<br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305161712.jpg" alt="图片alt" title="图片title"></p><h4 id="芯动科技"><a href="#芯动科技" class="headerlink" title="芯动科技"></a>芯动科技</h4><p>2020 年 10 月，位于武汉的芯动科技宣布与 Imagination 达成合作，将采用多晶粒<br>（chiplet）和 GDDR6 高速显存等 SoC 创新技术，基于 Imagination 全新顶配 BXT 多核架构，开发“风华”系列 GPU。<br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305161713.jpg" alt="图片alt" title="图片title"></p><p>在信创和算力安全方面，“风华”系列 GPU 内置物理不可克隆 iUnique Security PUF 信息安全加密技术，提升数据安全和算力抗攻击性，支持桌面电脑和数据中心 GPU 计算自主可控生态。这款 GPU 芯片自带浮点和智能 3D 图形处理功能，全定制多级流水计算内核，兼具高性能渲染和智能 AI 算力，还可级联组合多颗芯片合并处理能力，灵活性大大增加，适配国产桌面市场 1080P&#x2F;4K&#x2F;8K 高品质显示，支持 VR&#x2F;AR&#x2F;AI，多路服务器云桌面、云游戏、云办公等应用场景。 </p><h2 id="三、我的感想"><a href="#三、我的感想" class="headerlink" title="三、我的感想"></a>三、我的感想</h2><p>通过这几天的查找资料和学习，我对芯片制造、晶体管、GPU 核心架构等都有了一个普遍的了解。我觉得这次学习对我的提升是非常明显的，有很多之前完全不了解的硬件知识可以进行一个系统的认知。<br>在学习的过程中，我也有很多感想。<br>首先就是在查阅一些图形学和 GPU 发展的历史的时候，我惊奇地发现，其实 GPU 技术几乎从上世纪 80 年代才开始发展，最核心最快速的发展进程也就集中在上世纪末和本世纪的<br>20 年内，这让我有一种很特别的感受，似乎就是在我作为一个个体成长起来的同时，图形学和 GPU 软件和硬件发展领域不断有新的技术涌现出来，行业飞速前进，而当我成长到决定之后从事图形学相关研究方向时，发现已经有很多研究成果，这些成果让现在的我们得以站在巨人的肩膀上，享受到更强大的计算机性能，极大地方便了研究的过程。<br>第二，在查阅资料的过程中，我了解到，GPU 的研发是一个非常复杂的过程，涉及到很多方面的技术。当前芯片制造工艺被卡脖子，最严重，也最难突破的关键点是制作精密芯片的光刻机，我们国家没有成熟的光刻机技术，就没办法制作芯片。而目前光刻机只有荷兰的ASML 公司可以生产，一旦该公司不出口给我国光刻机，我们就完全无法自主制作芯片。因此我们国家要想突破这层桎梏，就必须去探索发展光刻机技术。<br>第三，在学习历史的过程中，我也从各公司的发展中学习到一些失败的经验，比如Nvidia 在刚创始时就妄图改变行业规则，而导致了失败，GPU 终究是硬件工具，硬件的制作需要软件来驱动，实现更多功能，我们可以看到历代 GPU 的发展都伴随着能支持 DX 系统的迭代，因此如果不能和目前主流的 Windows、DirectX、OpenGL 相兼容，就不会受到市场的欢迎，自然也就无法在商业上推广。<br>第四，GPU 的发展本质上也需要核心架构的发展，正如之前提到的，没有好的核心电路架构，就算晶体管制程工艺发展好了，也无法释放其计算能力，因此，大力发展我国的微电子电路设计能力是十分有必要的，好的核心架构和技术甚至能获得一定的专利保障。<br>第五，GPU 发展离不开技术的支持，不同厂商的 GPU 都有其核心的竞争技术，比如 Nvidia的 DLSS，AMD 的 FSR 和 Inter 的 XESS。作为一款产品，不拿出新的技术支持，GPU 也终究只是一些复杂精细的元件，Nvidia 目前是一家独大的显卡公司，但与此同时，他也引领着图形学尤其是渲染领域很多核心技术的发展，在我之前写毕业论文的时候就曾经感受过这一点，Nvidia 强大的技术能力也体现在他们有很多工业界的方法去得到更好的图形效果，比如基于方差估计的 MipMap Roughness 优化等。<br>第六，我国目前的 GPU 事业也已经有了一定发展，我们不能妄自菲薄，但是也不能好高骛远，必须承认的是，我们目前独立制造的 GPU 仍与世界先进技术存在着至少两三代的代差，比如国内一些显卡厂商的 GPU 算力只能对标 Nvidia 的 10 系显卡，我国 GPU 发展事业仍然道阻且长。 </p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] Ivan E. Sutherland(Massachusetts Institute of Technology). SKETPAD: A MAN- MACHINE GRAPHICAL COMMUNICATION SYSTEM[J]. PROCEEDINGS—SPRING JOINT COMPUTER CONFERENCE, 1963.<br>[2] NVIDIA. NVIDIA launches the World’s first graphics processing unit: GeForce 256[EB&#x2F;OL]. (2002-01-11) [2023-01-06].<br>[3] BRIDGES R A, IMAM N, MINTZ T M, et al. Understanding GPU power: a survey of profiling, modeling, and simulation methods[J]. ACM Computing Surveys, 2016, 49(3): 41:1-41:27.<br>[4] Jacob Gaboury, Alvy Ray Smith, Mary Whitton,etc. 2021. Making Computer Graphics History Public: SIGGRAPH 2021 Retrospective Panel. In Special Interest Group on Computer Graphics and Interactive Techniques Conference (SIGGRAPH ‘21 Panels). Association for Computing Machinery, New York, NY, USA, Article 8, 1- 3.<br>[5] Prashanta Kumar Das, Ganesh Chandra Deka. History and Evolution of GPU Architecture[M].<br>[6] NVIDIA. NVIDIA HISTORY-A Timeline of Innovation[EB&#x2F;OL]. [2023-01-06]. <a href="https://www.nvidia.com/en-us/about-nvidia/corporate-timeline/">https://www.nvidia.com/en-us/about-nvidia/corporate-timeline/</a><br>[7] MACRI J. AMD’s next generation GPU and high bandwidth memory architecture: FURY[C]&#x2F;&#x2F; Hot Chips Symposium. IEEE, 2015: 1-26.<br>[8] BENAMOU J. Big ray tracing[J]. Journal of Computational Physics, 1996, 128(2): 463-474.<br>[9] 熊 庭刚 .GPU 的发 展历 程、未 来趋 势及 研制实 践 [J]. 微纳 电子 与智能 制造,2020,2(02):36-40.<br>[10] Graham Singer. The History of the Modern Graphics Processor-The Early Days of 3D Consumer Graphics[EB&#x2F;OL]. (2022-12-01) [2023-01-06]. <a href="https://www.techspot.com/article/650-history-of-the-gpu/">https://www.techspot.com/article/650-history-of-the-gpu/</a><br>[11] Olena. A brief history of GPU[EB&#x2F;OL]. (2018-02-22) [2023-01-06]. <a href="https://medium.com/altumea/a-brief-history-of-gpu-47d98d6a0f8a">https://medium.com/altumea/a-brief-history-of-gpu-47d98d6a0f8a</a><br>[12] JAKE FRANKENFIELD. What Is a Graphics Processing Unit (GPU)? Definition and Examples[EB&#x2F;OL]. (2021-09-07) [2023-01-06]. <a href="https://www.investopedia.com/terms/g/graphics-processing-unit-gpu.asp">https://www.investopedia.com/terms/g/graphics-processing-unit-gpu.asp</a> </p><p>[13] 丽台科技. GPU 硬件的发展史是怎样的？[EB&#x2F;OL]. (2016-02-13) [2023-01-06]. <a href="https://www.zhihu.com/question/21980949">https://www.zhihu.com/question/21980949</a><br>[14] biaoJM. GPU-directX 的发展历史[EB&#x2F;OL]. (2018-04-28) [2023-01-06]. <a href="https://www.cnblogs.com/biaoJM/p/10186721.html">https://www.cnblogs.com/biaoJM/p/10186721.html</a><br>[15] 顾正书. 国产 GPU 风生水起，英伟达和 AMD 感受到威胁了吗？[EB&#x2F;OL]. (2021-03-31) [2023-01-06].<br><a href="https://www.eet-china.com/news/202103310840.html">https://www.eet-china.com/news/202103310840.html</a><br>[16] 一个显卡型号及具体参数整合网站.<a href="https://videocardz.net/">https://videocardz.net/</a> </p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphics </category>
          
          <category> Rendering </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Homework </tag>
            
            <tag> Rendering </tag>
            
            <tag> GPU </tag>
            
            <tag> Computer Graphics </tag>
            
            <tag> Computer Graphics History </tag>
            
            <tag> Nvidia </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机动画HW1 - 路径曲线与运动物体控制</title>
      <link href="/2023/05/16/Cardinal-Spline/"/>
      <url>/2023/05/16/Cardinal-Spline/</url>
      
        <content type="html"><![CDATA[<p>课程名称：计算机动画<br>实验项目名称：路径曲线与运动物体控制<br>实验日期：2020 年 9 月 27 日</p><span id="more"></span><div class="tag link"><a class="link-card" title="code" href="https://github.com/YaelCassini/CA_HW1"><div class="left"><img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/256/safari.png"/></div><div class="right"><p class="text">code</p><p class="url">https://github.com/YaelCassini/CA_HW1</p></div></a></div><div class="tag link"><a class="link-card" title="video" href="https://www.bilibili.com/video/BV1T34y1B7WJ/"><div class="left"><img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/256/safari.png"/></div><div class="right"><p class="text">video</p><p class="url">https://www.bilibili.com/video/BV1T34y1B7WJ/</p></div></a></div><div class="tag link"><a class="link-card" title="report" href="https://yaelcassini.github.io/2023/05/16/Cardinal-Spline/"><div class="left"><img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/256/safari.png"/></div><div class="right"><p class="text">report</p><p class="url">https://yaelcassini.github.io/2023/05/16/Cardinal-Spline/</p></div></a></div><h2 id="一、-实验目的和要求"><a href="#一、-实验目的和要求" class="headerlink" title="一、 实验目的和要求"></a>一、 实验目的和要求</h2><ol><li>设计并实现一个路径曲线，通过不同参数控制曲线状态，并实现对物体沿生成路线运动的控制。</li><li>通过上述实验内容，了解动画动态控制的基本原理何方法，提高动画编程能力。</li></ol><h2 id="二、-实验内容和原理"><a href="#二、-实验内容和原理" class="headerlink" title="二、 实验内容和原理"></a>二、 实验内容和原理</h2><ol><li>选用 Cardinal 曲线表示运动路径，掌握它的表示和算法，了解不同控制参数对曲线形状和状态的影响。</li><li>编写代码实现 Cardinal 曲线算法，对照 cardinal 样条曲线的数学表示和程序之间的对应关系。</li><li>给定若干关键控制点的位置（这些控制点可以大致描述某个运动路径的形状），用上述程序计算出控制点之间的插值点，显示出样条曲线。</li><li>改变曲线弯曲程度的参数$τ∈[0，1]$大小和控制插值点数目的参数 grain ，观察曲线形状的变化。</li><li>在路径曲线上放置一小汽车，使其在沿生成的 cardinal 曲线运动，汽车速度和加速度可以调节。</li></ol><h2 id="三、-实验平台"><a href="#三、-实验平台" class="headerlink" title="三、 实验平台"></a>三、 实验平台</h2><p>Qt 5.14.2 @ Windows</p><h2 id="四、-实验步骤"><a href="#四、-实验步骤" class="headerlink" title="四、 实验步骤"></a>四、 实验步骤</h2><h3 id="1-首先，对照Cardinal-样条曲线的数学表达和程序中计算代码的对应关系。"><a href="#1-首先，对照Cardinal-样条曲线的数学表达和程序中计算代码的对应关系。" class="headerlink" title="1. 首先，对照Cardinal 样条曲线的数学表达和程序中计算代码的对应关系。"></a>1. 首先，对照Cardinal 样条曲线的数学表达和程序中计算代码的对应关系。</h3><p>Cardinal 样条曲线矩阵表示：<br>$$$ P(u) &#x3D; U^T M B $$$<br>其中，u 是幂次最高为 3 的插值变量，且u∈[0,1]， M 是 Hermite 多项式矩阵，B 是曲线中，用户指定的关键点数据。其矩阵展开表示。<br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305161622.jpg" alt="图片alt" title="图片title"></p><p>其中，$P_i-1，P_i，P_i+1，P_i+2$，是用户指定的控制点控制点，参数τ 控制曲线的弯曲程度。<br>为了实现 Cardinal 样条曲线计算，创建 spline 类。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class spline</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    double *ax,*bx,*cx,*dx;//P(u)系数</span><br><span class="line">    double *ay,*by,*cy,*dy;//P(u)系数</span><br><span class="line">    double *A,*B,*C,*D,*E;//计算弧长所用系数</span><br><span class="line">    double* matrix[4];//计算矩阵</span><br><span class="line">    double tension;//参数τ</span><br><span class="line">    int num;//关键点个数</span><br><span class="line">    int grain;//每两个关键点之间插值点的个数（含关键点）</span><br><span class="line">    bool create_flag=false;//是否已经为指针分配空间（判断是否需要delete）</span><br><span class="line">    vector&lt;QPoint&gt; all_points;//所有点</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    spline();</span><br><span class="line">     //生成CubicSpline曲线</span><br><span class="line">    void set_Spline(vector&lt;QPoint&gt;&amp; vec,int _grain,double _tension);</span><br><span class="line">    //计算生成的三次样条曲线上所有插值点</span><br><span class="line">    void CubicSpline(vector&lt;QPoint&gt;&amp; vec);</span><br><span class="line">    double calc_Total_length();  //计算曲线总长度</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    void init_Matrix(); //初始化矩阵</span><br><span class="line">    void init_spline_Coefficient(vector&lt;QPoint&gt;&amp; vec);//计算P(u)系数</span><br><span class="line"></span><br><span class="line">    QPoint calc_Interpolation(int i,double u);//计算内部插值点</span><br><span class="line">    point calc_double_Interpolation(int i,double u);//计算内部插值点（坐标为double类型）</span><br><span class="line"></span><br><span class="line">    vector&lt;QPoint&gt;&amp; get_all_points();  //返回储存所有插值点的vector</span><br><span class="line"></span><br><span class="line">    void init_length_Coefficient(int _num);//初始化长度计算参数</span><br><span class="line">    double f(int i,double u); //f函数</span><br><span class="line">    double simpson(int i,double a,double b);//求样条曲线长度</span><br><span class="line">    double calc_U(double s,int i,double u1,double u2);//根据长度计算参数u的值</span><br><span class="line">    void clear();//清除数据</span><br><span class="line"></span><br><span class="line">    ~spline()&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中 set_Spline 函数根据关键点数组 vec、插值点数目 _grain、和控制曲线弯曲程度的参数 _tension 生成样条曲线所需要的计算数据<br>（如矩阵数值，P(u)系数等）。具体算法见源码。</p><p>其中init_Matrix 函数计算矩阵中的数值，即为 P(u)公式中的矩阵M。init_spline_Coefficient 函数计算不同曲线段中的P(u)多项式系数，即为公式中的 M*B（分 x，y 两个方向计算）。具体算法见源码。</p><h3 id="2-CubicSpline-函数"><a href="#2-CubicSpline-函数" class="headerlink" title="2. CubicSpline 函数."></a>2. CubicSpline 函数.</h3><p>根据_grain 值生成不同的u 值，并计算曲线上所有插值点的坐标，储存在名为 all_points 的 vector 中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//计算曲线上所有插值点</span><br><span class="line">void spline::CubicSpline(vector&lt;QPoint&gt;&amp; vec)</span><br><span class="line">&#123;</span><br><span class="line">    //当没清除就再次点击生成曲线时，不清除之前的插值点，插入间隔点</span><br><span class="line">    QPoint temp(0,0);</span><br><span class="line">    all_points.push_back(temp);</span><br><span class="line"></span><br><span class="line">    //根据设置的插值点个数参数，计算对应的u值</span><br><span class="line">    int num=vec.size();</span><br><span class="line">    double* u = new double[grain];</span><br><span class="line">    for (int i = 0; i&lt;grain; i++) &#123;</span><br><span class="line">        u[i] = ((double)i) / grain;  //u [0,1]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //根据u值和曲线参数计算插值点坐标</span><br><span class="line">    for (int i = 0; i&lt;num-1; i++) &#123;</span><br><span class="line">        QPoint p1=vec[i];</span><br><span class="line">        //加入关键点</span><br><span class="line">        all_points.push_back(p1);</span><br><span class="line">        for (int j = 1; j&lt;grain; j++) &#123;</span><br><span class="line">            QPoint temp=calc_Interpolation(i,u[j]);</span><br><span class="line">            all_points.push_back(temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //加入关键点</span><br><span class="line">    QPoint p1=vec[num-1];</span><br><span class="line">    all_points.push_back(p1);</span><br><span class="line"></span><br><span class="line">    delete []u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，calc_Interpolation 函数根据曲线段序号i，和参数 u 的不同值，计算具体一个插值点的坐标。</p><h3 id="3-编写-paintWindow-类作为画板，继承自-QWidget-类。"><a href="#3-编写-paintWindow-类作为画板，继承自-QWidget-类。" class="headerlink" title="3. 编写 paintWindow 类作为画板，继承自 QWidget 类。"></a>3. 编写 paintWindow 类作为画板，继承自 QWidget 类。</h3><p>在paintWindow 类中编写鼠标回调函数mousePressEvent，记录通过鼠标交互选定的关键点。以及绘制函数 paintEvent，在每次update（）时调用。paintWindow 类定义具体如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">class paintWindow : public QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">private:</span><br><span class="line">    spline* sp;</span><br><span class="line">    int grain;  //每个曲线区间有多少个插值点（包括两端关键点）</span><br><span class="line">    double tension;  //参数，控制曲线弯曲程度</span><br><span class="line"></span><br><span class="line">    bool ifDrawInpoint=false;  //是否显示插值点</span><br><span class="line"></span><br><span class="line">    int time;//时间</span><br><span class="line">    QTimer* timer;  //计时器</span><br><span class="line">    QPixmap* car[5];  //储存小车位图信息</span><br><span class="line"></span><br><span class="line">    int car_index;//显示第几种小车</span><br><span class="line">    int pen_index=0;//使用第几种笔刷</span><br><span class="line"></span><br><span class="line">    double speed;  //小车速度</span><br><span class="line">    double accelerate;  //小车加速度</span><br><span class="line"></span><br><span class="line">    point now_point;  //运动当前点</span><br><span class="line">    point next_point;  //运动下一个点</span><br><span class="line">    double ratio;  //旋转角度</span><br><span class="line"></span><br><span class="line">    vector&lt;QPoint&gt; points;//储存所有关键点</span><br><span class="line"></span><br><span class="line">    bool endflag=false;  //小车是否运动到曲线末端</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    paintWindow();</span><br><span class="line"></span><br><span class="line">    void paintEvent(QPaintEvent *);  //绘制函数</span><br><span class="line">    void mousePressEvent(QMouseEvent *e);  //鼠标回调函数</span><br><span class="line"></span><br><span class="line">    void create_Spline(int _grain, double _tension);  //生成并显示cubicspline曲线</span><br><span class="line">    void start_Move(double _speed,double _accelarate);  //小车开始运动</span><br><span class="line">    void stop_Move();  //小车暂停运动</span><br><span class="line">    void continue_Move();  //小车继续运动</span><br><span class="line"></span><br><span class="line">    int numbers();  //关键点个数</span><br><span class="line">    double total_length();  //曲线总长度</span><br><span class="line">    double now_length();  //小车当前走过的路线长度</span><br><span class="line">    int get_spline_index(double now_len);  //获取小车当前在哪一段曲线</span><br><span class="line">    double get_Ratio();  //获取当前曲线斜率</span><br><span class="line"></span><br><span class="line">    void change_car();  //改变小车</span><br><span class="line">    void change_pen(QPainter&amp; paint);  //改变笔刷</span><br><span class="line">    void change_DrawInPoint();  //改变是否绘制插值点的控制变量</span><br><span class="line">    QPixmap* now_car();  //当前小车位图指针</span><br><span class="line"></span><br><span class="line">    void clear();</span><br><span class="line">private slots:</span><br><span class="line">    void changeState();  //连接计时器，改变小车坐标，旋转角度等信息</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h3><p>鼠标回调函数mousePressEvent，记录通过鼠标交互选定的关键点。<br>绘制函数 paintEvent，根据数据变化，绘制所有的关键点、曲线，已经选择是否绘制插值点。</p><h3 id="5-引入QTimer-类作为计时器"><a href="#5-引入QTimer-类作为计时器" class="headerlink" title="5. 引入QTimer 类作为计时器."></a>5. 引入QTimer 类作为计时器.</h3><p>每隔一段时间调用 changestate 函数，改变小车坐标及旋转角度等。其中now_point 是当前小车位置，next_point 是下一个小车位置。get_Ratio 函数计算当下曲线的斜率，以及小车旋转角度。</p><h3 id="6-MainWindow-设计及按钮槽函数"><a href="#6-MainWindow-设计及按钮槽函数" class="headerlink" title="6. MainWindow 设计及按钮槽函数"></a>6. MainWindow 设计及按钮槽函数</h3><p>MainWindow 窗口设计如下：<br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305161623.jpg" alt="图片alt" title="图片title"></p><p>MainWindow 类设计：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class MainWindow : public QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">private:</span><br><span class="line">    paintWindow* p_w;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    MainWindow(QWidget *parent = nullptr);</span><br><span class="line">    ~MainWindow();</span><br><span class="line"></span><br><span class="line">private slots:</span><br><span class="line">    void on_create_clicked();//绘制曲线并显示</span><br><span class="line">    void on_clear_clicked();//清屏</span><br><span class="line">    void on_start_clicked();//开始运动按钮槽函数</span><br><span class="line">    void on_show_clicked();//展示插值点按钮槽函数</span><br><span class="line">    void on_stop_move_clicked();//停止运动按钮槽函数</span><br><span class="line">    void on_continue_move_clicked();//继续运动按钮槽函数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    void update_numbers();//更新关键点数目</span><br><span class="line">    void on_change_clicked();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    Ui::MainWindow *ui;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="五、-实验结果分析"><a href="#五、-实验结果分析" class="headerlink" title="五、 实验结果分析"></a>五、 实验结果分析</h2><p>选取控制点：<br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305161624.jpg" alt="图片alt" title="图片title"></p><p>绘制曲线：同时显示关键点个数和路线总长度。<br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305161625.jpg" alt="图片alt" title="图片title"></p><p>不同参数对曲线值的影响：</p><p>1、不同的 grain：grain&#x3D;5（红色）和 grain&#x3D;60（蓝色）<br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305161626.jpg" alt="图片alt" title="图片title"></p><p>2、不同的tension（τ）：分别为：<br>0（绿色），0.25（灰色），0.5（红色），0.75（蓝色），1.0（黄色）<br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305161627.jpg" alt="图片alt" title="图片title"></p><p>显示插值点（白色为内部插值点）：<br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305161628.jpg" alt="图片alt" title="图片title"></p><p>小车开始运动：<br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305161629.jpg" alt="图片alt" title="图片title"></p><p>更换小车：<br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305161630.jpg" alt="图片alt" title="图片title"></p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphics </category>
          
          <category> Computer Animation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Homework </tag>
            
            <tag> Computer Animation </tag>
            
            <tag> Spline </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机动画HW2 - 线性插值和矢量线性插值关键帧动画</title>
      <link href="/2023/05/16/Keyframe-Interpolation/"/>
      <url>/2023/05/16/Keyframe-Interpolation/</url>
      
        <content type="html"><![CDATA[<p>课程名称：计算机动画<br>实验项目名称：线性插值和矢量线性插值关键帧动画<br>实验日期：2020 年 11 月 6 日</p><span id="more"></span><div class="tag link"><a class="link-card" title="code" href="https://github.com/YaelCassini/CA_HW2"><div class="left"><img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/256/safari.png"/></div><div class="right"><p class="text">code</p><p class="url">https://github.com/YaelCassini/CA_HW2</p></div></a></div><div class="tag link"><a class="link-card" title="video" href="https://www.bilibili.com/video/BV1zL4y137rn/"><div class="left"><img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/256/safari.png"/></div><div class="right"><p class="text">video</p><p class="url">https://www.bilibili.com/video/BV1zL4y137rn/</p></div></a></div><div class="tag link"><a class="link-card" title="report" href="https://yaelcassini.github.io/2023/05/16/Keyframe-Interpolation/"><div class="left"><img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/256/safari.png"/></div><div class="right"><p class="text">report</p><p class="url">https://yaelcassini.github.io/2023/05/16/Keyframe-Interpolation/</p></div></a></div><h2 id="一、-实验目的和要求"><a href="#一、-实验目的和要求" class="headerlink" title="一、 实验目的和要求"></a>一、 实验目的和要求</h2><ol><li>关键帧动画技术是计算机动画中的一类重要技术。本实验选取线性插值和矢量线性插值作为实验内容，旨在了解关键帧动画系统的结构，变形算法的思想以及不同算法对应的不同性能。</li><li>本实验要求实现线性插值和矢量线性插值两种关键帧插值算法的图形化界面展示，用户通过鼠标点击交互选定起点帧和终点帧的关键点，由程序自行生成起始帧的图形，并且通过计算得到中间的插值图像，连续播放形成关键帧动画。</li></ol><h2 id="二、-实验内容和原理"><a href="#二、-实验内容和原理" class="headerlink" title="二、 实验内容和原理"></a>二、 实验内容和原理</h2><p>系统包括三个部分：</p><ol><li>输入数据：包括初始形状数据和终止形状数据, 一般为事先定义好的整型变量数据,如简单的几何物体形状(苹果，凳子，陶罐)以及简单的动物形状(大象，马)等。也可以设计交互界面，用户通过界面交互输入数据。</li><li>插值算法：包括线性插值和矢量线性插值。</li></ol><ul><li><p>线性插值：对于初始和终止形状上每个点的坐标 $P_i$  进行线性插值得到物体变形的中间形状；</p></li><li><p>矢量线性插值：对初始形状和终止形状上每两个相邻点计算其对应的矢量的长度和角度，然后对其进行线性插值得到中间长度和角度， 对起点帧和终点帧的第一个关键点进行线性插值得到中间图像的第一个关键点。顺序连接插值后定义的各个矢量得到中间变化形状。插值变量变化范围是[0，1], 插值变量等于 0 时对应于初始形状，插值变量等于 0 时对应于终止形状；数据类型为 double。</p></li></ul><ol start="3"><li>插值结果输出。用户可以在图形化界面中自行指定插值帧的个数以及动画刷新频率，程序会根据其设定的参数生成不同效果的关键帧动画并播放动画。用户可以通过点击不同插值方式的按钮，反复播放不同算法生成的插值结果。</li></ol><h2 id="三、-实验平台"><a href="#三、-实验平台" class="headerlink" title="三、 实验平台"></a>三、 实验平台</h2><p>Qt 5.14.2 @ Windows</p><h2 id="四、-实验步骤"><a href="#四、-实验步骤" class="headerlink" title="四、 实验步骤"></a>四、 实验步骤</h2><h3 id="1-线性插值："><a href="#1-线性插值：" class="headerlink" title="1.线性插值："></a>1.线性插值：</h3><p>指定两幅关键画面图形(最简单的是大小不同的两个矩形，分别由４个点构成。学生也可以自己构造更复杂的图形，如由若干点构成的手图形)， 然后计算两幅图对应点的线性距离来得到它们的中间画面图形。<br>设图形上有 N 个点，$(x_i，y_i),  i&#x3D;1,…N$;  初始图形的点记为$(x_{0i}， y_{0i})$，终止图形记为$(x_{1i}，y_{1i})$，生成的中间图形记为$(x_{ti}，y_{ti})$，设生成 M 个画面，则有：</p><p>$$$ x_{ti} &#x3D; x_0<em>t + x_1</em>(1-t);t&#x3D;1,…M; y_{ti} &#x3D; y_0<em>t + y_1</em>(1-t); $$$</p><p>线性插值代码实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">if (mode == 0)</span><br><span class="line">&#123;</span><br><span class="line">inter_points.clear();</span><br><span class="line">double t = 1.0 * time / grain;</span><br><span class="line">for (int i = 0; i &lt; start_points.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line">QPoint temp;</span><br><span class="line">double x0 = start_points[i].x();</span><br><span class="line">double y0 = start_points[i].y();</span><br><span class="line">double x1 = end_points[i].x();</span><br><span class="line">double y1 = end_points[i].y();</span><br><span class="line">double x = (1 - t) * x0 + t * x1;</span><br><span class="line">double y = (1 - t) * y0 + t * y1;</span><br><span class="line"></span><br><span class="line">temp.setX(x);</span><br><span class="line">temp.setY(y);</span><br><span class="line">inter_points.push_back(temp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-矢量线性插值："><a href="#2-矢量线性插值：" class="headerlink" title="2.矢量线性插值："></a>2.矢量线性插值：</h3><p>与线性差值框架类似，但插值变量不再是线性插值中的点坐标表(x, y), 而是把图形曲线上每两个邻近点看成一个矢量，这样就能把由N 个点构成的曲线分解成 N-1 个矢量。初始图形的矢量记为$(a_{0i}， p_{0i})$，终止图形记为$(a_{1i}，p_{1i})$，生成的中间图形记为$(a_{ti}，p_{ti})$,  设生成 M 个画面，则有：</p><p>$$$ a_{ti} &#x3D; a_0<em>t + a_1</em>(1-t);  t&#x3D;1,…M; p_{ti} &#x3D; p_0<em>t + p_1</em>(1-t); $$$</p><p>矢量线性插值代码实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//mode==1:普通矢量线性插值(不规定矢量插值方向)</span><br><span class="line">else if(mode==1)</span><br><span class="line">&#123;</span><br><span class="line">    inter_points.clear();</span><br><span class="line">    double t=1.0*time/grain;</span><br><span class="line">    QPoint temp;</span><br><span class="line">    double x0=start_points[0].x();</span><br><span class="line">    double y0=start_points[0].y();</span><br><span class="line">    double x1=end_points[0].x();</span><br><span class="line">    double y1=end_points[0].y();</span><br><span class="line">    double x=(1-t)*x0+t*x1;</span><br><span class="line">    double y=(1-t)*y0+t*y1;</span><br><span class="line">    temp.setX(x);</span><br><span class="line">    temp.setY(y);</span><br><span class="line">    inter_points.push_back(temp);</span><br><span class="line">    for(int i=0;i&lt;start_vectors.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        double vec_a0=start_vectors[i].a;</span><br><span class="line">        double vec_p0=start_vectors[i].p;</span><br><span class="line">        double vec_a1=end_vectors[i].a;</span><br><span class="line">        double vec_p1=end_vectors[i].p;</span><br><span class="line">        if(vec_a0&lt;0)vec_a0+=2*PI;</span><br><span class="line">        if(vec_a1&lt;0)vec_a1+=2*PI;</span><br><span class="line">        if(vec_a1-vec_a0&gt;PI)vec_a0+=2*PI;</span><br><span class="line">        if(vec_a1-vec_a0&lt;-PI)vec_a1+=2*PI;</span><br><span class="line"></span><br><span class="line">        double vec_a=(1-t)*vec_a0+t*vec_a1;</span><br><span class="line">        double vec_p=(1-t)*vec_p0+t*vec_p1;</span><br><span class="line">        x+=vec_p*cos(vec_a);</span><br><span class="line">        y+=vec_p*sin(vec_a);</span><br><span class="line">        temp.setX(x);</span><br><span class="line">        temp.setY(y);</span><br><span class="line">        inter_points.push_back(temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本次试验中，我还对矢量线性插值进行了三种不同的改良：分别是规定矢量顺时针旋转、规定矢量逆时针旋转以及规定矢量旋转角度小于π。<br>使用控制变量 mode：mode 为 1、2、3 时分别在矢量插值函数代码中插入不同语句。</p><h3 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h3><p>编写paintWindow 类作为画板，继承自 QWidget 类。在 paintWindow 类中编写鼠标回调函数 mousePressEvent，记录通过鼠标交互选定的关键点。以及绘制函数paintEvent，在每次 update()时调用。paintWindow 类定义具体如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class paintWindow : public QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">private:</span><br><span class="line">    int grain;  //每个曲线区间有多少个插值点(包括两端关键点)</span><br><span class="line">    int speed;  //刷新速度(改为int)</span><br><span class="line">    int mode=0; //插值模式</span><br><span class="line">    int pen_index=0;//使用第几种笔刷</span><br><span class="line">    int time;//时间</span><br><span class="line">    QTimer* timer;  //计时器</span><br><span class="line"></span><br><span class="line">    vector&lt;QPoint&gt; start_points;//储存起点帧点坐标</span><br><span class="line">    vector&lt;Vector&gt; start_vectors;//储存起点帧向量</span><br><span class="line">    vector&lt;QPoint&gt; end_points;//储存终点帧点坐标</span><br><span class="line">    vector&lt;Vector&gt; end_vectors;//储存终点帧向量</span><br><span class="line">    vector&lt;QPoint&gt; inter_points;//储存当前插值帧关键点</span><br><span class="line"></span><br><span class="line">    bool start_draw=false; //是否绘制起始帧图像</span><br><span class="line">    bool end_draw=false; //是否绘制终止帧图像</span><br><span class="line"></span><br><span class="line">    bool startframe=true; //是否处于起始帧选定状态</span><br><span class="line">    bool endframe=true; //是否处于终止帧选定状态</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    paintWindow();</span><br><span class="line"></span><br><span class="line">    void change_frame(); //从起始帧切换到终止帧</span><br><span class="line">    void finish_frame(); //结束终止帧交互</span><br><span class="line">    void calc_vectors();  //计算关键帧向量</span><br><span class="line"></span><br><span class="line">    void set_interpolation(int _grain,int _speed, int _mode);  //设置动画参数</span><br><span class="line">    void paintEvent(QPaintEvent *);  //绘制函数</span><br><span class="line">    void mousePressEvent(QMouseEvent *e);  //鼠标回调函数</span><br><span class="line">    int numbers();  //关键点个数</span><br><span class="line">    void change_pen();  //改变笔刷</span><br><span class="line">    void clear(); //清屏</span><br><span class="line">private slots:</span><br><span class="line">    void changeState();  //连接计时器，改变小车坐标，旋转角度等信息</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h3><p>鼠标回调函数 mousePressEvent，记录通过鼠标交互选定的关键点，储存在名为start_points 和 end_points 的vector 中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//鼠标回调函数，鼠标点击，加入关键点</span><br><span class="line">voidpaintWindow::mousePressEvent(QMouseEvent * e)</span><br><span class="line">&#123;</span><br><span class="line">if (startframe)start_points.push_back(e-&gt;pos());</span><br><span class="line">else if (endframe) end_points.push_back(e-&gt;pos());</span><br><span class="line">update();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5"><a href="#5" class="headerlink" title="5."></a>5.</h3><p>绘制函数 paintEvent，根据数据变化，绘制所有的关键点，起始帧图像，以及中间插值图像。(篇幅限制，此处省略部分代码)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">//绘制函数</span><br><span class="line">void paintWindow::paintEvent(QPaintEvent*)</span><br><span class="line">&#123;</span><br><span class="line">QPainter paint(this);</span><br><span class="line">if (start_points.size() &lt;= 0)return; //没有关键点6.</span><br><span class="line">//设置笔刷样式，绘制关键点</span><br><span class="line">paint.setPen(QPen(Qt::black, 5, Qt::DashDotLine, Qt::RoundCap));</span><br><span class="line">for (int i = 0; i &lt; start_points.size(); i++)</span><br><span class="line">paint.drawEllipse(start_points[i], 1, 1);</span><br><span class="line">for (int i = 0; i &lt; end_points.size(); i++)</span><br><span class="line">paint.drawEllipse(end_points[i], 1, 1);</span><br><span class="line">//设置笔刷样式，绘制起点帧图像</span><br><span class="line">//paint.setPen(QPen(Qt::blue,3,Qt::SolidLine,Qt::RoundCap));</span><br><span class="line">if (start_points.size() &gt; 0)</span><br><span class="line">&#123;</span><br><span class="line">if (start_draw)</span><br><span class="line">&#123;</span><br><span class="line">for (unsigned int i = 0; i &lt; start_points.size() - 1; i++)</span><br><span class="line">&#123;</span><br><span class="line">QPoint p1 = start_points[i];</span><br><span class="line">QPoint p2 = start_points[i + 1];</span><br><span class="line">paint.drawLine(p1, p2);</span><br><span class="line">&#125;</span><br><span class="line">QPoint p1 = start_points[0];</span><br><span class="line">QPoint p2 = start_points[start_points.size() - 1];</span><br><span class="line">paint.drawLine(p1, p2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//设置笔刷样式，绘制终点帧图像(省略)</span><br><span class="line">//设置笔刷样式，绘制插值帧图像</span><br><span class="line">//paint.setPen(QPen(Qt::red,3,Qt::DotLine,Qt::RoundCap));</span><br><span class="line">if (time != 0)</span><br><span class="line">&#123;</span><br><span class="line">if (inter_points.size() &gt; 0)</span><br><span class="line">&#123;</span><br><span class="line">for (unsigned int i = 0; i &lt; inter_points.size() - 1; i++)</span><br><span class="line">&#123;</span><br><span class="line">QPoint p1 = inter_points[i];</span><br><span class="line">QPoint p2 = inter_points[i + 1];</span><br><span class="line">paint.drawLine(p1, p2);</span><br><span class="line">&#125;</span><br><span class="line">QPoint p1 = inter_points[0];</span><br><span class="line">QPoint p2 = inter_points[inter_points.size() - 1];</span><br><span class="line">paint.drawLine(p1, p2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6"><a href="#6" class="headerlink" title="6."></a>6.</h3><p>引入QTimer 类作为计时器，每隔一段时间调用 changestate 函数， 在该函数中，改变当前插值图像信息。通过线性插值或者矢量线性插值计算，将当前插值图像的所有关键点坐标储存在名为inter_points 的vector 中。</p><h3 id="7-MainWindow-设计及按钮槽函数"><a href="#7-MainWindow-设计及按钮槽函数" class="headerlink" title="7. MainWindow 设计及按钮槽函数"></a>7. MainWindow 设计及按钮槽函数</h3><p>MainWindow 窗口设计如下：<br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305161456.jpg" alt="图片alt" title="图片title"></p><h2 id="五、-实验结果分析"><a href="#五、-实验结果分析" class="headerlink" title="五、 实验结果分析"></a>五、 实验结果分析</h2><p>分析不同起始帧和终止帧对应不同插值方法的效果和局限性：</p><h3 id="1-普通四边形-几乎不旋转"><a href="#1-普通四边形-几乎不旋转" class="headerlink" title="1)普通四边形(几乎不旋转)"></a>1)普通四边形(几乎不旋转)</h3><p><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305161457.jpg" alt="图片alt" title="图片title"><br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305161458.jpg" alt="图片alt" title="图片title"><br>普通线性插值和第一种矢量线性插值(变换角不大于π)效果都很好，但是规定变换方向为顺时针或者逆时针的则出现了变形问题，通过分析，我找到了原因，这是因为有两条相邻的边，向量旋转方向相反，比如：<br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305161459.jpg" alt="图片alt" title="图片title"></p><p>上图中绿色标注的边终点帧比起点帧的向量角度更小，而蓝色标注的边，则是终点帧比起点帧的向量角度更大，因此在选择向量顺时针插值时，绿色标注的边可以直接选择角度小于π的旋转方式，而蓝色标注的边则会选择大于π的旋转方式(几乎接近旋转一周)，因此导致图像插值过程中变形。</p><h3 id="2-边交叉的四边形-有一定的旋转角度-0-π-x2F-2"><a href="#2-边交叉的四边形-有一定的旋转角度-0-π-x2F-2" class="headerlink" title="2)边交叉的四边形(有一定的旋转角度(0 ~π&#x2F;2))"></a>2)边交叉的四边形(有一定的旋转角度(0 ~π&#x2F;2))</h3><p><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305161460.jpg" alt="图片alt" title="图片title"><br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305161461.jpg" alt="图片alt" title="图片title"></p><p>可以看出上图中四种插值方式的效果都非常好，顺时针向量插值时，图像呈现顺时针转动效果，逆时针插值时效果相反。</p><h3 id="3-小车大小变化-有一定的旋转角度-π-x2F-2-π"><a href="#3-小车大小变化-有一定的旋转角度-π-x2F-2-π" class="headerlink" title="3)小车大小变化(有一定的旋转角度(π&#x2F;2 ~π))"></a>3)小车大小变化(有一定的旋转角度(π&#x2F;2 ~π))</h3><p><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305161462.jpg" alt="图片alt" title="图片title"><br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305161463.jpg" alt="图片alt" title="图片title"></p><p>可以看出上图中直接线性插值方式会产生明显的变形，不能保持形状平滑变化，而其他三种矢量线性插值方式效果都表现得非常好。</p><h3 id="4-箭头图形-旋转角度接近π"><a href="#4-箭头图形-旋转角度接近π" class="headerlink" title="4)箭头图形(旋转角度接近π)"></a>4)箭头图形(旋转角度接近π)</h3><p><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305161464.jpg" alt="图片alt" title="图片title"></p><p>可以看出上图中直接线性插值方式会产生明显的变形，不能保持形状平滑变化，第一种矢量线性插值方式也会产生非常严重的变形， 而规定了顺时针或者逆时针差值的矢量线性插值方式效果表现得非常好。<br>通过分析，我找到了原因，这是因为对第一种矢量线性差之方式， 有两条相邻的边，向量旋转方向在都接近π的情况下，一个比π略小一些，一个比π略大一些，比如：<br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305161465.jpg" alt="图片alt" title="图片title"></p><p>上图中绿色标注的边终点帧比起点帧的向量大一个接近π的值， 于是算法在判断后，认为该边应该逆时针旋转插值，而蓝色标注的边， 则是终点帧比起点帧的向量大一个稍大于π的值(也可以看成是小一个接近π的值)，因此算法在判断后，认为该边应该顺时针旋转。这就导致了相邻的两个向量向着不同的方向旋转，因此导致图像插值过程中变形。</p><h3 id="5-复杂图像的关键帧插值动画"><a href="#5-复杂图像的关键帧插值动画" class="headerlink" title="5)复杂图像的关键帧插值动画"></a>5)复杂图像的关键帧插值动画</h3><p><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305161466.jpg" alt="图片alt" title="图片title"><br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202305161467.jpg" alt="图片alt" title="图片title"></p><p>如上图，可以看出，除了线性插值有明显的变形之外，其他三种矢量差值方式都表现得效果非常好。</p><h3 id="6-分析总结"><a href="#6-分析总结" class="headerlink" title="6)分析总结"></a>6)分析总结</h3><p>没有一种关键帧动画算法可以适用于所有的场景，通过对不同起始帧终止帧图像的情形的实践和分析，我总结出：</p><ol><li>对于方向基本没有变化的初始帧和终止帧，普通线性插值效果非常不错，第一种矢量线性插值算法(规定矢量旋转角度小于π)也表现非常好，第二三种矢量线性插值算法(规定矢量旋转方向为顺时针或者逆时针)则可能会产生较大的变形，原因是相邻两个矢量旋转角度一个大于零一个小于零。</li><li>对于方向有一定变化(0~π)的初始帧和终止帧，普通线性插值算法会使得插值图像有较大的变形(一般情况下，旋转角度大的， 变形程度也会更大)，而三种矢量线性插值算法都表现得效果非常好。</li><li>对于方向变化接近π的初始帧和终止帧，普通线性插值算法也会使得插值图像有较大的变形(一般情况下，旋转角度大的，变形程度也会更大)，第二三种矢量线性插值算法(规定矢量旋转方向为顺时针或者逆时针)也表现非常好，第一种矢量线性插值算法(规定矢量旋转角度小于π)则可能会产生较大的变形，原因是相邻两个矢量旋转角度一个大于π一个小于零π。</li><li>对于方向变化较大(π~2π)的初始帧和终止帧，效果可以参考第二条。</li><li>以上所有总结建立在本实验程序的演示基础上，本实验中产生这些现象的主要原因是，不能保证初始帧和终止帧有完全相同的角度，如果在更多元化的图形化交互界面中，可以将初始帧直接复制放大缩小平移旋转得到终止帧，则每一种矢量线性插值算法都不会产生上述的严重变形现象。</li><li>但是在真正的动画制作中，也不可能保证初始帧和终止帧有完全相同的角度，因此本次实验的分析还是非常具有实际意义的。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Computer Graphics </category>
          
          <category> Computer Animation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Homework </tag>
            
            <tag> Computer Animation </tag>
            
            <tag> KeyFrame </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Relightable Neural Renderer 配置环境记录</title>
      <link href="/2023/05/15/Relightable-Neural-Renderer-%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E8%AE%B0%E5%BD%95/"/>
      <url>/2023/05/15/Relightable-Neural-Renderer-%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>因为项目需要学习了Relightable Neural Rendering， 并尝试把源码下载到本地配置环境运行，被pytorch环境折磨的不轻，把最后成功的过程在这里放一下。<br><br>原仓库中记录的环境是<code>Ubuntu 16.04 + CUDA 9.0 + gcc 4.9.2 + Anaconda 3</code>，但因为手边没有合适的Linux服务器，所以使用windows环境配置，版本太老的cuda目前已经找不到合适的pytorch支持，最后使用的环境是<code>window 10 + python3.9.16 + pytorch 1.13.0 + cuda 11.7 + anaconda 3</code>，在两台windows系统电脑上都成功跑通了：一台是双3090，一台是1650。<br></p><span id="more"></span><ul><li>原Github仓库地址：<a href="https://github.com/LansburyCH/relightable-nr">https://github.com/LansburyCH/relightable-nr</a></li></ul><h3 id="环境配置过程"><a href="#环境配置过程" class="headerlink" title="环境配置过程"></a>环境配置过程</h3><p>原仓库提供的environment环境文件太过杂乱，有很多不必要一一匹配的包，并且其中有很多版本都太老了已经无从下载，因此安装的时候就没有管这个environment了。<br>首先在官网安装cuda11.7版本，anaconda新建一个python3.9的环境，安装pytorch1.13.0，安装命令为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install pytorch==1.13.0 torchvision==0.14.0 torchaudio==0.13.0 pytorch-cuda=11.7 -c pytorch -c nvidia</span><br></pre></td></tr></table></figure><ul><li>安装旧版本的pytorch指令集：<a href="https://pytorch.org/get-started/previous-versions/">https://pytorch.org/get-started/previous-versions/</a></li></ul><p>安装后需要进行的步骤为：</p><ol><li>安装opencv：<code>conda install opencv</code></li><li>安装trimesh：<code>conda install -c conda-forge trimesh</code></li><li>安装torch-geometric。这里参考了：<a href="https://blog.csdn.net/xiangfengl/article/details/120254867#%E5%AE%89%E8%A3%85torch-%20geometric">https://blog.csdn.net/xiangfengl/article/details/120254867#%E5%AE%89%E8%A3%85torch-%20geometric</a><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pip install torch-scatter -f https://pytorch-geometric.com/whl/torch-1.13.0%2Bcu117.html</span><br><span class="line">pip install torch-sparse -f https://pytorch-geometric.com/whl/torch-1.13.0%2Bcu117.html</span><br><span class="line">pip install torch-cluster -f https://pytorch-geometric.com/whl/torch-1.13.0%2Bcu117.html</span><br><span class="line">pip install torch-spline-conv -f https://pytorch-geometric.com/whl/torch-1.13.0%2Bcu117.html</span><br><span class="line">pip install torch-geometric</span><br></pre></td></tr></table></figure></li><li><code>pip install pyshtools</code></li><li><code>pip install openexr</code></li><li><code>conda install tensorboardX</code></li><li><code>pip install pytorch_msssim</code></li></ol><h3 id="与此同时，源码需要做的修改："><a href="#与此同时，源码需要做的修改：" class="headerlink" title="与此同时，源码需要做的修改："></a>与此同时，源码需要做的修改：</h3><ol><li>nerural-renderer模块中，rasterize_cuda_kernel.cu中，将<br><code>#if  __CUDA_ARCH__ &lt; 600 and defined(__CUDA_ARCH__)</code>修改为<code>#if  __CUDA_ARCH__ &lt; 600 &amp;&amp; defined(__CUDA_ARCH__)</code>。</li><li>将源码cuda文件夹下所有的代码中的<code>AT_CHECK</code>替换为<code>TORCH_CHECK</code>。</li><li>在precompute.py, stitch_lp.py, train_rnr.py三个文件开头添加：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">os.environ[&#x27;OPENCV_IO_ENABLE_OPENEXR&#x27;] = &#x27;TRUE&#x27;</span><br></pre></td></tr></table></figure></li><li>将<code>np.int</code>修改为<code>np.int_</code></li><li>由于在windows系统下，将<code>num_workers = 8</code>修改为<code>num_workers = 0</code>。</li><li>把train_rnr.py 中的 <code>if opt.exp_name is not &#39;&#39;:</code> 修改为 <code>if opt.exp_name != &#39;&#39;:</code></li><li>使用windows系统，需要把sh文件修改为bat文件，在线转换工具：<a href="https://daniel-sc.github.io/bash-shell-to-bat-converter/">https://daniel-sc.github.io/bash-shell-to-bat-converter/</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Relighting Project </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rendering </tag>
            
            <tag> Neural Rendering </tag>
            
            <tag> Relighting </tag>
            
            <tag> Anaconda </tag>
            
            <tag> Pytorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pytorch学习笔记</title>
      <link href="/2023/05/08/Pytorch-Notes/"/>
      <url>/2023/05/08/Pytorch-Notes/</url>
      
        <content type="html"><![CDATA[<p>Pytorch小白学习。</p><span id="more"></span><ol><li>U-net网络结构：</li></ol><ul><li><a href="https://zhuanlan.zhihu.com/p/313283141">https://zhuanlan.zhihu.com/p/313283141</a></li></ul><ol start="2"><li>nn.ReplicationPad3d</li></ol><ul><li>使用输入边界的复制对输入张量进行填充。</li><li>Parameters</li><li><ul><li>padding(int,tuple)–填充的大小。如果是int，则在所有边界中使用相同的填充。如果是6 tuple，则使用(padding_left,padding_right, padding_top, padding_bottom, padding_front, padding_back )</li></ul></li></ul><ol start="3"><li>torch.nn.Conv3D</li></ol><ul><li>3D卷积, 输入的shape是(N, C_{in}, D, H, W) (N, C_{in}, D, H, W)(N, C_{in}, D, H, W)，输出shape(N, C_{out}, D_{out}, H_{out}, W_{out})</li><li>其中，就是batch_size；C_{in}对应着输入图像的通道数，比如RGB图像通道数为3；D为深度，H、W则是tensor的长宽。</li></ul><ol start="4"><li><p>torch.nn.BatchNorm3d</p></li><li><p>torch.nn.LeakyReLU</p></li><li><p>pytorch中的relu,sigmiod,tanh等激励函数(激活函数）： <a href="https://blog.csdn.net/weixin_44912159/article/details/104994863">https://blog.csdn.net/weixin_44912159/article/details/104994863</a></p></li><li><p>train()和eval()模式的区别</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Relighting Project </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GPU </tag>
            
            <tag> Pytroch </tag>
            
            <tag> Machine Learing </tag>
            
            <tag> Nerual Rendering </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机中的颜色管理知识(有待补充更新)</title>
      <link href="/2023/04/24/Color-Management/"/>
      <url>/2023/04/24/Color-Management/</url>
      
        <content type="html"><![CDATA[<p>颜色管理是图形学中一个非常重要的课题，图形学与图像和颜色的可视化息息相关，但是我们有时候追求的是储存元数据的信息，有时候又追求的是图像看上去合理，符合美术工作人员的期待。不同的显示器、不同的颜色空间管理以及不同的人眼都会产生颜色的感知偏差。</p><span id="more"></span><h3 id="一、Gamma-矫正"><a href="#一、Gamma-矫正" class="headerlink" title="一、Gamma 矫正"></a>一、Gamma 矫正</h3><p>Gamma矫正最初是为了适应CRT显示器的非线性输出问题，目前存在则是主要为了适应人眼的非线性感知问题。<br>CRT显示器的非线性输出具体来说是，如果输入一个0.5的值到显示器，显示器会呈现出0.218的值。<br>现在的Gamma矫正大多是为了拟合人眼的感知曲线，人眼对暗部细节的感知更加丰富，因此使用gamma矫正在储存图像时，相当于对源数据的暗部进行了展开，亮部进行了压缩，这样能储存更丰富的暗部细节信息。但<strong>gamma矫正本质上是一种编码格式，并不应该影响实际的数据</strong>，比如源数据在储存为RGB格式时做了gamma矫正，那么在从RGB文件中读取时要做反gamma矫正重新映射回源数据。<br>另外，由于历史遗留原因，我们使用的大部分显示器，仍然沿袭CRT显示器的这种非线性输出，也就是我们再把数据传递给显示器时需要做一个类似gamma矫正的变换，而显示器则会做一个类似CRT显示器的反gamma变换。</p><h3 id="二、不同的Color-Space以及其换算"><a href="#二、不同的Color-Space以及其换算" class="headerlink" title="二、不同的Color Space以及其换算"></a>二、不同的Color Space以及其换算</h3><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ol><li>Games101-Lecture 20-Color and Perception</li></ol>]]></content>
      
      
      <categories>
          
          <category> Computer Graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Color </tag>
            
            <tag> Color Space </tag>
            
            <tag> Gamma Correction </tag>
            
            <tag> Tone Mapping </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shadow Rendering 阴影绘制方法的发展过程</title>
      <link href="/2023/03/29/Shadow-Rendering/"/>
      <url>/2023/03/29/Shadow-Rendering/</url>
      
        <content type="html"><![CDATA[<p>课程名称：计算机图形学（研究生）<br>报告主题：图形处理器(GPU)的历史、现状和展望<br>提交日期：2023 年 1 月 1 日</p><span id="more"></span><h3 id="渲染技术研究报告——阴影绘制技术的发展历程及方法比较"><a href="#渲染技术研究报告——阴影绘制技术的发展历程及方法比较" class="headerlink" title="渲染技术研究报告——阴影绘制技术的发展历程及方法比较"></a>渲染技术研究报告——阴影绘制技术的发展历程及方法比较</h3><h4 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h4><p>阴影绘制是真实感渲染中非常重要的一个模块，对提高场景的真实度有着至关重要的作用，不管是使用光栅化的流程还是光线追踪的流程进行场景绘制，阴影绘制的技术都经过了多次的更新和迭代。我也在一些课程中学习过一些简单的阴影绘制方法，因此想借此机会对所有的阴影绘制方法做一个系统性的梳理和总结。阴影绘制的方法按照时间发展顺序主要有Shadow Volume算法、Shadow Map算法、PCF算法、PCSS算法、VSM算法等等。<br><br>首先，阴影的定义是Shadow is the region of space for which at least on point of the light source is occluded，也就是绘制中那些至少对一盏光源，其没有被直接照亮而是被其他物体遮挡住的区域。<br><br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202303292041.jpg" alt="图片alt" title="图片title"><br>图源Real-Time Rendering 4th<br>如上图所示，要实现阴影的绘制，需要考虑的有光源、遮挡物（Occluder）、接受物（Receiver）、本影区（umbra）半影区（penumbra）等。<br><br>其中，对于接收物体是平面的情况，我们可以直接通过光源位置、物体几何等信息进行光线求交几何计算，解析地得到平面上阴影的形状和范围（如下图），但是这显然无法处理复杂的场景阴影绘制，也不是我们需要的通用的方法，也因此本文仍然选择聚焦于在任何曲面或者几何体上产生阴影的通用方法。<br><br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202303292042.jpg" alt="图片alt" title="图片title"><br>图源Real-Time Rendering 4th</p><h4 id="二、Shadow-Volume算法诞生及其改进"><a href="#二、Shadow-Volume算法诞生及其改进" class="headerlink" title="二、Shadow Volume算法诞生及其改进"></a>二、Shadow Volume算法诞生及其改进</h4><p><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202303292043.jpg" alt="图片alt" title="图片title"><br>图源Real-Time Rendering 4th<br>Shadow Volume是Franklin在1977年提出的阴影绘制算法，虽然在今天这个算法由于其较大的开销已经不太被使用，但我们仍然可以从中学到一些基础的思维方式，并且由于该算法不是在图像空间进行的，因此不会像Shadow Map一样收到采样的影响。<br><br>Shadow Volume算法的基本思想是对于投影物体（以一个三角形为例），以光源为出发点建立一个类似金字塔的无限延伸的体积结构，并切除在光源点和投影物体之间的部分。所有包含在剩余体积范围内的区域都处在阴影中。<br><br>对于场景中的所有物体，都可以使用该方法建立其投影金字塔。在正常绘制场景时，对于每一哥Fragment，都需要遍历所有的投影金字塔，计算其是否被包含在其中并记录被包含的次数。被包含的越多，则该处阴影强度越大（阴影颜色更暗）。以此类推，绘制完成所有的Fragment。可想而知，对于较为复杂的场景，Shadow Volume方法需要的时间和空间开销都是巨大的，不仅需要管理每一个投影物体的投影金字塔，还需要对任何一个片元进行所有金字塔的遍历测试。如果场景中包含N个物体，且都可以投射阴影，则该算法的时间复杂度将达到O(n²)。<br></p><h4 id="三、Shadow-Map算法的诞生及其改进"><a href="#三、Shadow-Map算法的诞生及其改进" class="headerlink" title="三、Shadow Map算法的诞生及其改进"></a>三、Shadow Map算法的诞生及其改进</h4><p>早在 1968年，Arthur Appel就在研究隐藏面消除时提出了光线投射算法（Ray Casting），并首次给出了光线跟踪算法的描述。其具体思路是从每一个像素射出一条射线，然后找到最接近的物体挡住射线的路径，而视平面上每个像素的颜色取决于从可见光表面产生的亮度。<br></p><p>1974年，Catmull为了解决消隐问题提出了Z-Buffer算法，该算法的主要思路是使用一个屏幕空间的缓存，记录每一个像素点所对应的最小深度，在绘制每一个多边形时，与对应像素位置的当前最小深度做对比，如果小于该值则证明该多边形可见，绘制并更新Z-Buffer。Z-Buffer算法思路简单且通用性较好，为之后图形学的许多技术提供了理论基础。<br></p><p>因此在1978年，William以Z-Buffer算法为基础，提出了Shadow Map算法，主要思想就是维护一个从光源看出的Z-Buffer（也就是Shadow Map）。能从光源出发直接看到的区域就不属于阴影，否则属于阴影。<br><br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202303292044.jpg" alt="图片alt" title="图片title"><br>图源【3】<br>Shadow Map是一个2-pass的算法。算法主要步骤为：<br></p><ol><li>第一个pass：以光源为视点出发绘制场景，只需要绘制深度信息，像Z-Buffer算法一样记录屏幕空间上每一个像素点的最小深度，得到 Shadow Map。</li><li>第二个Pass：正常绘制场景。</li></ol><ul><li>在每个像素绘制时通过坐标转换，计算出其在光源坐标系下对应的屏幕坐标。</li><li>如果其在光源坐标系下的深度在浮点数精度下小于等于Shadow Map上对应位置的当前值，则证明该点被光源直接照亮，否则证明该点在阴影中。<br>其中，需要做的坐标转换为：首先根据片元当前的屏幕坐标，乘以当前相机投影矩阵的逆矩阵得到其世界坐标，再根据光源坐标系下的投影矩阵计算出在Shadow Map的屏幕坐标。其中，对于太阳光这样的平行光我们需要使用平行投影方式绘制Shadow Map，而对于点光源则应该使用透视投影绘制Shadow Map。<br><br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202303292045.jpg" alt="图片alt" title="图片title"><br>图源Real-Time Rendering 4th</li></ul><p>不难想到，如何选择Shadow Map绘制的视口是一个至关重要的问题，如果光源坐标系下的视口刚好可以包含正常绘制时所有能看到的物体，如上图中所示，则算法可行，否则可能会出现正常绘制时的某些Fragment对应的光源坐标系下的坐标超过视口范围，在Shadow Map上没有对应点，无法判断是否属于阴影的情况。另外，对于在场景中间的点光源（在不同方向上都可能投射阴影），则一般选择使用一个six-view cude，分别绘制不同方向上的Shadow Map。但这样的解决方法同样也带来了不同view交界处的走样问题。<br></p><p>Shadow Map算法的效果很大程度上受限于 Shadow Map的分辨率，因此在绘制Shadow Map时进行场景物体的剔除和剪枝也是十分有必要的，对于那些在相机中不可见的物体，在Shadow Map中也不需要绘制，这样可以有效缩小Shadow Map绘制的范围，从而对同样分辨率的Shadow Map达到更高的利用率和绘制精度。<br><br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202303292046.jpg" alt="图片alt" title="图片title"><br>图源Real-Time Rendering 4th</p><p>但是普通的Shadow Map算法不可避免地存在着问题，主要的两个问题有自遮挡问题（“surface acne”）和锯齿状走样问题。<br><br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202303292047.jpg" alt="图片alt" title="图片title"><br>图源网络</p><p>其中，自遮挡问题产生的原因是如下图，在从灯光出发进行Shadow Map绘制时，视线方向与接收投影的平面方向存在夹角，但是绘制时仅采样了像素中心的深度值作为整体的深度值。在第二个pass比较深度是就会出现本来同一平面但是有部分像素通不过Shadow Map的深度测试这种情况，从而导致如下图所示的阴影错误。对该问题可以使用设置比较的bias来尝试解决，但是bias过小时不能完全避免这种错误的产生，过大时又会产生如下图中右边所示的阴影和物体不贴合的错误（被称为Light Leaks 或者 Peter Panning），出现物体悬浮的绘制效果。<br><br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202303292048.jpg" alt="图片alt" title="图片title"><br>图源Real-Time Rendering 4th</p><p>另外一个解决Self-shadowing自遮挡问题的思路是修改绘制Shadow Map的过程，比如说绘制时进行面剔除（Face Culling），仅绘制模型的背面。这种方法在物体都是流形时（拥有背面和反面）效果较好，能很好地避免surface acne问题。但是无法处理某些模型只有单个面的情况。一种沿着这个思路的改进方法是Second-depth Shadow Map，是在绘制Shadow Map时选择front face和back face的中间值作为Shadow Map的采样值。<br><br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202303292049.jpg" alt="图片alt" title="图片title"><br>图源Real-Time Rendering 4th</p><p>而另一个问题锯齿状走样本质上还是由于Shadow Map的分辨率限制导致的，由于Shadow Map的绘制视口与相机绘制视口不同，可能会导致在相机坐标系下占很大部分的空间在Shadow Map中仅仅对应几个像素，因而导致其不能完全表达出该部分的相互遮挡信息，正常绘制时的较大区域可能整体无法通过Shadow Map的深度测试，产生锯齿状走样。<br></p><p>为了解决分辨率不够导致的锯齿状走样问题，Nvdia提出了CSM算法（Cascaded Shadow Maps），也就是使用级联的阴影贴图。其主要思想就是通过物体的距离，动态地进行不同分辨率的Shadow Map的绘制，比如说对远处的物体采用分辨率较小的Shadow Map，而对于较近处的物体则采用分辨率较大Shadow Map。LearnOpenGL中提供了一种基本的思路：<br><br>首先使用相机的视图和投影矩阵，反向计算出它所定义的视锥体在世界坐标系下的位置，然后将其划分为 n 个子视锥体，其中第i个截锥体的远平面是第i+1个截锥体的近平面。然后对于每一个截锥体中的物体依次渲染一张Shadow Map，在正常绘制时，则同样根据Fragment的Z值计算其应该属于哪一个截锥体，从而选取不同的Shadow Map。<br><br>需要注意的一点是，如果某个物体不在相机视锥体内，但在光源和某个截锥体之间，则绘制Shadow Map时也需要对其进行考虑，否则也会造成阴影绘制的错误。<br></p><h4 id="四、PCF算法-amp-PCSS算法"><a href="#四、PCF算法-amp-PCSS算法" class="headerlink" title="四、PCF算法&amp;PCSS算法"></a>四、PCF算法&amp;PCSS算法</h4><p>普通的Shadow Map只能得到非零即一的阴影测试值，只能绘制硬阴影，这显然不能满足我们真实感渲染的需求，因此在1987年，William T. Reeves引入了本来用于做抗锯齿的PCF算法（Percentage Closer Filter）到阴影绘制领域，在此基础上改良得到Shadow Map算法得到了PCSS算法。<br><br>该算法的基本思想是对深度测试的结果进行Filter（而不是直接对Shadow Map进行filter）。具体操作方法是：在第二个Pass进行正常绘制时，对于每一个Fragment的深度测试，不仅比较直接对应的Shadow Map像素，还要与其邻域内（比如说3*3）像素进行深度测试，小于等于（表示不在阴影中）则记为0，大于则记为1，得到一个01的矩阵，对其求平均得到一个0-1之间的浮点数值，则代表该像素的阴影值，这样就能实现软阴影的效果。<br><br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202303292050.jpg" alt="图片alt" title="图片title"><br>图源【7】<br>在以上这种思想的指导下我们不难发现，filter的邻域大小一定程度决定了得到的阴影边缘的平滑程度，也就是邻域越大越容易得到“软”阴影。而在生活中，当投影物体靠近接收物体时，我们得到的阴影边缘更硬，反之则较软。以此为指导，Fernando在2005年提出的PCSS算法是在PCF进行阴影绘制基础上的进一步改进。其主要思想是使用如下图所示的几何关系来估计半影区（Penumbra）的宽度（也就是阴影的软硬程度）。其中$d_blocker$指的是投影物体的深度也就是Shadow Map中储存的深度，$d_receiver$指的是接收物体的深度也就是当前片元的深度。而用此方法计算出的半影区的宽度可以指导我们进行PCF中filter邻域大小的选择。<br><br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202303292051.jpg" alt="图片alt" title="图片title"><br>图源【8】</p><p>PCSS算法的主要流程为：</p><ol><li>Blocker Search</li></ol><ul><li>在一个小的邻域内采样得到投影物体的平均深度。</li></ul><ol start="2"><li>Penumbra Estimation</li></ol><ul><li>根据投影物体的平均深度和当前片元的深度计算半影区的宽度。</li></ul><ol start="3"><li>Percentage Closer Filtering</li></ol><ul><li>根据计算出的半影区的宽度选定filter的邻域大小并进行PCF计算。<br>其中，在第一步进行投影物体深度的采样时，采样区域的大小可以用下图所示的这种方式选定，也就是根据投影物体的深度和光源的大小计算选定。<br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202303292052.jpg" alt="图片alt" title="图片title"><br>图源【8】</li></ul><h4 id="五、VSM算法和VSSM算法"><a href="#五、VSM算法和VSSM算法" class="headerlink" title="五、VSM算法和VSSM算法"></a>五、VSM算法和VSSM算法</h4><p>VSM算法全称为Variance Shadow Mapping，VSSM算法全称为Variance Soft Shadow Mapping，这两种算法相互承袭，是一种使用统计学知识对PCSS算法的改进方案，其主要的思路是通过对Shadow Map中Block内的深度分布进行统计学估计，避免大量采样计算PCF的过程，从而加快阴影绘制速度。<br><br>PCF算法的基本思想就是在某一个邻域内测试有百分之多少的像素能使得当前片元通过深度测试。也就是测试当前片元的深度在该邻域内分布在百分之多少。VSSM算法引入了统计学的知识，假设当前邻域内的深度分布符合高斯分布，如果要测试当前片元的深度在该邻域内分布在百分之多少，只需要知道当前分布的均值和方差。<br><br>对于深度图邻域内均值的计算，我们可以自然地联想到对Shadow Map进行Mipmap查询。而对于方差的计算，VSM引入了以下的公式，因此我们只需要在绘制Shadow Map的同时绘制一个储存深度的平方的map。<br><br>$var(x)&#x3D;E(x^2),-E^2(x)$<br><br>这样在Shadow Map绘制完成后，对于其上的每一个点我们都能通过均值和方差得到该位置的一个深度的近似分布情况，从而可以根据当前片元的值，计算出其CDF。另外，VSM算法还引入了切比雪夫不等式（如下），只需要知道分布的期望和方差，就可以计算出x大于某个固定值的概率。<br><br>$P(x&gt;t)≤σ^2&#x2F;(σ^2+(t-μ)^2)$<br><br>切比雪夫不等式成立的条件是$t＞μ$，也就是当前的$d＞z_avg$。也就说如果Block内的平均深度小于当前Fragment的深度，就不能使用这种估计方法。<br></p><p>上面这种从统计学出发的估计解决了PCSS算法中的第三个步骤也就是PCF计算，但是PCSS算法中的第一个步骤Blocker Search仍然会耗费较长的时间，因此VSSM算法针对性地提出了估计方案。<br><br>对于一个Block，第一个步骤Block Search的目标是估计其中遮挡物的平均深度，我们可以设Block中的像素总数为N，平均深度为$Z_avg$，深度小于当前值（遮挡物）的像素数为N1，平均深度为$Z_occ$，深度大于当前值（接收物体）的像素数为N2，平均深度为$Z_unocc$。则可以得到等式：<br><br>$N_1&#x2F;N Z_unocc+N_2&#x2F;N Z_occ&#x3D;Z_avg$<br><br>不难看出，N_1&#x2F;N就是非遮挡物所占比例，也就可以转化为P（X≥t）。则上式可以转化为：<br><br>$P(x≥t) z_unocc+(1.0-P(x≥t)) z_occ&#x3D;z_avg$<br><br>要计算遮挡物的平均深度，可以使用：<br><br>$Z_occ&#x3D;(z_avg-P(x≥t) z_unocc)&#x2F;(1.0-P(x≥t))$<br><br>而其中的$Z_avg$可以通过Mipmap得到，因此VSSM假设非遮挡物的深度都是t，从而可以计算出遮挡物的平均深度，这种假设的理论依据是一般的接收物体都是一个平面。而对于那些不是一个平面的阴影接收物体，以及切比雪夫不成立的情况，VSSM这篇论文则提出了分治的解决方案。对不满足$d&gt;z_avg$的Block，将其分割为更小的sub-Block，再进行阴影的绘制计算。<br><br>具体的分治思路是，对于那些$z_avg＜d$的sub-Block，我们之前使用切比雪夫不等式的估计仍然是有效的，但是对于那些$z_avg≥d$的sub-Block，论文中选择了直接使用普通的PCSS算法进行阴影的绘制。其原因是论文认为分治之后的sub-Block较小，可以使用传统的PCF采样进行计算。论文使用类似四叉树的结构进行分治之后Block的管理和遍历。<br></p><h4 id="六、MSM算法"><a href="#六、MSM算法" class="headerlink" title="六、MSM算法"></a>六、MSM算法</h4><p>MSM算法全称为Moment Shadow Mapping。是Christoph Peters在2015年提出的一种阴影绘制方式。<br><br>MSM实际上是在VSSM算法的基础上，对使用统计学思想逼近Depth Map的分布进行阴影绘制这种想法的延续。VSSM算法中，仅仅使用到了Depth的平均值和方差（也就是一阶矩和二阶矩）去估计深度的分布情况，这显然是可能产生偏差的，比如说对于下图中右边这种深度的分布，集中分布在几个固定的值附近，这样的情况使用切比雪夫不等式去估计就会出现比较大的误差。<br><br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202303292053.jpg" alt="图片alt" title="图片title"><br>图源Games202<br>而为了让VSM中对分布的描述更加精确，Christoph Peters提出了使用高阶矩来描述分布的方法。如下图，蓝色表示真正的深度分布CDF，如果使用VSSM算法则只能对CDF逼近到红色线条的程度，而如果使用前四阶矩则能逼近到绿色线段的程度，这样能使得我们对深度分布的估计更精确，对PCF进行近似计算也就更精确。<br><br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202303292054.jpg" alt="图片alt" title="图片title"><br>图源【13】<br>Christoph的测试表明，相对于VSM和ESM算法，MSM算法能提供更小的Shadow绘制误差（如下图）。<br><br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202303292055.jpg" alt="图片alt" title="图片title"><br>图源【13】</p><h4 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h4><p>在当前的渲染领域，由于时序上降噪技术的引入，实时的光线追踪技术成为了可能，因此目前传统的阴影绘制方法或许没有像之前那样应用这么广泛，但是在顺着这条发展路径学习的过程中，我对渲染的一些理解仍然能加深，并且获得新的启发。传统渲染方式虽然在一定程度上是某个时代算力限制的产物，但是其中蕴含的思考方式和优化方法，相信仍然能在未来的学习中给我带来灵感和启发。<br></p><h5 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h5><ol><li>Tomas Akenine-Möller, Eric Haines, Naty Hoffman, Angelo Pesce, Michał Iwanicki, and Sébastien Hillaire,T.  Real-Time Rendering 4rd Edition[M]. Natick, MA, USA: A. K. Peters, Ltd., 2020. </li><li>Catmull, E., “A Subdivision Algorithm for Computer Display of Curved Surfaces,” PhD. thesis, Dept. of Computer Science, University of Utah, 1974.</li><li>Lance Williams. 1978. Casting curved shadows on curved surfaces. SIGGRAPH Comput. Graph. 12, 3 (August 1978), 270–274. <a href="https://doi.org/10.1145/965139.807402">https://doi.org/10.1145/965139.807402</a></li><li>Y. Wang and S. Molnar. Second-depth shadow mapping.  Technical Report TR94-019, Department of Computer Science, University of North Carolina - Chapel Hill, Dec. 1994.</li><li>Fernando, S. Fernandez, K. Bala, and D. P. Greenberg. Adaptive shadow maps. In SIGGRAPH 2001 Conference Proceedings, pages 387–390, 2001.</li><li>M. Stamminger and G. Drettakis. Perspective shadow maps. ACM Transactions on Graphics, 21(3):557–562, July 2002.</li><li>William T. Reeves, David H. Salesin, and Robert L. Cook. 1987. Rendering antialiased shadows with depth maps. SIGGRAPH Comput. Graph. 21, 4 (July 1987), 283–291. <a href="https://doi.org/10.1145/37402.37435">https://doi.org/10.1145/37402.37435</a></li><li><a href="https://developer.download.nvidia.com/shaderlibrary/docs/shadow_PCSS.pdf">https://developer.download.nvidia.com/shaderlibrary/docs/shadow_PCSS.pdf</a></li><li>William Donnelly and Andrew Lauritzen. 2006. Variance shadow maps. In Proceedings of the 2006 symposium on Interactive 3D graphics and games (I3D ‘06). Association for Computing Machinery, New York, NY, USA, 161–165. <a href="https://doi.org/10.1145/1111411.1111440">https://doi.org/10.1145/1111411.1111440</a></li><li><a href="https://developer.download.nvidia.com/SDK/10.5/opengl/src/cascaded_shadow_maps/doc/cascaded_shadow_maps.pdf">https://developer.download.nvidia.com/SDK/10.5/opengl/src/cascaded_shadow_maps/doc/cascaded_shadow_maps.pdf</a></li><li>Salvi, Marco, “Rendering Filtered Shadows with Exponential Shadow Maps,” in Wolfgang Engel, ed., ShaderX6, Charles River Media, pp. 257–274, 2008.</li><li>Yang, B., Dong, Z., Feng, J., Seidel, H.-P. and Kautz, J. (2010), Variance Soft Shadow Mapping. Computer Graphics Forum, 29: 2127-2134. <a href="https://doi.org/10.1111/j.1467-8659.2010.01800.x">https://doi.org/10.1111/j.1467-8659.2010.01800.x</a></li><li>Christoph Peters and Reinhard Klein. 2015. Moment shadow mapping. In Proceedings of the 19th Symposium on Interactive 3D Graphics and Games (i3D ‘15). Association for Computing Machinery, New York, NY, USA, 7–14. <a href="https://doi.org/10.1145/2699276.2699277">https://doi.org/10.1145/2699276.2699277</a></li><li>Lingqi Yan. Games202 Lecture3&amp;Lecture4.</li><li><a href="https://zhuanlan.zhihu.com/p/384446688">https://zhuanlan.zhihu.com/p/384446688</a></li><li><a href="https://zhuanlan.zhihu.com/p/478472753">https://zhuanlan.zhihu.com/p/478472753</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Computer Graphics </category>
          
          <category> Rendering </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Homework </tag>
            
            <tag> Rendering </tag>
            
            <tag> Shadow </tag>
            
            <tag> Shadow Map </tag>
            
            <tag> PCF </tag>
            
            <tag> PCSS </tag>
            
            <tag> VSM </tag>
            
            <tag> MSM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rendering框架及发展历史总结(待补充)</title>
      <link href="/2023/03/28/Rendering-History/"/>
      <url>/2023/03/28/Rendering-History/</url>
      
        <content type="html"><![CDATA[<h2 id="真实感渲染"><a href="#真实感渲染" class="headerlink" title="真实感渲染"></a>真实感渲染</h2><h3 id="光照模型-Illumination-Model"><a href="#光照模型-Illumination-Model" class="headerlink" title="光照模型 Illumination Model"></a>光照模型 Illumination Model</h3><ul><li>灯光</li><li>阴影</li></ul><h3 id="基于物理的材质-Material"><a href="#基于物理的材质-Material" class="headerlink" title="基于物理的材质 Material"></a>基于物理的材质 Material</h3><ul><li>明暗</li><li>纹理</li><li>透明</li><li>一种标准的基本属性主要是Metallic-Roughness，另一种标准是Specular-Glossiness，前者对设计师更友好，后者侧重物理属性，保留了反射率F0。</li></ul><h3 id="光栅化-Rasterization"><a href="#光栅化-Rasterization" class="headerlink" title="光栅化 Rasterization"></a>光栅化 Rasterization</h3><h3 id="光线追踪"><a href="#光线追踪" class="headerlink" title="光线追踪"></a>光线追踪</h3><h3 id="消隐技术"><a href="#消隐技术" class="headerlink" title="消隐技术"></a>消隐技术</h3><h3 id="全局光照（Global-Illumination）"><a href="#全局光照（Global-Illumination）" class="headerlink" title="全局光照（Global Illumination）"></a>全局光照（Global Illumination）</h3><h3 id="后处理"><a href="#后处理" class="headerlink" title="后处理"></a>后处理</h3><h3 id="DLSS"><a href="#DLSS" class="headerlink" title="DLSS"></a>DLSS</h3><h2 id="光照模型"><a href="#光照模型" class="headerlink" title="光照模型"></a>光照模型</h2><h3 id="局部光照模型"><a href="#局部光照模型" class="headerlink" title="局部光照模型"></a>局部光照模型</h3><ul><li>Lambert漫反射模型</li><li>Gourand光照模型</li><li>Phong光照模型</li><li>Blinn-Phong光照模型</li><li>Cook-Torrance模型</li></ul><h3 id="全局光照模型"><a href="#全局光照模型" class="headerlink" title="全局光照模型"></a>全局光照模型</h3><ul><li><p>光线追踪</p><ul><li><p>路径追踪</p></li><li><p>递归光线追踪 whitted-type</p></li><li><p>分布式光线追踪 distrubution</p></li><li><p>双向路径追踪 Bidirectional Path</p><ul><li><a href="https://graphics.stanford.edu/courses/cs348b-03/papers/veach-chapter10.pdf">https://graphics.stanford.edu/courses/cs348b-03/papers/veach-chapter10.pdf</a></li></ul></li><li><p>Metropolis</p></li><li><p>光子映射 Photon Mapping</p></li><li><p>基于点的全局光照</p></li></ul></li><li><p>辐射度算法</p></li><li><p>光子映射</p></li></ul><h2 id="Other-Topic"><a href="#Other-Topic" class="headerlink" title="Other Topic"></a>Other Topic</h2><h3 id="Ray-Marching"><a href="#Ray-Marching" class="headerlink" title="Ray Marching"></a>Ray Marching</h3><h3 id="Percentage-Closer-Soft-Shadows-PCSS"><a href="#Percentage-Closer-Soft-Shadows-PCSS" class="headerlink" title="Percentage Closer Soft Shadows (PCSS)"></a>Percentage Closer Soft Shadows (PCSS)</h3><h2 id="大事记-amp-原文引用"><a href="#大事记-amp-原文引用" class="headerlink" title="大事记&amp;原文引用"></a>大事记&amp;原文引用</h2><h3 id="1760"><a href="#1760" class="headerlink" title="1760"></a>1760</h3><ul><li>Johann Heinrich Lambert在其著作Photometria中提出Lambert模型。</li><li>Half-Lambert是Valve公司提出来的算法，为了解决Lambert公式在灰面太暗的问题。”Half Lambert” lighting is a technique first developed in the original Half-Life.</li></ul><h3 id="1967"><a href="#1967" class="headerlink" title="1967"></a>1967</h3><ul><li><p>Siggraph（Special Interest Group for Computer GRAPHICS，计算机图形图像特别兴趣小组）成立</p></li><li><p>光照模型：Wylie等人第一次在显示物体时加入了光照效果。该论文提出，物体表面上一点接收到的光强，与该点到光源距离的平方成反比，且与光照方向和表面发现的夹角有关。</p><ul><li>Chris Wylie, Gordon Romney, David Evans, and Alan Erdahl. 1967. Half-tone perspective drawings by computer. In Proceedings of the November 14-16, 1967, fall joint computer conference (AFIPS ‘67 (Fall)). Association for Computing Machinery, New York, NY, USA, 49–58. <a href="https://doi.org/10.1145/1465611.1465619">https://doi.org/10.1145/1465611.1465619</a></li></ul></li></ul><h3 id="1968"><a href="#1968" class="headerlink" title="1968"></a>1968</h3><ul><li><p>Arthur Appel 在研究隐藏面消除时提出了光线投射算法（Ray Casting），并首次给出了光线跟踪算法的描述。其具体思路是从每一个像素射出一条射线，然后找到最接近的物体挡住射线的路径，而视平面上每个像素的颜色取决于从可见光表面产生的亮度。</p><ul><li>Arthur Appel. 1968. Some techniques for shading machine renderings of solids. In Proceedings of the April 30–May 2, 1968, spring joint computer conference (AFIPS ‘68 (Spring)). Association for Computing Machinery, New York, NY, USA, 37–45. <a href="https://doi.org/10.1145/1468075.1468082">https://doi.org/10.1145/1468075.1468082</a></li></ul></li></ul><h3 id="1970"><a href="#1970" class="headerlink" title="1970"></a>1970</h3><ul><li><p>光照模型：Bouknight提出第一个光反射模型，指出物体表面朝向是确定物体表面上一点光强的主要因素，用Lambert漫反射定律计算物体表面上各多边形的光强，对光照射不到的地方，用环境光代替。</p><ul><li>W. Jack Bouknight. 1970. A procedure for generation of three-dimensional half-toned computer graphics presentations. Commun. ACM 13, 9 (Sept. 1970), 527–536. <a href="https://doi.org/10.1145/362736.362739">https://doi.org/10.1145/362736.362739</a></li></ul></li></ul><h3 id="1971"><a href="#1971" class="headerlink" title="1971"></a>1971</h3><ul><li><p>光照模型：Gourand提出的基于“漫反射模型与插值”思想的Gourand模型。对多面体模型，用漫反射模型计算多边形顶点的光亮度，再用增量法插值计算。</p><ul><li>Gouraud, H. (1971). Continuous Shading of Curved Surfaces. IEEE Transactions on Computers, C-20, 623-629. <a href="https://ieeexplore.ieee.org/document/1671906">https://ieeexplore.ieee.org/document/1671906</a></li></ul></li></ul><h3 id="1974"><a href="#1974" class="headerlink" title="1974"></a>1974</h3><ul><li><p>Siggraph开始每年举办计算机图形学顶级年度会议。</p></li><li><p>Z-buffer算法</p><ul><li>Catmull, E., “A Subdivision Algorithm for Computer Display of Curved Surfaces,” PhD. thesis, Dept. of Computer Science, University of Utah, 1974.</li></ul></li></ul><h3 id="1975"><a href="#1975" class="headerlink" title="1975"></a>1975</h3><ul><li><p>光照模型：Phong提出图形学中第一个有影响的简单光照明模型。模型虽然只是一个经验模型，但是其真实度已达到可以接受的程度。在Phong光照模型的基础之上，相继出现了Goud明暗处理和Phong明暗处理两个增量式光照模型。</p><ul><li>Bui Tuong Phong. 1975. Illumination for computer generated pictures. Commun. ACM 18, 6 (June 1975), 311–317. <a href="https://doi.org/10.1145/360825.360839">https://doi.org/10.1145/360825.360839</a></li></ul></li></ul><h3 id="1976"><a href="#1976" class="headerlink" title="1976"></a>1976</h3><ul><li><p>UV mapping</p><ul><li>James F. Blinn and Martin E. Newell. 1976. Texture and reflection in computer generated images. Commun. ACM 19, 10 (Oct. 1976), 542–547. <a href="https://doi.org/10.1145/360349.360353">https://doi.org/10.1145/360349.360353</a></li></ul></li><li><p>用于消隐的数据结构</p><ul><li>James H. Clark. 1976. Hierarchical geometric models for visible surface algorithms. Commun. ACM 19, 10 (Oct. 1976), 547–554. <a href="https://doi.org/10.1145/360349.360354">https://doi.org/10.1145/360349.360354</a></li></ul></li></ul><h3 id="1977"><a href="#1977" class="headerlink" title="1977"></a>1977</h3><ul><li><p>光照模型：Blinn-Phong</p><ul><li>James F. Blinn. 1977. Models of light reflection for computer synthesized pictures. SIGGRAPH Comput. Graph. 11, 2 (Summer 1977), 192–198. <a href="https://doi.org/10.1145/965141.563893">https://doi.org/10.1145/965141.563893</a></li></ul></li><li><p>Shadow Volume</p><ul><li>Crow, Franklin C., “Shadow Algorithms for Computer Graphics,” Computer Graphics (SIGGRAPH ’77 Proceedings), vol. 11, no. 2, pp. 242–248, July 1977.</li></ul></li></ul><h3 id="1978"><a href="#1978" class="headerlink" title="1978"></a>1978</h3><ul><li><p>Shadow Map算法</p><ul><li><p>Lance Williams. 1978. Casting curved shadows on curved surfaces. SIGGRAPH Comput. Graph. 12, 3 (August 1978), 270–274. <a href="https://doi.org/10.1145/965139.807402">https://doi.org/10.1145/965139.807402</a></p></li><li><p>Development：</p><ul><li>C. Hourcade and A. Nicolas.  Algorithms for antialiased cast shadows. Computers and Graphics, 9(3):259–265, 1985.</li><li>Midpoint Shadow Map.  Andrew Woo, VII.1 - THE SHADOW DEPTH MAP REVISITED, Editor(s): DAVID KIRK, Graphics Gems III (IBM Version), Morgan Kaufmann, 1992,Pages 338-342,  <a href="https://doi.org/10.1016/B978-0-08-050755-2.50073-7">https://doi.org/10.1016/B978-0-08-050755-2.50073-7</a>.</li><li>Mark Segal, Carl Korobkin, Rolf van Widenfelt, Jim Foran, and Paul Haeberli. 1992.  Fast shadows and lighting effects using texture mapping. SIGGRAPH Comput. Graph. 26, 2 (July 1992), 249–252. <a href="https://doi.org/10.1145/142920.134071">https://doi.org/10.1145/142920.134071</a></li><li>Shenchang Eric Chen and Lance Williams. 1993.  View interpolation for image synthesis. In Proceedings of the 20th annual conference on Computer graphics and interactive techniques (SIGGRAPH ‘93). Association for Computing Machinery, New York, NY, USA, 279–288. <a href="https://doi.org/10.1145/166117.166153">https://doi.org/10.1145/166117.166153</a></li><li>Y. Wang and S. Molnar. Second-depth shadow mapping.  Technical Report TR94-019, Department of Computer Science, University of North Carolina - Chapel Hill, Dec. 1994.</li><li>. Fernando, S. Fernandez, K. Bala, and D. P. Greenberg. Adaptive shadow maps. In SIGGRAPH 2001 Conference Proceedings, pages 387–390, 2001.</li><li>M. Stamminger and G. Drettakis. Perspective shadow maps. ACM Transactions on Graphics, 21(3):557–562, July 2002.</li></ul></li></ul></li><li><p>感觉是消隐</p><ul><li>Edwin Catmull. 1978. A hidden-surface algorithm with anti-aliasing. SIGGRAPH Comput. Graph. 12, 3 (August 1978), 6–11. <a href="https://doi.org/10.1145/965139.807360">https://doi.org/10.1145/965139.807360</a></li></ul></li><li><p>太有名了先放在这里</p><ul><li>Turner Whitted. 1978. A scan line algorithm for computer display of curved surfaces. SIGGRAPH Comput. Graph. 12, SI (August 1978), 8–13. <a href="https://doi.org/10.1145/988437.988440">https://doi.org/10.1145/988437.988440</a></li></ul></li></ul><h3 id="1980"><a href="#1980" class="headerlink" title="1980"></a>1980</h3><ul><li><p>光照模型&amp;光线追踪：Whitted提出了Whitted模型，并第一次给出一般性光线跟踪算法的范例。该模型综合考虑了光的反射、折射透射、阴影等。此时的光线追踪才真正的变成一个强大的工具，其将光线投射算法扩展为递归算法（Recursive Ray Tracing）。</p><ul><li>Turner Whitted. 1980. An improved illumination model for shaded display. Commun. ACM 23, 6 (June 1980), 343–349. <a href="https://doi.org/10.1145/358876.358882">https://doi.org/10.1145/358876.358882</a></li></ul></li><li><p>八叉树？</p><ul><li>Steven M. Rubin and Turner Whitted. 1980. A 3-dimensional representation for fast rendering of complex scenes. SIGGRAPH Comput. Graph. 14, 3 (July 1980), 110–116. <a href="https://doi.org/10.1145/965105.807479">https://doi.org/10.1145/965105.807479</a></li></ul></li></ul><h3 id="1982"><a href="#1982" class="headerlink" title="1982"></a>1982</h3><ul><li><p>光照模型：Cook和Torrance为了克服Phong模型的缺点，提出了一个基于物理光学的表面反射模型—大名鼎鼎的Cook-Torrance微表面模型，使得模型中反射光的位置和分布与实际情况非常接近，因而用它绘制的图形具有很好的质感。</p><ul><li>R. L. Cook and K. E. Torrance. 1982. A Reflectance Model for Computer Graphics. ACM Trans. Graph. 1, 1 (Jan. 1982), 7–24. <a href="https://doi.org/10.1145/357290.357293">https://doi.org/10.1145/357290.357293</a></li></ul></li><li><p>体积散射 blinn</p></li></ul><h3 id="1983"><a href="#1983" class="headerlink" title="1983"></a>1983</h3><ul><li>光照模型：Hall和Greenbert在whitted基础上此进一步给出Hall光透射模型,考虑了漫透射和规则透射光。改进了whitted中投射高光效果，并再环境光中加入距离衰减因子，使之能够更好的模拟物体表面的透射特性。</li></ul><h3 id="1984"><a href="#1984" class="headerlink" title="1984"></a>1984</h3><ul><li><p>Cook于1984年引入蒙特卡洛方法（Monte Carlo method）到光线跟踪领域，将经典的光线跟踪方法扩展为分布式光线跟踪算法（Distributed Ray Tracing），又称为随机光线追踪（stochasticray tracing），可以模拟更多的效果，如金属光泽、软阴影、景深（ Depthof Field）、运动模糊等等。</p><ul><li>Robert L. Cook, Thomas Porter, and Loren Carpenter. 1984. Distributed ray tracing. SIGGRAPH Comput. Graph. 18, 3 (July 1984), 137–145. <a href="https://doi.org/10.1145/964965.808590">https://doi.org/10.1145/964965.808590</a></li></ul></li><li><p>Goral 1984年 辐射度算法</p></li></ul><h3 id="1986"><a href="#1986" class="headerlink" title="1986"></a>1986</h3><ul><li><p>光照模型&amp;光线追踪：Kajiya统一了以前所有的光照模型。Kajiya首先提出使类似于随机采样的蒙特卡罗（Monte Carlo）方法求解绘制方程的光线追踪算法（Raytracing）——通过对到达图像平面上的光线路径进行采样，然后估计它们对最终图像的贡献来生成图像。</p><ul><li>James T. Kajiya. 1986. The rendering equation. SIGGRAPH Comput. Graph. 20, 4 (Aug. 1986), 143–150. <a href="https://doi.org/10.1145/15886.15902">https://doi.org/10.1145/15886.15902</a></li></ul></li><li><p>Non-diffuse Radiosity</p><ul><li>David S. Immel, Michael F. Cohen, and Donald P. Greenberg. 1986. A radiosity method for non-diffuse environments. SIGGRAPH Comput. Graph. 20, 4 (Aug. 1986), 133–142. <a href="https://doi.org/10.1145/15886.15901">https://doi.org/10.1145/15886.15901</a></li></ul></li></ul><h3 id="1987"><a href="#1987" class="headerlink" title="1987"></a>1987</h3><ul><li><p>PCF算法</p><ul><li>William T. Reeves, David H. Salesin, and Robert L. Cook. 1987. Rendering antialiased shadows with depth maps. SIGGRAPH Comput. Graph. 21, 4 (July 1987), 283–291. <a href="https://doi.org/10.1145/37402.37435">https://doi.org/10.1145/37402.37435</a></li></ul></li></ul><h3 id="1991"><a href="#1991" class="headerlink" title="1991"></a>1991</h3><ul><li><p>非漫射辐射度（Non-diffuse Radiosity）</p><ul><li>Françis X. Sillion, James R. Arvo, Stephen H. Westin, and Donald P. Greenberg. 1991. A global illumination solution for general reflectance distributions. SIGGRAPH Comput. Graph. 25, 4 (July 1991), 187–196. <a href="https://doi.org/10.1145/127719.122739">https://doi.org/10.1145/127719.122739</a></li></ul></li><li><p>Hanrahan 1991年 分级辐射度算法（Hierarchical radiosity）</p></li><li><p>先放在这</p><ul><li>Xiao D. He, Kenneth E. Torrance, François X. Sillion, and Donald P. Greenberg. 1991. A comprehensive physical model for light reflection. SIGGRAPH Comput. Graph. 25, 4 (July 1991), 175–186. <a href="https://doi.org/10.1145/127719.122738">https://doi.org/10.1145/127719.122738</a></li></ul></li></ul><h3 id="1992"><a href="#1992" class="headerlink" title="1992"></a>1992</h3><ul><li>RenderMan规范，简称RISpec，是一个开放的API，由皮克斯开发，用于描述三维模型并把它转换成逼真的数字图像。RenderMan规范作为建模程序和渲染程序之间的通信协议（或称为接口），用于生成逼真的数字图像。</li></ul><h3 id="1993"><a href="#1993" class="headerlink" title="1993"></a>1993</h3><ul><li><p>不连续网格辐射度（Discontinuity meshing）</p><ul><li>Dani Lischinski, Filippo Tampieri, and Donald P. Greenberg. 1993. Combining hierarchical radiosity and discontinuity meshing. In Proceedings of the 20th annual conference on Computer graphics and interactive techniques (SIGGRAPH ‘93). Association for Computing Machinery, New York, NY, USA, 199–208. <a href="https://doi.org/10.1145/166117.166143">https://doi.org/10.1145/166117.166143</a></li></ul></li><li><p>Lafortune and Willems 1993 年• Veach and Guibas 1994年 双向路径跟踪</p></li></ul><h3 id="1994"><a href="#1994" class="headerlink" title="1994"></a>1994</h3><ul><li><p>微表面&amp;Roughness相关</p><ul><li>Michael Oren and Shree K. Nayar. 1994. Generalization of Lambert’s reflectance model. In Proceedings of the 21st annual conference on Computer graphics and interactive techniques (SIGGRAPH ‘94). Association for Computing Machinery, New York, NY, USA, 239–246. <a href="https://doi.org/10.1145/192161.192213">https://doi.org/10.1145/192161.192213</a></li></ul></li></ul><h3 id="1995"><a href="#1995" class="headerlink" title="1995"></a>1995</h3><ul><li>Diffusion for light transport</li></ul><h3 id="1996"><a href="#1996" class="headerlink" title="1996"></a>1996</h3><ul><li><p>光子映射 Photon Mapping</p><ul><li>Jensen, Henrik Wann. “Global Illumination using Photon Maps.” Rendering Techniques (1996).</li></ul></li></ul><h3 id="1997"><a href="#1997" class="headerlink" title="1997"></a>1997</h3><ul><li><p>Veach and Guibas 1997 马尔可夫链蒙特卡洛</p><ul><li>Robust Monte Carlo Methods for Light Transport Simulation</li></ul></li><li><p>光子映射 Photon Mapping</p><ul><li>Bruce Walter, Philip M. Hubbard, Peter Shirley, and Donald P. Greenberg. 1997. Global illumination using local linear density estimation. ACM Trans. Graph. 16, 3 (July 1997), 217–259. <a href="https://doi.org/10.1145/256157.256158">https://doi.org/10.1145/256157.256158</a></li></ul></li><li><p>Light Transport</p><ul><li>Veach, Eric &amp; Guibas, Leonidas. (1970). Metropolis Light Transport. Computer Graphics (SIGGRAPH ‘97 Proceedings). 31. 10.1145&#x2F;258734.258775.</li></ul></li><li><p>Keller 1997年Virtual point lights (Instant Radiosity)</p></li></ul><h3 id="1998"><a href="#1998" class="headerlink" title="1998"></a>1998</h3><ul><li><p>Jensen and Christensen 1998年Volumetric photon mapping</p></li><li><p>Bi-Directional Path Tracing</p><ul><li>Lafortune, Eric &amp; Willems, Yves. (1998). Bi-Directional Path Tracing. Proceedings of Third International Conference on Computational Graphics and Visualization Techniques (Compugraphics’. 93.</li></ul></li></ul><h3 id="2000"><a href="#2000" class="headerlink" title="2000"></a>2000</h3><ul><li>Pauly 2000年 Metropolis in volumes</li></ul><h3 id="2001"><a href="#2001" class="headerlink" title="2001"></a>2001</h3><ul><li><p>次表面散射</p><ul><li>Jensen H W, Marschner S R, Levoy M, et al. A practical model for subsurface light transport[C]&#x2F;&#x2F;Proceedings of the 28th annual conference on Computer graphics and interactive techniques. ACM, 2001: 511-518.</li></ul></li></ul><h3 id="2002"><a href="#2002" class="headerlink" title="2002"></a>2002</h3><ul><li>Kelemen et al. 2002Primary sample space MCMC</li></ul><h3 id="2005"><a href="#2005" class="headerlink" title="2005"></a>2005</h3><ul><li><p>Walter 2005年 LightCuts</p></li><li><p>Cline 2005年“Energy Redistribution” 和 非遍历 MCMC</p></li><li><p>Fernando发表了Percentage-Closer Soft Shadows，称为“百分比渐近柔和阴影（PCSS）。</p><ul><li><a href="https://developer.download.nvidia.com/shaderlibrary/docs/shadow_PCSS.pdf">https://developer.download.nvidia.com/shaderlibrary/docs/shadow_PCSS.pdf</a></li></ul></li><li><p>RSM算法（Reflective Shadow Map）</p><ul><li>Carsten Dachsbacher and Marc Stamminger. 2005. Reflective shadow maps. In Proceedings of the 2005 symposium on Interactive 3D graphics and games (I3D ‘05). Association for Computing Machinery, New York, NY, USA, 203–231. <a href="https://doi.org/10.1145/1053427.1053460">https://doi.org/10.1145/1053427.1053460</a></li></ul></li></ul><h3 id="2006"><a href="#2006" class="headerlink" title="2006"></a>2006</h3><ul><li><p>VSM算法（Variance shadow maps）</p><ul><li>William Donnelly and Andrew Lauritzen. 2006. Variance shadow maps. In Proceedings of the 2006 symposium on Interactive 3D graphics and games (I3D ‘06). Association for Computing Machinery, New York, NY, USA, 161–165. <a href="https://doi.org/10.1145/1111411.1111440">https://doi.org/10.1145/1111411.1111440</a></li></ul></li></ul><h3 id="2007"><a href="#2007" class="headerlink" title="2007"></a>2007</h3><ul><li><p>Walter 2007 年 Microfacet transmission model</p></li><li><p>CSM算法</p><ul><li><a href="https://developer.download.nvidia.com/SDK/10.5/opengl/src/cascaded_shadow_maps/doc/cascaded_shadow_maps.pdf">https://developer.download.nvidia.com/SDK/10.5/opengl/src/cascaded_shadow_maps/doc/cascaded_shadow_maps.pdf</a></li></ul></li></ul><h3 id="2008"><a href="#2008" class="headerlink" title="2008"></a>2008</h3><ul><li>Jarosz 2008年 光束辐射估计（Beam Radiance Estimate）</li></ul><h3 id="2010"><a href="#2010" class="headerlink" title="2010"></a>2010</h3><ul><li>Jakob 2010年Anisotropic volume media</li></ul><h3 id="2011"><a href="#2011" class="headerlink" title="2011"></a>2011</h3><ul><li>d’Eon and Irving 2011年Advanced diffusion models</li></ul><h3 id="2012"><a href="#2012" class="headerlink" title="2012"></a>2012</h3><ul><li><p>Jakob &amp;amp;amp; Marschner 2012年Manifold Exploration</p></li><li><p>Disney Principled BRDF</p><p>- </p><ul><li>MERL 100 BRDF 材质库</li></ul></li></ul><h3 id="2014"><a href="#2014" class="headerlink" title="2014"></a>2014</h3><ul><li>Křivánek 2014年Unifying Points, Beams, and Paths</li></ul><h3 id="2015"><a href="#2015" class="headerlink" title="2015"></a>2015</h3><ul><li><p>Kettunen 2015 梯度域路径跟踪</p></li><li><p>Stochastic Screen-Space Reflections</p><ul><li><a href="https://view.officeapps.live.com/op/view.aspx?src=https://advances.realtimerendering.com/s2015/Stochastic%2520Screen-Space%2520Reflections.pptx">https://view.officeapps.live.com/op/view.aspx?src=https%3A%2F%2Fadvances.realtimerendering.com%2Fs2015%2FStochastic%2520Screen-Space%2520Reflections.pptx</a></li></ul></li><li><p>Moment Shadow Map</p><ul><li>Christoph Peters and Reinhard Klein. 2015. Moment shadow mapping. In Proceedings of the 19th Symposium on Interactive 3D Graphics and Games (i3D ‘15). Association for Computing Machinery, New York, NY, USA, 7–14. <a href="https://doi.org/10.1145/2699276.2699277">https://doi.org/10.1145/2699276.2699277</a></li></ul></li></ul><h3 id="2018"><a href="#2018" class="headerlink" title="2018"></a>2018</h3><ul><li><p>微软提出了DirectX Ray Tracing（DXR）的API，提供了Ray Tracing Pipeline的雏形。</p></li><li><p>NVIDIA宣布了可加速硬件中光线追踪速度的新架构Turing，以及搭载实时光线追踪技术的RTX系列显卡。Nvidia推出了新一代的RTX显卡，提供了Ray Tracing硬件加速的能力。</p></li><li><p>第一款搭载RTX实时混合光线追踪技术的游戏《战地5（Battlefield V）》正式面世，基于EA的Frostbite引擎，带来了出色的混合光线追踪反射（Hybrid Ray-Traced Reflections）渲染表现。</p></li><li><p>Eric Heitz于2018年提出了一种结合了解析直接光照（analytic direct illumination）和随机阴影（stochastic shadows）的新方法[13]）。在paper中，他们提出了一种比率估计器（ratio estimator），该比率估计器可以将解析光照技术（analytic illumination techniques）与随机光线追踪阴影（stochastic raytraced shadows）正确组合。</p><ul><li>Eric Heitz, Stephen Hill, and Morgan McGuire. 2018. Combining analytic direct illumination and stochastic shadows. In Proceedings of the ACM SIGGRAPH Symposium on Interactive 3D Graphics and Games (I3D ‘18). Association for Computing Machinery, New York, NY, USA, Article 2, 1–11. <a href="https://doi.org/10.1145/3190834.3190852">https://doi.org/10.1145/3190834.3190852</a></li></ul></li></ul><h3 id="2019"><a href="#2019" class="headerlink" title="2019"></a>2019</h3><ul><li><p>SIGGRAPH2019的Ray Tracing专题报告展望了实时光线追踪的未来。其中，SEED团队分享了自己的混合渲染管线（上图），管线由一个接一个的阶段串联，而每个阶段采用最合适的技术来实现。</p><ul><li>SIGGRAPH 2019, State-of-the-Art and Challenges in Game Ray Tracing</li></ul></li></ul><h3 id="2020"><a href="#2020" class="headerlink" title="2020"></a>2020</h3><ul><li>Vulkan也推出了Ray Tracing规范，同DXR非常相似。</li></ul><h3 id="2021"><a href="#2021" class="headerlink" title="2021"></a>2021</h3><ul><li>2021年，UE5的视频又掀起了一波热潮，新一代的渲染引擎Lumen则是一套完整的光线追踪管线，分为Software和Hardware两种形式。</li><li>Nvidia推出 RayTracing Gens Ⅱ。</li></ul><h3 id="2022"><a href="#2022" class="headerlink" title="2022"></a>2022</h3><ul><li>AMD推出自己的Ray Tracing库——HIP。</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><h3 id="https-zhuanlan-zhihu-com-p-50165536"><a href="#https-zhuanlan-zhihu-com-p-50165536" class="headerlink" title="https://zhuanlan.zhihu.com/p/50165536"></a><a href="https://zhuanlan.zhihu.com/p/50165536">https://zhuanlan.zhihu.com/p/50165536</a></h3><h3 id="https-zhuanlan-zhihu-com-p-49474631"><a href="#https-zhuanlan-zhihu-com-p-49474631" class="headerlink" title="https://zhuanlan.zhihu.com/p/49474631"></a><a href="https://zhuanlan.zhihu.com/p/49474631">https://zhuanlan.zhihu.com/p/49474631</a></h3><h3 id="https-zhuanlan-zhihu-com-p-29418992"><a href="#https-zhuanlan-zhihu-com-p-29418992" class="headerlink" title="https://zhuanlan.zhihu.com/p/29418992"></a><a href="https://zhuanlan.zhihu.com/p/29418992">https://zhuanlan.zhihu.com/p/29418992</a></h3>]]></content>
      
      
      <categories>
          
          <category> Computer Graphics </category>
          
          <category> Rendering </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rendering </tag>
            
            <tag> Monte Carlo </tag>
            
            <tag> RayTracing </tag>
            
            <tag> PathTracing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PathTracing(待补充)</title>
      <link href="/2023/03/24/PathTracing/"/>
      <url>/2023/03/24/PathTracing/</url>
      
        <content type="html"><![CDATA[<p>光线追踪及路径追踪算法学习与实践。</p><span id="more"></span><h3 id="Related-Information"><a href="#Related-Information" class="headerlink" title="Related Information:"></a>Related Information:</h3><ul><li><a href="https://raytracing.github.io/books/RayTracingInOneWeekend.html">https://raytracing.github.io/books/RayTracingInOneWeekend.html</a></li><li><a href="https://raytracing.github.io/books/RayTracingTheNextWeek.html">https://raytracing.github.io/books/RayTracingTheNextWeek.html</a></li><li><a href="https://agraphicsguynotes.com/posts/sample_microfacet_brdf/">https://agraphicsguynotes.com/posts/sample_microfacet_brdf/</a></li><li><a href="http://www.cim.mcgill.ca/~derek/ecse689_a3.html">http://www.cim.mcgill.ca/~derek/ecse689_a3.html</a></li><li><a href="https://raytracing.github.io/books/RayTracingInOneWeekend.html#dielectrics">https://raytracing.github.io/books/RayTracingInOneWeekend.html#dielectrics</a></li><li><a href="https://en.wikipedia.org/wiki/M%C3%B6ller%E2%80%93Trumbore_intersection_algorithm">https://en.wikipedia.org/wiki/M%C3%B6ller%E2%80%93Trumbore_intersection_algorithm</a></li><li><a href="https://math.stackexchange.com/questions/538458/how-to-sample-points-on-a-triangle-surface-in-3d">https://math.stackexchange.com/questions/538458/how-to-sample-points-on-a-triangle-surface-in-3d</a></li><li><a href="https://computergraphics.stackexchange.com/questions/5152/progressive-path-tracing-with-explicit-light-sampling">https://computergraphics.stackexchange.com/questions/5152/progressive-path-tracing-with-explicit-light-sampling</a></li></ul><h3 id="Path-Tracing-Project："><a href="#Path-Tracing-Project：" class="headerlink" title="Path-Tracing Project："></a>Path-Tracing Project：</h3>]]></content>
      
      
      <categories>
          
          <category> Computer Graphics </category>
          
          <category> Rendering </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rendering </tag>
            
            <tag> Monte Carlo </tag>
            
            <tag> RayTracing </tag>
            
            <tag> PathTracing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Visibility</title>
      <link href="/2023/02/17/Visibility/"/>
      <url>/2023/02/17/Visibility/</url>
      
        <content type="html"><![CDATA[<p>任务目标：<br>参与一个可微分渲染的项目，主要负责其中的渲染部分相关工作，在前期需要使用已有的Mesh和Texture数据生成网络所需要的输入数据。其中就包括Visibility，刚开始做的时候什么都不太懂，学习相关知识耽误了很多时间，故整理于此。</p><span id="more"></span><h2 id="任务理解："><a href="#任务理解：" class="headerlink" title="任务理解："></a>任务理解：</h2><p>经与导师沟通后，本项目要求的Visibility并不是从相机角度看过去的可视性，而是更像环境光照那种，设想有一个无限大的球面，在球面上通过遍历不同的经纬得到不同的光线方向，对于模型上面的每一个顶点，计算在球面上各个方向其是否可视（光线不被其他物体或者面片遮挡）。<br><br>为了方便数据输入网络，导师还要求将这个可视数据通过球谐函数Spherical Harmonics计算得到在球谐函数空间的前9维系数，从而将每一个顶点在各个方向上是否可见的信息，转化为一个9维的向量，作为Mesh中顶点的附加属性。</p><h2 id="具体实现："><a href="#具体实现：" class="headerlink" title="具体实现："></a>具体实现：</h2><p>因为在计算Visibility中需要对整个球面进行光线方向的采样，并计算其在整个场景中是否与其他物体或者面片相交，因此其实可以转化为使用一个光线追踪的框架来帮助完成这个工作，在前期探索中，曾经试图使用Games202 Assignment2的Nori框架来完成这件事，但是后面与导师沟通后，导师建议我使用Mitsuba来完成该工作，原因主要有下：Mitsuba的使用场合较为广泛，相关的资料和实验室能够提供的帮助也较多；另外学习Mitsuba也对我之后在渲染方向的继续探索有帮助。</p><p>而对于投影到SH这一步，目前我在Giuhub上找到一个开源的项目：</p><ul><li><a href="https://github.com/chalmersgit/SphericalHarmonics">https://github.com/chalmersgit/SphericalHarmonics</a></li></ul><p>初步决定在其基础上进行修改完成第二部分计算工作。这个项目初衷是针对Image Based Lighting的SH投影计算，其使用的IBL投影方式是Equirectangular Projection(ERP)。相关资料：</p><ul><li><a href="https://blog.csdn.net/lin453701006/article/details/71173090">https://blog.csdn.net/lin453701006/article/details/71173090</a></li></ul><p>因此首先要把球面采样的代码修改到与该投影方式对应，得到一张这样的图像，再使用该项目计算SH。</p><h2 id="具体实现中遇到的问题"><a href="#具体实现中遇到的问题" class="headerlink" title="具体实现中遇到的问题"></a>具体实现中遇到的问题</h2><ul><li>从maya导出的mesh 在Maya中没有Transform 但是导入Blender有x轴上90度的旋转，而进入到Mitsuba时其在空间坐标系中的状态是Blender中去掉90旋转之后的状态，初步怀疑是Maya、Blender和Mitsuba三者的坐标系有些不同，但是目前还没有深入探索得到答案。</li><li>在进行球面采样的时候，需要为了防止边界出现问题，需要将每个像素点的坐标变换到像素点中心，即遍历xy时对其进行x+0.5 y+0.5的计算。</li></ul><h2 id="相关知识点"><a href="#相关知识点" class="headerlink" title="相关知识点"></a>相关知识点</h2><p>Image Based Lighting分为三种不同的投影方式：</p><ul><li>Cube Map</li><li>Dual Paraboloid Map</li><li>Equirectangualr Map</li></ul><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><ul><li>Spherical Harmonics：<br><a href="https://www.jianshu.com/p/a379b4c6d346">https://www.jianshu.com/p/a379b4c6d346</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Relighting Project </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Deep Learing </tag>
            
            <tag> Artificial Intelligent </tag>
            
            <tag> Spherical Harmonics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些资源链接&amp;小知识</title>
      <link href="/2022/11/10/Dessert-Knowledge/"/>
      <url>/2022/11/10/Dessert-Knowledge/</url>
      
        <content type="html"><![CDATA[<p>一些零碎的知识</p><span id="more"></span><h3 id="Key-Words"><a href="#Key-Words" class="headerlink" title="Key Words:"></a>Key Words:</h3><ul><li>重要性采样</li><li>Image based lighting</li><li>Spherical Harmonics</li><li>Blender渲染中的两种重要性采样</li><li><ul><li>Indirect Light</li></ul></li><li><ul><li>Direct Light</li></ul></li></ul><ol><li><p>Siggraph索引：<a href="https://kesen.realtimerendering.com/">https://kesen.realtimerendering.com/</a></p></li><li><p>常用Mesh：<a href="http://casual-effects.com/data/index.html">http://casual-effects.com/data/index.html</a></p></li><li><p>HDRI贴图：<a href="https://polyhaven.com/zh/hdris/indoor">https://polyhaven.com/zh/hdris/indoor</a></p></li><li><p>在线shell转bat：</p></li></ol><ul><li><a href="https://daniel-sc.github.io/bash-shell-to-bat-converter/">https://daniel-sc.github.io/bash-shell-to-bat-converter/</a></li></ul><ol start="5"><li>Spherical Harmonics：</li></ol><ul><li><a href="https://www.jianshu.com/p/a379b4c6d346">https://www.jianshu.com/p/a379b4c6d346</a></li><li><a href="https://github.com/blurgyy/cg-2020">https://github.com/blurgyy/cg-2020</a></li></ul><ol start="6"><li>Chrono是c++11的一个时间库，可以用它来做程序运行时间的记录。</li></ol><ul><li><a href="https://www.cnblogs.com/jwk000/p/3560086.html">https://www.cnblogs.com/jwk000/p/3560086.html</a></li></ul><ol start="7"><li><p>Warp是一个可以迁移拓扑并投影贴图的软件</p></li><li><p>TinyXML2是一个可以解析XML格式文件的库</p></li></ol><ul><li><a href="https://github.com/leethomason/tinyxml2">https://github.com/leethomason/tinyxml2</a></li></ul><ol start="9"><li>三维制作软件中，基本都是右手坐标系，但需要注意默认朝上的轴，比如：</li></ol><ul><li>Maya里面的坐标系是Y轴朝上</li><li>Blender里面的坐标系是z轴朝上</li><li>所以模型导入blender会自动沿着x轴旋转90度</li></ul><ol start="10"><li>PBRT:</li></ol><ul><li><a href="https://www.pbr-book.org/3ed-2018/contents">https://www.pbr-book.org/3ed-2018/contents</a></li><li><a href="https://github.com/BachiLi/lajolla_public">https://github.com/BachiLi/lajolla_public</a></li><li><a href="https://github.com/462cmu">https://github.com/462cmu</a></li><li><a href="https://github.com/wjakob/nori">https://github.com/wjakob/nori</a></li><li><a href="https://github.com/HW140701/Book-list-of-computational-geometry-and-computer-graphics">https://github.com/HW140701/Book-list-of-computational-geometry-and-computer-graphics</a></li><li><a href="https://blog.csdn.net/qq_21388689/article/details/117129404">https://blog.csdn.net/qq_21388689/article/details/117129404</a></li><li><a href="https://zhuanlan.zhihu.com/p/553407062">https://zhuanlan.zhihu.com/p/553407062</a></li></ul><ol start="11"><li>py3nvml使用：</li></ol><ul><li><a href="https://blog.csdn.net/zywvvd/article/details/109538759">https://blog.csdn.net/zywvvd/article/details/109538759</a></li></ul><ol start="12"><li>git waring：LF will be replaced by CRLF in 2022&#x2F;06&#x2F;08&#x2F;hello-world&#x2F;index.html.</li></ol><ul><li><a href="https://xiaozhuanlan.com/topic/4053786912">https://xiaozhuanlan.com/topic/4053786912</a></li></ul><ol start="13"><li>cuDNN&amp;cuBlas</li></ol><ul><li>cuda深度神经网络库 CUDA Deep Neural Network (cuDNN)</li><li>cuBLAS简介：CUDA基本线性代数子程序库（CUDA Basic Linear Algebra Subroutine library）</li></ul><ol start="14"><li>Nsight System和Nsight Compute</li></ol><ul><li>将 CUDA API, GPU activity 的 tracing 与 kernel的profiling 分开，以便专门优化减小overhead，前者是 Nsight System，后者是 Nsight Compute。</li><li>拆开易扩展，Nsight System 可以监控 多进程、多核的 CPU backtrace； Nsight Compute 可以交互地debug 和 kernel profiling，它可以设置baseline，比较不同的kernel 执行。</li></ul><ol start="15"><li>欧几里德结构数据(Euclidean Structure Data) 以及非欧几里德结构数据(Non-Euclidean Structure Data)</li></ol><ul><li><a href="https://blog.csdn.net/imsuhxz/article/details/91361977">https://blog.csdn.net/imsuhxz/article/details/91361977</a></li></ul><ol start="16"><li>如何制作雨中布料渲染效果</li></ol><ul><li><ul><li><a href="https://www.youtube.com/watch?v=w3lwfMKkEwI">https://www.youtube.com/watch?v=w3lwfMKkEwI</a></li></ul></li><li><ul><li><a href="https://youngjoongkwon.wordpress.com/2017/11/30/real-time-animation-of-rain-wet-cloth-material-2016/">https://youngjoongkwon.wordpress.com/2017/11/30/real-time-animation-of-rain-wet-cloth-material-2016/</a></li></ul></li><li><ul><li><a href="https://cdn.jsdelivr.net/gh/YaelCassini/Papers/TA/Wet%20cloth%20animation%20with%20vertex%20based%20adhesion%20force%20model.pdf">https://cdn.jsdelivr.net/gh/YaelCassini/Papers/TA/Wet%20cloth%20animation%20with%20vertex%20based%20adhesion%20force%20model.pdf</a></li></ul></li><li><ul><li><a href="https://cdn.jsdelivr.net/gh/YaelCassini/Papers/TA/Real-time%20Animation%20of%20Rain-wet%20Cloth%20Material.pdf">https://cdn.jsdelivr.net/gh/YaelCassini/Papers/TA/Real-time%20Animation%20of%20Rain-wet%20Cloth%20Material.pdf</a></li></ul></li></ul><ol start="17"><li>Normal Mapping相关</li></ol><ul><li><ul><li>Triplanar Mapping</li></ul></li><li><ul><li><a href="https://blog.selfshadow.com/publications/blending-in-detail/#mjx-eqn-eqquat">https://blog.selfshadow.com/publications/blending-in-detail/#mjx-eqn-eqquat</a></li></ul></li></ul><ol start="18"><li>渲染中的坐标变换：</li></ol><ul><li><ul><li><a href="https://blog.csdn.net/sinat_34870723/article/details/113925012">https://blog.csdn.net/sinat_34870723/article/details/113925012</a></li></ul></li><li><ul><li><a href="https://zhuanlan.zhihu.com/p/115395322">https://zhuanlan.zhihu.com/p/115395322</a></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer Graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Papers </tag>
            
            <tag> ToolBag </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Deep Face 初期调研及实践</title>
      <link href="/2022/07/04/Deep-Fake-Survey/"/>
      <url>/2022/07/04/Deep-Fake-Survey/</url>
      
        <content type="html"><![CDATA[<p>Deep Face(后改为Relighting)项目 初期调研及实践</p><span id="more"></span><ul><li><p>GAN论文总结：<a href="https://mp.weixin.qq.com/s?__biz=MzU5MTgzNzE0MA==&amp;mid=100002834&amp;idx=1&amp;sn=7d1c740509ba6b65f630f6db6bd51d7b&amp;chksm=7e29aea9495e27bfa746902298298c921320c3cb13a0619824528c3d1803f533779b7a93a242#rd">https://mp.weixin.qq.com/s?__biz=MzU5MTgzNzE0MA==&amp;mid=100002834&amp;idx=1&amp;sn=7d1c740509ba6b65f630f6db6bd51d7b&amp;chksm=7e29aea9495e27bfa746902298298c921320c3cb13a0619824528c3d1803f533779b7a93a242#rd</a></p></li><li><p>3DMM：<a href="https://zhuanlan.zhihu.com/p/161828142">https://zhuanlan.zhihu.com/p/161828142</a></p></li><li><p>深度学习入门：<a href="https://zhuanlan.zhihu.com/p/372029815">https://zhuanlan.zhihu.com/p/372029815</a></p></li><li><p>Keywords: 全连接神经网络、CNN、RNN、LTSM、GAN</p></li><li><p>CNN：<a href="https://zhuanlan.zhihu.com/p/38160157">https://zhuanlan.zhihu.com/p/38160157</a></p></li><li><p>解决CondaHTTPError:HTTP 000：<a href="https://blog.csdn.net/weixin_51484460/article/details/122179000">https://blog.csdn.net/weixin_51484460/article/details/122179000</a></p></li><li><p>批处理文件格式的Deep Face Lab及教程：<a href="https://blog.csdn.net/yihuaixu/article/details/120738257">https://blog.csdn.net/yihuaixu/article/details/120738257</a></p></li><li><p><a href="https://blog.csdn.net/u010554381/article/details/100131811">https://blog.csdn.net/u010554381/article/details/100131811</a></p></li><li><p>Deep Face Lab参数说明：<a href="https://blog.csdn.net/qq_28941587/article/details/113790231">https://blog.csdn.net/qq_28941587/article/details/113790231</a></p></li><li><p>数据集：<a href="https://github.com/ondyari/FaceForensics/">https://github.com/ondyari/FaceForensics/</a></p></li><li><ul><li><a href="http://kaldir.vc.in.tum.de/faceforensics_benchmark/">http://kaldir.vc.in.tum.de/faceforensics_benchmark/</a></li></ul></li><li><ul><li>下载：<a href="http://kaldir.vc.in.tum.de/faceforensics_download_v1.py">http://kaldir.vc.in.tum.de/faceforensics_download_v1.py</a></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Relighting Project </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Deep Learing </tag>
            
            <tag> GAN </tag>
            
            <tag> Deep Fake </tag>
            
            <tag> Artificial Intelligent </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Subsurface Scattering 次表面散射学习笔记(待补充)</title>
      <link href="/2022/06/15/Subsurface-Scattering/"/>
      <url>/2022/06/15/Subsurface-Scattering/</url>
      
        <content type="html"><![CDATA[<p>蒙特卡洛积分：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/146144853">https://zhuanlan.zhihu.com/p/146144853</a></li><li><a href="https://www.cnblogs.com/time-flow1024/p/10094293.html#mjx-eqn-eq%3AFN">https://www.cnblogs.com/time-flow1024/p/10094293.html#mjx-eqn-eq%3AFN</a></li><li><a href="https://zhuanlan.zhihu.com/p/365624460">https://zhuanlan.zhihu.com/p/365624460</a></li><li>我悟了！</li></ul><p>Blender Random Walk SSS：</p><ul><li><a href="https://www.blendernation.com/2018/02/10/new-random-walk-method-sss-cycles/">https://www.blendernation.com/2018/02/10/new-random-walk-method-sss-cycles/</a></li><li><a href="https://www.youtube.com/watch?v=fSShkXJtWjU">https://www.youtube.com/watch?v=fSShkXJtWjU</a></li></ul><p>Blender Subsurface：</p><ul><li><a href="https://docs.blender.org/manual/en/latest/render/shader_nodes/shader/sss.html">https://docs.blender.org/manual/en/latest/render/shader_nodes/shader/sss.html</a></li></ul><p>BRDF、BTDF、BSDF、BSSDF：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/27014447">https://zhuanlan.zhihu.com/p/27014447</a></li></ul><p>次表面散射：</p><ul><li><p>毛星云总结Gems 3：<a href="https://zhuanlan.zhihu.com/p/42433792">https://zhuanlan.zhihu.com/p/42433792</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/21247702?refer=graphics">https://zhuanlan.zhihu.com/p/21247702?refer=graphics</a></p></li><li><ol start="2001"><li>A Practical Model for Subsurface Light Transport</li></ol></li><li><p>引入偶极子：2001. A Practical Model for Subsurface Light Transport</p></li><li><p>引入多极子：2005. Light Diffusion in Multi-Layered Translucent Materials</p></li></ul><p>基于纹理空间、基于屏幕空间</p><p>基于纹理空间：Advanced Skin Rendering——Nvidia：<a href="https://developer.download.nvidia.com/presentations/2007/gdc/Advanced_Skin.pdf">https://developer.download.nvidia.com/presentations/2007/gdc/Advanced_Skin.pdf</a></p><ul><li><p>可分离的次表面散射：Separable Subsurface Scattering</p></li><li><p>Arnold 提供的次表面散射说明：<a href="https://docs.arnoldrenderer.com/display/A5AFMUG/Subsurface">https://docs.arnoldrenderer.com/display/A5AFMUG/Subsurface</a></p></li><li><p>Random Walk算法：<a href="https://blog.csdn.net/Da___Vinci/article/details/82958297">https://blog.csdn.net/Da___Vinci/article/details/82958297</a></p></li><li><p>一维随机游走：<a href="https://blog.csdn.net/qq_43186282/article/details/114585885">https://blog.csdn.net/qq_43186282/article/details/114585885</a></p></li><li><p><a href="http://www.iryoku.com/">http://www.iryoku.com/</a></p></li><li><p><a href="http://www.iryoku.com/separable-sss/">http://www.iryoku.com/separable-sss/</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer Graphics </category>
          
          <category> Rendering </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rendering </tag>
            
            <tag> Monte Carlo </tag>
            
            <tag> Subsurface Scattering </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Volantis主题配置</title>
      <link href="/2022/06/15/Volantis%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"/>
      <url>/2022/06/15/Volantis%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>Volantis主题配制教程<br>转自：<a href="https://volantis.js.org/v5/theme-settings/">https://volantis.js.org/v5/theme-settings/</a></p><span id="more"></span><h2 id="创建主题配置文件"><a href="#创建主题配置文件" class="headerlink" title="创建主题配置文件"></a>创建主题配置文件</h2><p>主题目录下的 <code>_config.yml</code> 文件通常负责主题相关配置，我们强烈建议您使用代替的主题配置文件以防止自己的配置丢失。那么如何使用代替主题配置文件呢？</p><div class="timeline"><div class="timenode"><div class="meta"><p><p>第 1&#x2F;2 步：创建配置文件</p></p></div><div class="body"><p>在博客根目录的 <code>_config.yml</code> 文件旁边新建一个文件： <code>_config.volantis.yml</code> ，这个文件中的配置信息优先级高于主题文件夹中的配置文件。</p></div></div><div class="timenode"><div class="meta"><p><p>第 2&#x2F;2 步：覆盖自定义配置</p></p></div><div class="body"><p>当您需要修改某项内容时，例如导航栏菜单，那么您需要在主题配置文件中找到相关内容，复制进自己创建的配置文件中：</p><figure class="highlight yaml"><figcaption><span>blog/_config.volantis.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">navbar:</span></span><br><span class="line">  <span class="attr">visiable:</span> <span class="string">auto</span> <span class="comment"># always, auto</span></span><br><span class="line">  <span class="attr">logo:</span> <span class="comment"># choose [img] or [icon + title]</span></span><br><span class="line">    <span class="attr">img:</span> <span class="string">volantis-static/media/org.volantis/blog/Logo-NavBar@3x.png</span> <span class="comment"># https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/Logo-NavBar@3x.png</span></span><br><span class="line">    <span class="attr">icon:</span></span><br><span class="line">    <span class="attr">title:</span></span><br><span class="line">  <span class="attr">menu:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">博客</span></span><br><span class="line">      <span class="attr">icon:</span> <span class="string">fa-solid</span> <span class="string">fa-rss</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">/</span></span><br></pre></td></tr></table></figure><div class="note idea yellow"><p><strong>小提示</strong><br>使用「<code>npm i hexo-theme-volantis</code>」方式安装的主题，主题配置文件在「<code>blog/node_modules/hexo-theme-volantis/_config.yml</code>」<br>使用传统方式安装的主题，主题配置文件在「<code>blog/themes/volantis/_config.yml</code>」</p></div></div></div></div><h2 id="自定义主题外观"><a href="#自定义主题外观" class="headerlink" title="自定义主题外观"></a>自定义主题外观</h2><h3 id="最大布局宽度"><a href="#最大布局宽度" class="headerlink" title="最大布局宽度"></a>最大布局宽度</h3><figure class="highlight yaml"><figcaption><span>blog/_config.volantis.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">custom_css:</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="attr">max_width:</span> <span class="string">1080px</span> <span class="comment"># Sum of body width and sidebar width</span></span><br></pre></td></tr></table></figure><p>网页所呈现的内容的最大宽度，即 body 和 sidebar 的宽度之和。</p><h3 id="抗锯齿"><a href="#抗锯齿" class="headerlink" title="抗锯齿"></a>抗锯齿</h3><figure class="highlight yaml"><figcaption><span>blog/_config.volantis.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">custom_css:</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="attr">font_smoothing:</span> <span class="literal">true</span> <span class="comment"># font-smoothing for webkit</span></span><br></pre></td></tr></table></figure><h3 id="自定义光标样式"><a href="#自定义光标样式" class="headerlink" title="自定义光标样式"></a>自定义光标样式</h3><figure class="highlight yaml"><figcaption><span>blog/_config.volantis.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">custom_css:</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="attr">cursor:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">text:</span> <span class="string">volantis-static/media/cursor/text.png</span> <span class="comment"># https://cdn.jsdelivr.net/gh/inkss/common@1/cursor/text.png</span></span><br><span class="line">    <span class="attr">pointer:</span> <span class="string">volantis-static/media/cursor/pointer.png</span> <span class="comment"># https://cdn.jsdelivr.net/gh/inkss/common@1/cursor/pointer.png</span></span><br><span class="line">    <span class="attr">default:</span> <span class="string">volantis-static/media/cursor/left_ptr.png</span> <span class="comment"># https://cdn.jsdelivr.net/gh/inkss/common@1/cursor/left_ptr.png</span></span><br><span class="line">    <span class="attr">not-allowed:</span> <span class="string">volantis-static/media/cursor/circle.png</span> <span class="comment"># https://cdn.jsdelivr.net/gh/inkss/common@1/cursor/circle.png</span></span><br><span class="line">    <span class="attr">zoom-out:</span> <span class="string">volantis-static/media/cursor/zoom-out.png</span> <span class="comment"># https://cdn.jsdelivr.net/gh/inkss/common@1/cursor/zoom-out.png</span></span><br><span class="line">    <span class="attr">zoom-in:</span> <span class="string">volantis-static/media/cursor/zoom-in.png</span> <span class="comment"># https://cdn.jsdelivr.net/gh/inkss/common@1/cursor/zoom-in.png</span></span><br><span class="line">    <span class="attr">grab:</span> <span class="string">volantis-static/media/cursor/openhand.png</span> <span class="comment"># https://cdn.jsdelivr.net/gh/inkss/common@1/cursor/openhand.png</span></span><br></pre></td></tr></table></figure><h3 id="导航栏样式"><a href="#导航栏样式" class="headerlink" title="导航栏样式"></a>导航栏样式</h3><p>您可以设置导航栏的高度以及视觉特效，视觉特效目前可选的有：</p><ul><li><strong>shadow</strong>：卡片阴影。</li><li><strong>floatable</strong>：当鼠标移动到容器内时，呈现出浮起来的效果。</li><li><strong>blur</strong>：背景模糊效果（毛玻璃），当浏览器不支持时显示为不透明。</li></ul><figure class="highlight yaml"><figcaption><span>blog/_config.volantis.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">custom_css:</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="attr">navbar:</span></span><br><span class="line">    <span class="attr">height:</span> <span class="string">64px</span></span><br><span class="line">    <span class="attr">width:</span> <span class="string">auto</span> <span class="comment"># auto, max</span></span><br><span class="line">    <span class="attr">effect:</span> [<span class="string">shadow</span>, <span class="string">blur</span>] <span class="comment"># [shadow, floatable, blur]</span></span><br></pre></td></tr></table></figure><h3 id="滚动条样式"><a href="#滚动条样式" class="headerlink" title="滚动条样式"></a>滚动条样式</h3><figure class="highlight yaml"><figcaption><span>blog/_config.volantis.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">custom_css:</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="attr">scrollbar:</span></span><br><span class="line">    <span class="attr">size:</span> <span class="string">4px</span></span><br><span class="line">    <span class="attr">border:</span> <span class="string">2px</span></span><br><span class="line">    <span class="attr">color:</span> <span class="string">&#x27;#2196f3&#x27;</span></span><br><span class="line">    <span class="attr">hover:</span> <span class="string">&#x27;#ff5722&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="侧边栏样式"><a href="#侧边栏样式" class="headerlink" title="侧边栏样式"></a>侧边栏样式</h3><p>视觉特效参数同上，值得注意的是：卡片的 <code>floatable</code> 效果和 <code>blur</code> 效果相冲突。</p><figure class="highlight yaml"><figcaption><span>blog/_config.volantis.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">custom_css:</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="attr">sidebar:</span></span><br><span class="line">    <span class="attr">effect:</span> [<span class="string">shadow</span>] <span class="comment"># [shadow, floatable, blur]</span></span><br></pre></td></tr></table></figure><h3 id="正文区域样式"><a href="#正文区域样式" class="headerlink" title="正文区域样式"></a>正文区域样式</h3><p>视觉特效参数同上，值得注意的是：卡片的 <code>floatable</code> 效果和 <code>blur</code> 效果相冲突。您可以在 <code>language: true</code> 这里设置代码块显示语言名称。<code>text_align</code> 可以设置 h1&#x2F;h2&#x2F;h3&#x2F;h4&#x2F;p 的文字对齐方向。</p><figure class="highlight yaml"><figcaption><span>blog/_config.volantis.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">custom_css:</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="attr">body:</span></span><br><span class="line">    <span class="attr">effect:</span> [<span class="string">shadow</span>] <span class="comment"># [shadow, floatable, blur]</span></span><br><span class="line">    <span class="attr">highlight:</span></span><br><span class="line">      <span class="attr">language:</span> <span class="literal">true</span> <span class="comment"># show language of codeblock</span></span><br><span class="line">      <span class="attr">copy_btn:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">text_align:</span> <span class="comment"># left, right, justify, center</span></span><br><span class="line">      <span class="attr">h1:</span> <span class="string">left</span></span><br><span class="line">      <span class="attr">h2:</span> <span class="string">left</span></span><br><span class="line">      <span class="attr">h3:</span> <span class="string">left</span></span><br><span class="line">      <span class="attr">h4:</span> <span class="string">left</span></span><br><span class="line">      <span class="attr">p:</span> <span class="string">justify</span></span><br></pre></td></tr></table></figure><h3 id="布局间距"><a href="#布局间距" class="headerlink" title="布局间距"></a>布局间距</h3><p>您可以设置几种标题的布局间距 h2&#x2F;h3&#x2F;h4、段落间距 line、区块内部的段落间距 inline。</p><figure class="highlight yaml"><figcaption><span>blog/_config.volantis.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">custom_css:</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="attr">gap:</span></span><br><span class="line">    <span class="attr">h2:</span> <span class="string">48px</span> <span class="comment"># Spacing above H2 (only px unit)</span></span><br><span class="line">    <span class="attr">h3:</span> <span class="string">24px</span> <span class="comment"># Spacing above H3 (only px unit)</span></span><br><span class="line">    <span class="attr">h4:</span> <span class="string">16px</span> <span class="comment"># Spacing above H4 (only px unit)</span></span><br><span class="line">    <span class="attr">p:</span> <span class="string">1em</span> <span class="comment"># Paragraph spacing between paragraphs</span></span><br><span class="line">    <span class="attr">line_height:</span> <span class="number">1.6</span> <span class="comment"># normal, 1.5, 1.75, 2 ...</span></span><br></pre></td></tr></table></figure><h3 id="自定义字体"><a href="#自定义字体" class="headerlink" title="自定义字体"></a>自定义字体</h3><p>您可以自定义正文和代码字体。</p><figure class="highlight yaml"><figcaption><span>blog/_config.volantis.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">custom_css:</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="attr">fontfamily:</span></span><br><span class="line">    <span class="attr">logofont:</span></span><br><span class="line">      <span class="attr">fontfamily:</span> <span class="string">&#x27;&quot;Varela Round&quot;, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, Helvetica, Arial&#x27;</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">&#x27;Varela Round&#x27;</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">volantis-static/media/fonts/VarelaRound/VarelaRound-Regular.ttf</span> <span class="comment"># https://cdn.jsdelivr.net/gh/volantis-x/cdn-fonts/VarelaRound/VarelaRound-Regular.ttf</span></span><br><span class="line">      <span class="attr">weight:</span> <span class="string">normal</span></span><br><span class="line">      <span class="attr">style:</span> <span class="string">normal</span></span><br><span class="line">    <span class="attr">bodyfont:</span></span><br><span class="line">      <span class="attr">fontfamily:</span> <span class="string">&#x27;UbuntuMono, &quot;Varela Round&quot;, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, Helvetica, Arial&#x27;</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">&#x27;UbuntuMono&#x27;</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">volantis-static/media/fonts/UbuntuMono/UbuntuMono-Regular.ttf</span> <span class="comment"># https://cdn.jsdelivr.net/gh/volantis-x/cdn-fonts/UbuntuMono/UbuntuMono-Regular.ttf</span></span><br><span class="line">      <span class="attr">weight:</span> <span class="string">normal</span></span><br><span class="line">      <span class="attr">style:</span> <span class="string">normal</span></span><br><span class="line">    <span class="attr">codefont:</span></span><br><span class="line">      <span class="attr">fontfamily:</span> <span class="string">&#x27;Menlo, UbuntuMono, Monaco&#x27;</span></span><br><span class="line">      <span class="comment"># name: &#x27;Monaco&#x27;</span></span><br><span class="line">      <span class="comment"># url: volantis-static/media/fonts/Monaco/Monaco.ttf # https://cdn.jsdelivr.net/gh/volantis-x/cdn-fonts/Monaco/Monaco.ttf</span></span><br><span class="line">      <span class="comment"># weight: normal</span></span><br><span class="line">      <span class="comment"># style: normal</span></span><br></pre></td></tr></table></figure><h3 id="自定义颜色"><a href="#自定义颜色" class="headerlink" title="自定义颜色"></a>自定义颜色</h3><span class='btn solid large center'><a class="button" href='https://mhg-lab.github.io/pages/color/' title='多彩配色方案'><i class='fad fa-paper-plane'></i>多彩配色方案</a></span><figure class="highlight yaml"><figcaption><span>blog/_config.volantis.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">color_scheme:</span></span><br><span class="line">  <span class="comment"># ------------</span></span><br><span class="line">  <span class="comment"># 通用颜色</span></span><br><span class="line">  <span class="attr">common:</span></span><br><span class="line">    <span class="comment"># 主题色</span></span><br><span class="line">    <span class="attr">theme:</span> <span class="string">&#x27;#44D7B6&#x27;</span></span><br><span class="line">    <span class="comment"># 链接色</span></span><br><span class="line">    <span class="attr">link:</span> <span class="string">&#x27;#2196f3&#x27;</span></span><br><span class="line">    <span class="comment"># 按钮色</span></span><br><span class="line">    <span class="attr">button:</span> <span class="string">&#x27;#44D7B6&#x27;</span></span><br><span class="line">    <span class="comment"># 鼠标放到交互元素上时的色</span></span><br><span class="line">    <span class="attr">hover:</span> <span class="string">&#x27;#ff5722&#x27;</span></span><br><span class="line">    <span class="comment"># 主题色块内部的文字颜色</span></span><br><span class="line">    <span class="attr">inner:</span> <span class="string">&#x27;#fff&#x27;</span></span><br><span class="line">    <span class="comment"># 选中区域文字的背景颜色</span></span><br><span class="line">    <span class="attr">selection:</span> <span class="string">&#x27;alpha(#2196f3, 0.2)&#x27;</span></span><br><span class="line">  <span class="comment"># ------------</span></span><br><span class="line">  <span class="comment"># 亮色主题（默认）</span></span><br><span class="line">  <span class="attr">light:</span></span><br><span class="line">    <span class="comment"># 网站背景色</span></span><br><span class="line">    <span class="attr">site_bg:</span> <span class="string">&#x27;#f4f4f4&#x27;</span></span><br><span class="line">    <span class="comment"># 网站背景上的文字</span></span><br><span class="line">    <span class="attr">site_inner:</span> <span class="string">&#x27;#fff&#x27;</span></span><br><span class="line">    <span class="comment"># 网站页脚文字</span></span><br><span class="line">    <span class="attr">site_footer:</span> <span class="string">&#x27;#666&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 卡片背景色</span></span><br><span class="line">    <span class="attr">card:</span> <span class="string">&#x27;#fff&#x27;</span></span><br><span class="line">    <span class="comment"># 卡片上的普通文字</span></span><br><span class="line">    <span class="attr">text:</span> <span class="string">&#x27;#444&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 区块和代码块背景色</span></span><br><span class="line">    <span class="attr">block:</span> <span class="string">&#x27;#f6f6f6&#x27;</span></span><br><span class="line">    <span class="comment"># 代码块高亮时的背景色</span></span><br><span class="line">    <span class="attr">codeblock:</span> <span class="string">&#x27;#FFF7EA&#x27;</span></span><br><span class="line">    <span class="comment"># 行内代码颜色</span></span><br><span class="line">    <span class="attr">inlinecode:</span> <span class="string">&#x27;#D56D28&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 文章部分</span></span><br><span class="line">    <span class="attr">h1:</span> <span class="string">&#x27;#444&#x27;</span></span><br><span class="line">    <span class="attr">h2:</span> <span class="string">&#x27;#444&#x27;</span></span><br><span class="line">    <span class="attr">h3:</span> <span class="string">&#x27;#444&#x27;</span></span><br><span class="line">    <span class="attr">h4:</span> <span class="string">&#x27;#444&#x27;</span></span><br><span class="line">    <span class="attr">h5:</span> <span class="string">&#x27;#444&#x27;</span></span><br><span class="line">    <span class="attr">h6:</span> <span class="string">&#x27;#444&#x27;</span></span><br><span class="line">    <span class="attr">p:</span> <span class="string">&#x27;#444&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 列表文字</span></span><br><span class="line">    <span class="attr">list:</span> <span class="string">&#x27;#666&#x27;</span></span><br><span class="line">    <span class="comment"># 列表 hover 时的文字</span></span><br><span class="line">    <span class="attr">list_hl:</span> <span class="string">&#x27;mix($color-theme, #000, 80)&#x27;</span></span><br><span class="line">    <span class="comment"># 辅助性文字</span></span><br><span class="line">    <span class="attr">meta:</span> <span class="string">&#x27;#888&#x27;</span></span><br><span class="line">  <span class="comment"># ------------</span></span><br><span class="line">  <span class="comment"># 暗色主题</span></span><br><span class="line">  <span class="attr">dark:</span></span><br><span class="line">    <span class="comment"># 网站背景色</span></span><br><span class="line">    <span class="attr">site_bg:</span> <span class="string">&#x27;#222&#x27;</span></span><br><span class="line">    <span class="comment"># 网站背景上的文字</span></span><br><span class="line">    <span class="attr">site_inner:</span> <span class="string">&#x27;#eee&#x27;</span></span><br><span class="line">    <span class="comment"># 网站页脚文字</span></span><br><span class="line">    <span class="attr">site_footer:</span> <span class="string">&#x27;#aaa&#x27;</span></span><br><span class="line">    <span class="comment"># 卡片背景色</span></span><br><span class="line">    <span class="attr">card:</span> <span class="string">&#x27;#444&#x27;</span></span><br><span class="line">    <span class="comment"># 卡片上的普通文字</span></span><br><span class="line">    <span class="attr">text:</span> <span class="string">&#x27;#eee&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 区块和代码块背景色</span></span><br><span class="line">    <span class="attr">block:</span> <span class="string">&#x27;#3a3a3a&#x27;</span></span><br><span class="line">    <span class="comment"># 代码块高亮时的背景色</span></span><br><span class="line">    <span class="attr">codeblock:</span> <span class="string">&#x27;#343a3c&#x27;</span></span><br><span class="line">    <span class="comment"># 行内代码颜色</span></span><br><span class="line">    <span class="attr">inlinecode:</span> <span class="string">&#x27;#D56D28&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 文章部分</span></span><br><span class="line">    <span class="attr">h1:</span> <span class="string">&#x27;#eee&#x27;</span></span><br><span class="line">    <span class="attr">h2:</span> <span class="string">&#x27;#eee&#x27;</span></span><br><span class="line">    <span class="attr">h3:</span> <span class="string">&#x27;#ddd&#x27;</span></span><br><span class="line">    <span class="attr">h4:</span> <span class="string">&#x27;#ddd&#x27;</span></span><br><span class="line">    <span class="attr">h5:</span> <span class="string">&#x27;#ddd&#x27;</span></span><br><span class="line">    <span class="attr">h6:</span> <span class="string">&#x27;#ddd&#x27;</span></span><br><span class="line">    <span class="attr">p:</span> <span class="string">&#x27;#bbb&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 列表文字</span></span><br><span class="line">    <span class="attr">list:</span> <span class="string">&#x27;#aaa&#x27;</span></span><br><span class="line">    <span class="comment"># 列表 hover 时的文字</span></span><br><span class="line">    <span class="attr">list_hl:</span> <span class="string">&#x27;mix($color-theme, #fff, 80)&#x27;</span></span><br><span class="line">    <span class="comment"># 辅助性文字</span></span><br><span class="line">    <span class="attr">meta:</span> <span class="string">&#x27;#888&#x27;</span></span><br><span class="line">    <span class="comment"># 夜间图片亮度</span></span><br><span class="line">    <span class="attr">brightness:</span> <span class="number">70</span><span class="string">%</span></span><br></pre></td></tr></table></figure><h3 id="自定义右键菜单"><a href="#自定义右键菜单" class="headerlink" title="自定义右键菜单"></a>自定义右键菜单</h3><p>自定义右键菜单自 <code>5.0.0-rc.8</code> 版本进行了全新重构，与历史版本相比，重构版右键菜单拥有更灵活的配置。</p><p>由于新版右键菜单配置较为复杂，原版菜单<strong>暂时性</strong>保留，在配置文件上新版右键以  <code>rightmenus</code> 命名。</p><blockquote><p><em>为了方面称呼，以<strong>新版右键</strong>代指重构版右键菜单，<strong>老版右键</strong>代指历史版本右键菜单。</em></p></blockquote><h4 id="差异对比"><a href="#差异对比" class="headerlink" title="差异对比"></a>差异对比</h4><p>新旧两版右键菜单的差异如下：</p><table><thead><tr><th>对比项</th><th>老版右键</th><th>新版右键</th></tr></thead><tbody><tr><td>自定义菜单项</td><td>只支持新增链接型菜单</td><td>同时支持事件型和链接型菜单</td></tr><tr><td>菜单项显示与顺序调整</td><td>部分支持</td><td>完全支持</td></tr><tr><td>内置菜单自定义调整</td><td>部分支持</td><td>完全支持修改文字描述、图标显示、功能实现等内容</td></tr><tr><td>自定义响应事件处理</td><td>不支持</td><td>支持自行添加</td></tr><tr><td>复制图片至剪切板</td><td>仅支持 PNG 格式图片</td><td>任意格式的图片</td></tr><tr><td>全局音乐控制</td><td>支持</td><td>支持</td></tr></tbody></table><h4 id="新版右键菜单"><a href="#新版右键菜单" class="headerlink" title="新版右键菜单"></a>新版右键菜单</h4><p>新版右键在菜单项上根据配置文件自行生成前端代码，所以统一了一个共用的菜单对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">id</span>: <span class="string">&#x27;&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;&#x27;</span>, <span class="attr">icon</span>: <span class="string">&#x27;&#x27;</span>, <span class="attr">link</span>: <span class="string">&#x27;&#x27;</span>, <span class="attr">event</span>: <span class="string">&#x27;&#x27;</span>, <span class="attr">group</span>: <span class="string">&#x27;&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><p>同时为了响应不同状态下的右键行为，提出了<strong>内置组</strong> （<code>defaultGroup</code>）的概念，相应的对于右键默认提供的功能实现则定义为<strong>内置实现</strong>（<code>defaultEvent</code>）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">defaultEvent</span>: [<span class="string">&#x27;copyText&#x27;</span>, <span class="string">&#x27;copyLink&#x27;</span>, <span class="string">&#x27;copyPaste&#x27;</span>, <span class="string">&#x27;copyAll&#x27;</span>, <span class="string">&#x27;copyCut&#x27;</span>, <span class="string">&#x27;copyImg&#x27;</span>, <span class="string">&#x27;printMode&#x27;</span>, <span class="string">&#x27;readMode&#x27;</span>],</span><br><span class="line">  <span class="attr">defaultGroup</span>: [<span class="string">&#x27;navigation&#x27;</span>, <span class="string">&#x27;inputBox&#x27;</span>, <span class="string">&#x27;seletctText&#x27;</span>, <span class="string">&#x27;elementCheck&#x27;</span>, <span class="string">&#x27;elementImage&#x27;</span>, <span class="string">&#x27;articlePage&#x27;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体来说，内置组对应右键行为，例如 <code>inputBox</code> 代表在输入框下右键行为；内置实现对应自定义右键默认提供的功能实现，例如 <code>readMode</code> 代表了阅读模式。</p><h5 id="参数解释"><a href="#参数解释" class="headerlink" title="参数解释"></a>参数解释</h5><figure class="highlight yml"><figcaption><span>plugins/menus 类的组内数据支持对象（单个菜单）或数组（一系列菜单）</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">rightmenus:</span></span><br><span class="line">  <span class="attr">order:</span></span><br><span class="line">    <span class="string">menus.groupName</span></span><br><span class="line">  <span class="attr">plugins:</span></span><br><span class="line">    <span class="string">defaultGroupItem</span></span><br><span class="line">  <span class="attr">menus:</span></span><br><span class="line">    <span class="attr">groupName:</span></span><br><span class="line">      <span class="bullet">-</span> &#123;<span class="string">menu</span>&#125;</span><br><span class="line">      <span class="bullet">-</span> &#123;<span class="string">menu</span>&#125;</span><br><span class="line">    <span class="attr">groupName1:</span> &#123;<span class="string">menu</span>&#125;</span><br></pre></td></tr></table></figure><h6 id="右键菜单加载"><a href="#右键菜单加载" class="headerlink" title="右键菜单加载"></a><strong>右键菜单加载</strong></h6><p>菜单的具体加载由 <code>order</code> 控制，可供使用的内容为：plugins.[组名], menus.[组名], hr, music 这四大类。</p><h6 id="右键菜单排序"><a href="#右键菜单排序" class="headerlink" title="右键菜单排序"></a><strong>右键菜单排序</strong></h6><p>菜单的排序由 <code>order</code> 字段的先后顺序和组内菜单项的先后顺序决定。</p><h6 id="右键菜单类"><a href="#右键菜单类" class="headerlink" title="右键菜单类"></a><strong>右键菜单类</strong></h6><p>菜单项共分为两大类：<code>plugins</code> 和 <code>menus</code>，前者放置内置组及内置菜单，允许添加&#x2F;修改组内菜单；后者为用户自建菜单类，允许添加&#x2F;修改组及组内菜单。一般意义上 plugins 类的组为动态组，根据实际的右键状态进行显示；menus 类中内容由用户添加，菜单项默认显示。</p><h6 id="右键菜单项"><a href="#右键菜单项" class="headerlink" title="右键菜单项"></a><strong>右键菜单项</strong></h6><p>菜单项共六个字段：<code>id</code>, <code>name</code>, <code>icon</code>, <code>link</code>, <code>event</code>, <code>group</code>，具体作用如下：</p><ul><li>id: 唯一值</li><li>name: 用于菜单名称显示</li><li>icon: 用于菜单图标显示</li><li>link: 跳转链接</li><li>event: 事件，当输入内容不为内置事件时，作 JavaScript 代码执行</li><li>group: 菜单项所处分组名称</li></ul><div class="note info"><p>note link&#x2F;event 二选一，同时出现时仅处理 link。</p></div><h5 id="内置功能"><a href="#内置功能" class="headerlink" title="内置功能"></a>内置功能</h5><h6 id="内置组"><a href="#内置组" class="headerlink" title="内置组"></a><strong>内置组</strong></h6><table><thead><tr><th>组名</th><th>描述</th><th>备注</th></tr></thead><tbody><tr><td><em>navigation</em></td><td><em>导航组件，横向排列，共用一行，仅显示图标</em></td><td><em>原则上支持的数量不限</em></td></tr><tr><td><em>inputBox</em></td><td><em>文本输入框相关组件</em></td><td><em>生效于 input&#x2F;textarea</em></td></tr><tr><td><em>seletctText</em></td><td><em>文本选中类组件</em></td><td><em>生效于右键选中文本，<strong>text</strong> 为选中的文本</em></td></tr><tr><td><em>elementCheck</em></td><td><em>链接判断组件</em></td><td><em>生效于链接处的右键行为，<strong>link</strong> 为链接地址</em></td></tr><tr><td><em>elementImage</em></td><td><em>图片判断类组件</em></td><td><em>生效于图片类的右键行为，<strong>link</strong> 为链接地址</em></td></tr><tr><td><em>articlePage</em></td><td><em>文章页面组件</em></td><td><em>生效于 post.article 页面</em></td></tr></tbody></table><div class="note info"><p>note 除 navigation 外的内置组，在显示时会隐藏含 link 属性的菜单项。</p></div><h6 id="内置实现"><a href="#内置实现" class="headerlink" title="内置实现"></a><strong>内置实现</strong></h6><table><thead><tr><th>事件名</th><th>描述</th><th>备注</th></tr></thead><tbody><tr><td><em>copyText</em></td><td>复制文本</td><td>复制选中文本</td></tr><tr><td><em>copyLink</em></td><td>复制链接地址</td><td>复制 <code>a</code> 或 <code>image</code> 下的链接至剪切板</td></tr><tr><td><em>copyPaste</em></td><td>粘贴文本</td><td>需要用户批准相应权限，仅支持粘贴文本至输入框（暂不支持粘贴图片）</td></tr><tr><td><em>copyAll</em></td><td>全选文本</td><td>选中输入框内的文本内容</td></tr><tr><td><em>copyCut</em></td><td>剪切文本</td><td>剪切输入框中选中的文本内容</td></tr><tr><td><em>copyImg</em></td><td>复制图片</td><td>支持 Chrome 浏览器，复制图片资源至剪切板</td></tr><tr><td><em>printMode</em></td><td>打印页面</td><td>一个调制过样式的打印功能</td></tr><tr><td><em>readMode</em></td><td>阅读模式</td><td>一个简单的阅读模式功能</td></tr></tbody></table><h5 id="默认设置"><a href="#默认设置" class="headerlink" title="默认设置"></a>默认设置</h5><h6 id="iconPrefix"><a href="#iconPrefix" class="headerlink" title="iconPrefix"></a><strong>iconPrefix<String></strong></h6><p>Fontawesome 图标前缀，音乐类组件使用，参考内容：<em>fa-solid, fa-regular, fa-light, fa-thin, fa-duotone, fa-brands</em>。</p><h6 id="articleShowLink"><a href="#articleShowLink" class="headerlink" title="articleShowLink"></a><strong>articleShowLink<Boolean></strong></h6><p>在 articlePage 组显示时（文章页）时依旧显示含 link 属性的菜单项。</p><h6 id="musicAlwaysShow"><a href="#musicAlwaysShow" class="headerlink" title="musicAlwaysShow"></a><strong>musicAlwaysShow<Boolean></strong></h6><p>当设定全局音乐播放器时，是否一直显示音乐控制菜单。false：仅当音乐播放时启用。</p><h6 id="corsAnywhere"><a href="#corsAnywhere" class="headerlink" title="corsAnywhere"></a><strong>corsAnywhere<String></strong></h6><p>适用于复制图片文件的场景，当图片源未设置 Access-Control-Allow-Origin 时，图片复制由于 CORS 问题失败。</p><p>你可以自行部署相应项目解决该问题，详见：<a href="https://github.com/Rob--W/cors-anywhere">Rob–W&#x2F;cors-anywhere</a> 或者 <a href="https://github.com/Zibri/cloudflare-cors-anywhere">Zibri&#x2F;cloudflare-cors-anywhere</a>。</p><h5 id="回调方法"><a href="#回调方法" class="headerlink" title="回调方法"></a>回调方法</h5><p><strong><code>volantis.rightmenu.handle</code></strong> 在右键菜单打开时执行。</p><p>volantis.rightmenu.handle(callBack[,”callBackName”, “setRequestAnimationFrame &#x3D; true”])。</p><p>此外，你还可以在 <code>volantis.mouseEvent</code> 处获得 MouseEvent 信息。</p><h5 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h5><details ><summary> blog/_config.volantis.yml </summary>              <div class='content'>              <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### 自定义右键 新</span></span><br><span class="line"><span class="attr">rightmenus:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 右键菜单项及加载顺序</span></span><br><span class="line">  <span class="comment"># 内容示例：plugins.[组名], menus.[组名], hr(分割线，推荐去线留白), music(音乐控制器)</span></span><br><span class="line">  <span class="attr">order:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="string">plugins.navigation</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">hr</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">plugins.inputBox</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">plugins.seletctText</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">plugins.elementCheck</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">plugins.elementImage</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">menus.link</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">hr</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">menus.darkMode</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">plugins.articlePage</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">music</span></span><br><span class="line">  <span class="comment">############################</span></span><br><span class="line">  <span class="comment"># - &#123;id: &#x27;&#x27;, name: &#x27;&#x27;, icon: &#x27;&#x27;, link: &#x27;&#x27;, event: &#x27;&#x27;, group: &#x27;&#x27;&#125;</span></span><br><span class="line">  <span class="comment"># id: 唯一值</span></span><br><span class="line">  <span class="comment"># name: 用于菜单名称显示</span></span><br><span class="line">  <span class="comment"># icon: 用于菜单图标显示</span></span><br><span class="line">  <span class="comment"># link: 跳转链接</span></span><br><span class="line">  <span class="comment"># event: 事件，当输入内容不为内置事件时，作 JavaScript 代码执行</span></span><br><span class="line">  <span class="comment"># group: 菜单项所处分组名称</span></span><br><span class="line">  <span class="comment"># 注： </span></span><br><span class="line">  <span class="comment"># 1. link/event 二选一，同时出现时仅处理 link</span></span><br><span class="line">  <span class="comment"># 2. 内置事件列表： copyText, copyLink, copyPaste, copyAll, copyCut, copyImg, printMode, readMode</span></span><br><span class="line">  <span class="comment"># 3. 内置组列表：navigation, inputBox, seletctText, elementCheck, elementImage, articlePage</span></span><br><span class="line">  <span class="comment"># 4. plugins 列允许自定义组内项目</span></span><br><span class="line">  <span class="comment"># 5. menus   列允许自定义组及其内容</span></span><br><span class="line">  <span class="comment"># 6. 除 navigation 外的内置组，在显示时会隐藏含 link 属性的菜单项</span></span><br><span class="line">  <span class="comment">###########################</span></span><br><span class="line">  <span class="comment"># 基础项设置</span></span><br><span class="line">  <span class="attr">options:</span></span><br><span class="line">    <span class="comment"># 图标前缀 fa-solid, fa-regular, fa-light, fa-thin, fa-duotone, fa-brands</span></span><br><span class="line">    <span class="attr">iconPrefix:</span> <span class="string">fa-solid</span></span><br><span class="line">    <span class="comment"># 例外，在 articlePage 组显示时（文章页）时依旧显示含 link 属性的菜单项</span></span><br><span class="line">    <span class="attr">articleShowLink:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># 当设定全局音乐播放器时，是否一直显示音乐控制菜单。false：仅当音乐播放时启用</span></span><br><span class="line">    <span class="attr">musicAlwaysShow:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># 适用于复制图片文件的场景，当图片源未设置 Access-Control-Allow-Origin 时，图片复制由于 CORS 问题失败</span></span><br><span class="line">    <span class="comment"># 你可以自行部署相应项目解决该问题，详见：https://github.com/Rob--W/cors-anywhere 或者 https://github.com/Zibri/cloudflare-cors-anywhere</span></span><br><span class="line">    <span class="attr">corsAnywhere:</span> </span><br><span class="line">  <span class="comment"># 右键内置组，预置实现</span></span><br><span class="line">  <span class="attr">plugins:</span></span><br><span class="line">    <span class="comment"># 导航组件</span></span><br><span class="line">    <span class="comment"># 横向排列，共用一行，仅显示图标 (原则上支持的数量不限)</span></span><br><span class="line">    <span class="attr">navigation:</span> </span><br><span class="line">      <span class="bullet">-</span> &#123;<span class="attr">id:</span> <span class="string">&#x27;left&#x27;</span>, <span class="attr">name:</span> <span class="string">&#x27;转到上一页&#x27;</span>, <span class="attr">icon:</span> <span class="string">&#x27;fa-solid fa-arrow-left&#x27;</span>, <span class="attr">event:</span> <span class="string">&#x27;history.back()&#x27;</span>, <span class="attr">group:</span> <span class="string">&#x27;navigation&#x27;</span>&#125;</span><br><span class="line">      <span class="bullet">-</span> &#123;<span class="attr">id:</span> <span class="string">&#x27;right&#x27;</span>, <span class="attr">name:</span> <span class="string">&#x27;转到下一页&#x27;</span>, <span class="attr">icon:</span> <span class="string">&#x27;fa-solid fa-arrow-right&#x27;</span>, <span class="attr">event:</span> <span class="string">&#x27;history.forward()&#x27;</span>, <span class="attr">group:</span> <span class="string">&#x27;navigation&#x27;</span>&#125;</span><br><span class="line">      <span class="bullet">-</span> &#123;<span class="attr">id:</span> <span class="string">&#x27;redo&#x27;</span>, <span class="attr">name:</span> <span class="string">&#x27;刷新当前页面&#x27;</span>, <span class="attr">icon:</span> <span class="string">&#x27;fa-solid fa-redo&#x27;</span>, <span class="attr">event:</span> <span class="string">&#x27;window.location.reload()&#x27;</span>, <span class="attr">group:</span> <span class="string">&#x27;navigation&#x27;</span>&#125;</span><br><span class="line">      <span class="bullet">-</span> &#123;<span class="attr">id:</span> <span class="string">&#x27;up&#x27;</span>, <span class="attr">name:</span> <span class="string">&#x27;回到顶部&#x27;</span>, <span class="attr">icon:</span> <span class="string">&#x27;fa-solid fa-arrow-up&#x27;</span>, <span class="attr">event:</span> <span class="string">&#x27;VolantisApp.scrolltoElement(volantis.dom.bodyAnchor)&#x27;</span>, <span class="attr">group:</span> <span class="string">&#x27;navigation&#x27;</span>&#125;</span><br><span class="line">      <span class="comment">#- &#123;id: &#x27;home&#x27;, name: &#x27;回到首页&#x27;, icon: &#x27;fa-solid fa-home&#x27;, link: &#x27;/&#x27;, group: &#x27;navigation&#x27;&#125;</span></span><br><span class="line">    <span class="comment"># 文本输入框相关组件</span></span><br><span class="line">    <span class="comment"># 生效于 input/textarea，粘贴、剪切、全选</span></span><br><span class="line">    <span class="attr">inputBox:</span></span><br><span class="line">      <span class="bullet">-</span> &#123;<span class="attr">id:</span> <span class="string">&#x27;copyPaste&#x27;</span>, <span class="attr">name:</span> <span class="string">&#x27;粘贴文本&#x27;</span>, <span class="attr">icon:</span> <span class="string">&#x27;fa-solid fa-paste&#x27;</span>, <span class="attr">event:</span> <span class="string">&#x27;copyPaste&#x27;</span>, <span class="attr">group:</span> <span class="string">&#x27;inputBox&#x27;</span>&#125;</span><br><span class="line">      <span class="bullet">-</span> &#123;<span class="attr">id:</span> <span class="string">&#x27;copyAll&#x27;</span>, <span class="attr">name:</span> <span class="string">&#x27;全选文本&#x27;</span>, <span class="attr">icon:</span> <span class="string">&#x27;fa-solid fa-object-ungroup&#x27;</span>, <span class="attr">event:</span> <span class="string">&#x27;copyAll&#x27;</span>, <span class="attr">group:</span> <span class="string">&#x27;inputBox&#x27;</span>&#125;</span><br><span class="line">      <span class="bullet">-</span> &#123;<span class="attr">id:</span> <span class="string">&#x27;copyCut&#x27;</span>, <span class="attr">name:</span> <span class="string">&#x27;剪切文本&#x27;</span>, <span class="attr">icon:</span> <span class="string">&#x27;fa-solid fa-cut&#x27;</span>, <span class="attr">event:</span> <span class="string">&#x27;copyCut&#x27;</span>, <span class="attr">group:</span> <span class="string">&#x27;inputBox&#x27;</span>&#125;</span><br><span class="line">    <span class="comment"># 文本选中类组件</span></span><br><span class="line">    <span class="comment"># 生效于右键选中文本，__text__ 为选中的文本。     </span></span><br><span class="line">    <span class="attr">seletctText:</span></span><br><span class="line">      <span class="bullet">-</span> &#123;<span class="attr">id:</span> <span class="string">&#x27;copyText&#x27;</span>, <span class="attr">name:</span> <span class="string">&#x27;复制文本&#x27;</span>, <span class="attr">icon:</span> <span class="string">&#x27;fa-solid fa-copy&#x27;</span>, <span class="attr">event:</span> <span class="string">&#x27;copyText&#x27;</span>, <span class="attr">group:</span> <span class="string">&#x27;seletctText&#x27;</span>&#125;</span><br><span class="line">      <span class="bullet">-</span> &#123;<span class="attr">id:</span> <span class="string">&#x27;searchWord&#x27;</span>, <span class="attr">name:</span> <span class="string">&#x27;站内搜索&#x27;</span>, <span class="attr">icon:</span> <span class="string">&#x27;fa-solid fa-search&#x27;</span>, <span class="attr">event:</span> <span class="string">&#x27;OpenSearch(__text__)&#x27;</span>, <span class="attr">group:</span> <span class="string">&#x27;seletctText&#x27;</span>&#125;</span><br><span class="line">      <span class="bullet">-</span> &#123;<span class="attr">id:</span> <span class="string">&#x27;bingSearch&#x27;</span>, <span class="attr">name:</span> <span class="string">&#x27;必应搜索&#x27;</span>, <span class="attr">icon:</span> <span class="string">&#x27;fa-solid fa-search&#x27;</span>, <span class="attr">event:</span> <span class="string">&#x27;window.open(`https://cn.bing.com/search?q=$&#123;__text__&#125;`)&#x27;</span>, <span class="attr">group:</span> <span class="string">&#x27;seletctText&#x27;</span>&#125;</span><br><span class="line">      <span class="comment">#- &#123;id: &#x27;googleSearch&#x27;, name: &#x27;谷歌搜索&#x27;, icon: &#x27;fa-solid fa-search&#x27;, event: &#x27;window.open(`https://www.google.com/search?q=$&#123;__text__&#125;`)&#x27;, group: &#x27;seletctText&#x27;&#125;</span></span><br><span class="line">    <span class="comment"># 链接判断组件</span></span><br><span class="line">    <span class="comment"># 生效于链接处的右键行为，__link__ 为链接地址</span></span><br><span class="line">    <span class="attr">elementCheck:</span></span><br><span class="line">      <span class="bullet">-</span> &#123;<span class="attr">id:</span> <span class="string">&#x27;openTab&#x27;</span>, <span class="attr">name:</span> <span class="string">&#x27;新标签页打开&#x27;</span>, <span class="attr">icon:</span> <span class="string">&#x27;fa-solid fa-external-link-square-alt&#x27;</span>, <span class="attr">event:</span> <span class="string">&#x27;window.open(__link__)&#x27;</span>, <span class="attr">group:</span> <span class="string">&#x27;elementCheck&#x27;</span>&#125;</span><br><span class="line">      <span class="bullet">-</span> &#123;<span class="attr">id:</span> <span class="string">&#x27;copyLink&#x27;</span>, <span class="attr">name:</span> <span class="string">&#x27;复制链接地址&#x27;</span>, <span class="attr">icon:</span> <span class="string">&#x27;fa-solid fa-link&#x27;</span>, <span class="attr">event:</span> <span class="string">&#x27;copyLink&#x27;</span>, <span class="attr">group:</span> <span class="string">&#x27;elementCheck&#x27;</span>&#125;</span><br><span class="line">    <span class="comment"># 图片判断类组件</span></span><br><span class="line">    <span class="comment"># 生效于图片类的右键行为，__link__ 为链接地址</span></span><br><span class="line">    <span class="attr">elementImage:</span></span><br><span class="line">      <span class="bullet">-</span> &#123;<span class="attr">id:</span> <span class="string">&#x27;copyImg&#x27;</span>, <span class="attr">name:</span> <span class="string">&#x27;复制图片&#x27;</span>, <span class="attr">icon:</span> <span class="string">&#x27;fa-solid fa-image&#x27;</span>, <span class="attr">event:</span> <span class="string">&#x27;copyImg&#x27;</span>, <span class="attr">group:</span> <span class="string">&#x27;elementImage&#x27;</span>&#125;</span><br><span class="line">      <span class="bullet">-</span> &#123;<span class="attr">id:</span> <span class="string">&#x27;googleImg&#x27;</span>, <span class="attr">name:</span> <span class="string">&#x27;谷歌识图&#x27;</span>, <span class="attr">icon:</span> <span class="string">&#x27;fa-solid fa-images&#x27;</span>, <span class="attr">event:</span> <span class="string">&#x27;window.open(`https://www.google.com.hk/searchbyimage?image_url=$&#123;__link__&#125;`)&#x27;</span>, <span class="attr">group:</span> <span class="string">&#x27;elementImage&#x27;</span>&#125;</span><br><span class="line">    <span class="comment"># 文章页面组件</span></span><br><span class="line">    <span class="comment"># 生效于 post.article 页面</span></span><br><span class="line">    <span class="attr">articlePage:</span></span><br><span class="line">      <span class="bullet">-</span> &#123;<span class="attr">id:</span> <span class="string">&#x27;printMode&#x27;</span>, <span class="attr">name:</span> <span class="string">&#x27;打印页面&#x27;</span>, <span class="attr">icon:</span> <span class="string">&#x27;fa-solid fa-print&#x27;</span>, <span class="attr">event:</span> <span class="string">&#x27;printMode&#x27;</span>, <span class="attr">group:</span> <span class="string">&#x27;articlePage&#x27;</span>&#125;</span><br><span class="line">      <span class="bullet">-</span> &#123;<span class="attr">id:</span> <span class="string">&#x27;readMode&#x27;</span>, <span class="attr">name:</span> <span class="string">&#x27;阅读模式&#x27;</span>, <span class="attr">icon:</span> <span class="string">&#x27;fa-solid fa-book-open&#x27;</span>, <span class="attr">event:</span> <span class="string">&#x27;readMode&#x27;</span>, <span class="attr">group:</span> <span class="string">&#x27;articlePage&#x27;</span>&#125;</span><br><span class="line">  <span class="comment"># 右键自定义菜单区域</span></span><br><span class="line">  <span class="attr">menus:</span></span><br><span class="line">    <span class="attr">link:</span></span><br><span class="line">      <span class="bullet">-</span> &#123;<span class="attr">id:</span> <span class="string">&#x27;help&#x27;</span>, <span class="attr">name:</span> <span class="string">&#x27;常见问题&#x27;</span>, <span class="attr">icon:</span> <span class="string">&#x27;fa-solid fa-question&#x27;</span>, <span class="attr">link:</span> <span class="string">&#x27;https://volantis.js.org/faqs/&#x27;</span>, <span class="attr">group:</span> <span class="string">&#x27;link&#x27;</span>&#125;</span><br><span class="line">      <span class="bullet">-</span> &#123;<span class="attr">id:</span> <span class="string">&#x27;examples&#x27;</span>, <span class="attr">name:</span> <span class="string">&#x27;示例博客&#x27;</span>, <span class="attr">icon:</span> <span class="string">&#x27;fa-solid fa-rss&#x27;</span>, <span class="attr">link:</span> <span class="string">&#x27;https://volantis.js.org/examples/&#x27;</span>, <span class="attr">group:</span> <span class="string">&#x27;link&#x27;</span>&#125;</span><br><span class="line">      <span class="bullet">-</span> &#123;<span class="attr">id:</span> <span class="string">&#x27;contributors&#x27;</span>, <span class="attr">name:</span> <span class="string">&#x27;加入社区&#x27;</span>, <span class="attr">icon:</span> <span class="string">&#x27;fa-solid fa-fan&#x27;</span>, <span class="attr">link:</span> <span class="string">&#x27;https://volantis.js.org/contributors/&#x27;</span>, <span class="attr">group:</span> <span class="string">&#x27;link&#x27;</span>&#125;</span><br><span class="line">      <span class="bullet">-</span> <span class="string">hr</span></span><br><span class="line">      <span class="bullet">-</span> &#123;<span class="attr">id:</span> <span class="string">&#x27;source_docs&#x27;</span>, <span class="attr">name:</span> <span class="string">&#x27;本站源码&#x27;</span>, <span class="attr">icon:</span> <span class="string">&#x27;fa-solid fa-code-branch&#x27;</span>, <span class="attr">link:</span> <span class="string">&#x27;https://github.com/volantis-x/volantis-docs/&#x27;</span>, <span class="attr">group:</span> <span class="string">&#x27;link&#x27;</span>&#125;</span><br><span class="line">      <span class="bullet">-</span> &#123;<span class="attr">id:</span> <span class="string">&#x27;source_theme&#x27;</span>, <span class="attr">name:</span> <span class="string">&#x27;主题源码&#x27;</span>, <span class="attr">icon:</span> <span class="string">&#x27;fa-solid fa-code-branch&#x27;</span>, <span class="attr">link:</span> <span class="string">&#x27;https://github.com/volantis-x/hexo-theme-volantis/&#x27;</span>, <span class="attr">group:</span> <span class="string">&#x27;link&#x27;</span>&#125;</span><br><span class="line">    <span class="attr">darkMode:</span> </span><br><span class="line">      <span class="bullet">-</span> &#123;<span class="attr">id:</span> <span class="string">&#x27;darkMode&#x27;</span>, <span class="attr">name:</span> <span class="string">&#x27;暗黑模式&#x27;</span>, <span class="attr">icon:</span> <span class="string">&#x27;fa-solid fa-moon&#x27;</span>, <span class="attr">event:</span> <span class="string">&#x27;volantis.dark.toggle()&#x27;</span>, <span class="attr">group:</span> <span class="string">&#x27;darkMode&#x27;</span>&#125;</span><br><span class="line"><span class="comment">###</span></span><br></pre></td></tr></table></figure>              </div>            </details><h5 id="高级玩法"><a href="#高级玩法" class="headerlink" title="高级玩法"></a>高级玩法</h5><p>可以利用 <em>Custom Files 自定义文件</em> 功能，实现自定义右键菜单脚本及菜单项控制。</p><ul><li>一个在右键菜单中添加 <strong>查看上一篇</strong>、<strong>查看下一篇</strong> 菜单项的范例：</li></ul><div class="tabs" id="tab-rightmenus"><ul class="nav-tabs"><li class="tab active"><a class="#rightmenus-1">blog/_config.volantis.yml</a></li><li class="tab"><a class="#rightmenus-2">blog/source/_volantis/bodyEnd.ejs</a></li></ul><div class="tab-content"><div class="tab-pane active" id="rightmenus-1"><figure class="highlight yml"><figcaption><span>省略了部分不相关内容</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">rightmenus:</span></span><br><span class="line">  <span class="attr">order:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">menus.prevNext</span></span><br><span class="line">  <span class="attr">menus:</span></span><br><span class="line">    <span class="attr">prevNext:</span></span><br><span class="line">      <span class="bullet">-</span> &#123;<span class="attr">id:</span> <span class="string">&#x27;prev&#x27;</span>, <span class="attr">name:</span> <span class="string">&#x27;查看上一篇&#x27;</span>, <span class="attr">icon:</span> <span class="string">&#x27;fa-solid fa-angles-left&#x27;</span>, <span class="attr">event:</span> <span class="string">&quot;volantis.rightmenu.jump(&#x27;prev&#x27;)&quot;</span>, <span class="attr">group:</span> <span class="string">&#x27;prevNext&#x27;</span>&#125;</span><br><span class="line">      <span class="bullet">-</span> &#123;<span class="attr">id:</span> <span class="string">&#x27;next&#x27;</span>, <span class="attr">name:</span> <span class="string">&#x27;查看下一篇&#x27;</span>, <span class="attr">icon:</span> <span class="string">&#x27;fa-solid fa-angles-right&#x27;</span>, <span class="attr">event:</span> <span class="string">&quot;volantis.rightmenu.jump(&#x27;next&#x27;)&quot;</span>, <span class="attr">group:</span> <span class="string">&#x27;prevNext&#x27;</span>&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="rightmenus-2"><figure class="highlight js"><figcaption><span>为了方便管理，将函数挂在 volantis.rightmenu 对象下</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt; </span><br><span class="line">  volantis.<span class="property">rightmenu</span>.<span class="property">jump</span> = <span class="function">(<span class="params">type</span>) =&gt;</span> &#123; </span><br><span class="line">    <span class="keyword">const</span> selector = type === <span class="string">&#x27;prev&#x27;</span> ? <span class="string">&#x27;article .prev-next a.prev&#x27;</span> : <span class="string">&#x27;article .prev-next a.next&#x27;</span>;</span><br><span class="line">    <span class="keyword">const</span> item = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(selector); </span><br><span class="line">    <span class="keyword">if</span>(!!item) &#123; </span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">typeof</span> pjax !== <span class="string">&#x27;undefined&#x27;</span>) &#123; </span><br><span class="line">        pjax.<span class="title function_">loadUrl</span>(item.<span class="property">href</span>) </span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span> = item.<span class="property">href</span>; </span><br><span class="line">      &#125; </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line"> </span><br><span class="line">  volantis.<span class="property">rightmenu</span>.<span class="title function_">handle</span>(<span class="function">() =&gt;</span> &#123; </span><br><span class="line">    <span class="keyword">const</span> prev = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#prev&#x27;</span>).<span class="property">parentElement</span>, </span><br><span class="line">      next = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#next&#x27;</span>).<span class="property">parentElement</span>, </span><br><span class="line">      articlePrev = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;article .prev-next a.prev p.title&#x27;</span>), </span><br><span class="line">      articleNext = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;article .prev-next a.next p.title&#x27;</span>); </span><br><span class="line"> </span><br><span class="line">    prev.<span class="property">style</span>.<span class="property">display</span> = articlePrev ? <span class="string">&#x27;block&#x27;</span> : <span class="string">&#x27;none&#x27;</span>; </span><br><span class="line">    prev.<span class="property">title</span> = articlePrev ? articlePrev.<span class="property">innerText</span> : <span class="literal">null</span>; </span><br><span class="line">    next.<span class="property">style</span>.<span class="property">display</span> = articleNext ? <span class="string">&#x27;block&#x27;</span> : <span class="string">&#x27;none&#x27;</span>; </span><br><span class="line">    next.<span class="property">title</span> = articleNext ? articleNext.<span class="property">innerText</span> : <span class="literal">null</span>; </span><br><span class="line">  &#125;, <span class="string">&#x27;prevNext&#x27;</span>, <span class="literal">false</span>) </span><br><span class="line">&lt;/script&gt; </span><br></pre></td></tr></table></figure></div></div></div><h4 id="老版右键菜单"><a href="#老版右键菜单" class="headerlink" title="老版右键菜单"></a>老版右键菜单</h4><p>目前老版右键与新版右键共存，但同时只能开启一个自定义右键菜单。</p><h5 id="配置文件-1"><a href="#配置文件-1" class="headerlink" title="配置文件"></a>配置文件</h5><details ><summary> blog/_config.volantis.yml </summary>              <div class='content'>              <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自定义右键菜单</span></span><br><span class="line"><span class="attr">rightmenu:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">faicon:</span> <span class="string">fa</span>              <span class="comment"># 公共图标类型 fa fal fa-solid fa-duotone</span></span><br><span class="line">  <span class="comment"># hr: 分割线, music: 音乐控制器</span></span><br><span class="line">  <span class="attr">layout:</span> [<span class="string">home</span>, <span class="string">hr</span>, <span class="string">help</span>, <span class="string">examples</span>, <span class="string">contributors</span>, <span class="string">hr</span>, <span class="string">source_docs</span>, <span class="string">source_theme</span>, <span class="string">hr</span>, <span class="string">print</span>, <span class="string">darkmode</span>, <span class="string">reading</span>, <span class="string">music</span>]</span><br><span class="line">  <span class="comment">### 可选功能项 ###</span></span><br><span class="line">  <span class="attr">print:</span>                  <span class="comment"># 只有文章页才允许自定义打印</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">打印页面</span></span><br><span class="line">    <span class="attr">icon:</span> <span class="string">fa</span> <span class="string">fa-print</span></span><br><span class="line">  <span class="attr">darkmode:</span>        <span class="comment"># 需开启 plugins.darkmodejs</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">暗黑模式</span></span><br><span class="line">    <span class="attr">icon:</span> <span class="string">fa</span> <span class="string">fa-moon</span></span><br><span class="line">  <span class="attr">reading:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">阅读模式</span></span><br><span class="line">    <span class="attr">icon:</span> <span class="string">fa</span> <span class="string">fa-book-open</span></span><br><span class="line">  <span class="attr">customPicUrl:</span>    <span class="comment"># 右键的图片复制：只有 Chrome 支持，且只支持 PNG 格式的图片。</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span>  <span class="comment"># 如果使用了对象存储且开启了自适应 Webp，那么可以提供额外的链接用以替换图片的访问地址</span></span><br><span class="line">    <span class="attr">old:</span> <span class="comment">#https://static.inkss.cn/img/article/</span></span><br><span class="line">    <span class="attr">new:</span> <span class="comment">#https://cdn.jsdelivr.net/gh/inkss/inkss-cdn@master/img/article/</span></span><br><span class="line">  <span class="attr">music:</span>           <span class="comment"># 当设定全局音乐播放器时，是否一直显示音乐控制菜单。false：仅当音乐播放时启用</span></span><br><span class="line">    <span class="attr">alwaysShow:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment">### 自定义菜单 ###</span></span><br><span class="line">  <span class="attr">help:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">常见问题</span></span><br><span class="line">    <span class="attr">icon:</span> <span class="string">fa</span> <span class="string">fa-question</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">https://volantis.js.org/faqs/</span></span><br><span class="line">  <span class="attr">examples:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">示例博客</span></span><br><span class="line">    <span class="attr">icon:</span> <span class="string">fa</span> <span class="string">fa-rss</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">https://volantis.js.org/examples/</span></span><br><span class="line">  <span class="attr">contributors:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">加入社区</span></span><br><span class="line">    <span class="attr">icon:</span> <span class="string">fa</span> <span class="string">fa-fan</span> <span class="string">fa-spin</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">https://volantis.js.org/contributors/</span></span><br><span class="line">  <span class="attr">source_docs:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">本站源码</span></span><br><span class="line">    <span class="attr">icon:</span> <span class="string">fa</span> <span class="string">fa-code-branch</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">https://github.com/volantis-x/volantis-docs/</span></span><br><span class="line">  <span class="attr">source_theme:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">主题源码</span></span><br><span class="line">    <span class="attr">icon:</span> <span class="string">fa</span> <span class="string">fa-code-branch</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">https://github.com/volantis-x/hexo-theme-volantis/</span></span><br><span class="line"><span class="comment">####</span></span><br></pre></td></tr></table></figure>              </div>            </details><h2 id="设置网站导航栏"><a href="#设置网站导航栏" class="headerlink" title="设置网站导航栏"></a>设置网站导航栏</h2><h3 id="导航栏配置"><a href="#导航栏配置" class="headerlink" title="导航栏配置"></a>导航栏配置</h3><p>导航栏分为 logo、menu、search 三个区域设置，其中 logo 区域如果设置了图片，则不能显示图标和标题， menu 区域的设置可以写在一个单独的文件中。</p><figure class="highlight yaml"><figcaption><span>blog/_config.volantis.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意事项：建议规范全站路径 URL 最后带一个 &quot;/&quot; 例如 &quot;about/&quot;</span></span><br><span class="line"><span class="attr">navbar:</span></span><br><span class="line">  <span class="attr">visiable:</span> <span class="string">auto</span> <span class="comment"># always, auto</span></span><br><span class="line">  <span class="attr">logo:</span> <span class="comment"># choose [img] or [icon + title]</span></span><br><span class="line">    <span class="attr">img:</span> <span class="string">volantis-static/media/org.volantis/blog/Logo-NavBar@3x.png</span> <span class="comment"># https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/Logo-NavBar@3x.png</span></span><br><span class="line">    <span class="attr">icon:</span></span><br><span class="line">    <span class="attr">title:</span></span><br><span class="line">  <span class="attr">menu:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">博客</span></span><br><span class="line">      <span class="attr">icon:</span> <span class="string">fa-solid</span> <span class="string">fa-rss</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">/</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">分类</span></span><br><span class="line">      <span class="attr">icon:</span> <span class="string">fa-solid</span> <span class="string">fa-folder-open</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">categories/</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">标签</span></span><br><span class="line">      <span class="attr">icon:</span> <span class="string">fa-solid</span> <span class="string">fa-tags</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">tags/</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">归档</span></span><br><span class="line">      <span class="attr">icon:</span> <span class="string">fa-solid</span> <span class="string">fa-archive</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">archives/</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">友链</span></span><br><span class="line">      <span class="attr">icon:</span> <span class="string">fa-solid</span> <span class="string">fa-link</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">friends/</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">关于</span></span><br><span class="line">      <span class="attr">icon:</span> <span class="string">fa-solid</span> <span class="string">fa-info-circle</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">about/</span></span><br><span class="line">  <span class="attr">search:</span> <span class="string">Search...</span>   <span class="comment"># Search bar placeholder</span></span><br></pre></td></tr></table></figure><h3 id="菜单嵌套"><a href="#菜单嵌套" class="headerlink" title="菜单嵌套"></a>菜单嵌套</h3><p>导航栏菜单支持嵌套，嵌套的属性名为 <code>rows</code> ，写法示例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">...</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">更多</span></span><br><span class="line">  <span class="attr">icon:</span> <span class="string">fa-solid</span> <span class="string">fa-ellipsis-v</span></span><br><span class="line">  <span class="attr">rows:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">主题源码</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">https://github.com/volantis-x/hexo-theme-volantis/</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">更新日志</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">https://github.com/volantis-x/hexo-theme-volantis/releases/</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">hr</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">有疑问？</span></span><br><span class="line">      <span class="attr">rows:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">看</span> <span class="string">FAQ</span></span><br><span class="line">          <span class="attr">url:</span> <span class="string">faqs/</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">看</span> <span class="string">本站源码</span></span><br><span class="line">          <span class="attr">url:</span> <span class="string">https://github.com/volantis-x/volantis-docs/</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">提</span> <span class="string">Issue</span></span><br><span class="line">          <span class="attr">url:</span> <span class="string">https://github.com/volantis-x/hexo-theme-volantis/issues/</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">hr</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">公告和测试博文</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">archives/</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">示例博客</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">examples/</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">特别感谢</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">contributors/</span></span><br></pre></td></tr></table></figure><h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><p>在子菜单中，新增一个只有 <code>name: hr</code> 的“菜单”就会被渲染成一个分割线。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">hr</span></span><br></pre></td></tr></table></figure><h3 id="小标题"><a href="#小标题" class="headerlink" title="小标题"></a>小标题</h3><p>在子菜单中，新增一个只有 <code>name: 小标题内容</code>（也可以有 <code>icon: 小标题的图标</code>）的“菜单”就会被渲染成一个小标题。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">...</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">近期</span></span><br><span class="line">  <span class="attr">icon:</span> <span class="string">fa-solid</span> <span class="string">fa-clock</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">/</span></span><br><span class="line">  <span class="attr">rows:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">热门文章</span></span><br><span class="line">      <span class="attr">icon:</span> <span class="string">fa-solid</span> <span class="string">fa-fire</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ProHUD</span> <span class="string">开源库的设计思路</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">blog/2019-08-27-prohud/</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ValueX：实用的安全对象类型转换库</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">blog/2019-08-29-valuex/</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">心率管家</span> <span class="string">App</span> <span class="string">的设计与开发</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">blog/2019-07-23-heartmate/</span></span><br></pre></td></tr></table></figure><h3 id="播放器"><a href="#播放器" class="headerlink" title="播放器"></a>播放器</h3><p>在子菜单中，新增一个 <code>icon: fa-solid fa-compact-disc</code> 的“菜单”就会被渲染成一个 APlayer 播放器。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">背景音乐</span></span><br><span class="line">  <span class="attr">icon:</span> <span class="string">fa-solid</span> <span class="string">fa-compact-disc</span></span><br></pre></td></tr></table></figure><h2 id="设置网站页脚"><a href="#设置网站页脚" class="headerlink" title="设置网站页脚"></a>设置网站页脚</h2><p>您通过 <code>layout</code> 可以自由布局网站页脚内容 <code>aplayer</code>, <code>social</code>, <code>license</code>, <code>info</code>, <code>copyright</code>。</p><figure class="highlight yaml"><figcaption><span>blog/_config.volantis.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">site_footer:</span></span><br><span class="line">  <span class="comment"># layout of footer: [aplayer, social, license, info, copyright]</span></span><br><span class="line">  <span class="attr">layout:</span> [<span class="string">aplayer</span>, <span class="string">social</span>, <span class="string">license</span>, <span class="string">info</span>, <span class="string">copyright</span>]</span><br><span class="line">  <span class="attr">social:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-rss</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">atom.xml</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-envelope</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">mailto:me@xaoxuu.com</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">icon:</span> <span class="string">fab</span> <span class="string">fa-github</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">https://github.com/xaoxuu</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-headphones-alt</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">https://music.163.com/#/user/home?id=63035382</span></span><br><span class="line">  <span class="attr">copyright:</span> <span class="string">&#x27;[Copyright © 2017-2021 XXX](/)&#x27;</span></span><br><span class="line">  <span class="comment"># You can add your own property here. (Support markdown, for example: br: &#x27;&lt;br&gt;&#x27;)</span></span><br><span class="line">  <span class="attr">br:</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span></span><br></pre></td></tr></table></figure><p>其中，<code>aplayer</code> 需要在插件部分设置中启用。您可以新增文字属性，用于展示其它文字信息，例如：</p><figure class="highlight yaml"><figcaption><span>blog/_config.volantis.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">site_footer:</span></span><br><span class="line">  <span class="attr">layout:</span> [<span class="string">...</span>, <span class="string">br</span>, <span class="string">hello</span>, <span class="string">...</span>]</span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="comment"># You can add your own property here. (Support markdown, for example: br: &#x27;&lt;br&gt;&#x27;)</span></span><br><span class="line">  <span class="attr">br:</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span></span><br><span class="line">  <span class="attr">hello:</span> <span class="string">&#x27;[Hello World](/)&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="网站与文章封面"><a href="#网站与文章封面" class="headerlink" title="网站与文章封面"></a>网站与文章封面</h2><h3 id="封面高度"><a href="#封面高度" class="headerlink" title="封面高度"></a>封面高度</h3><figure class="highlight yaml"><figcaption><span>blog/_config.volantis.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cover:</span></span><br><span class="line">  <span class="attr">height_scheme:</span> <span class="string">full</span> <span class="comment"># full, half</span></span><br><span class="line">  <span class="string">...</span></span><br></pre></td></tr></table></figure><p>目前主题提供两种首页封面高度方案，其它页面均为半屏幕高度。</p><h3 id="封面布局方案"><a href="#封面布局方案" class="headerlink" title="封面布局方案"></a>封面布局方案</h3><figure class="highlight yaml"><figcaption><span>blog/_config.volantis.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cover:</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="attr">scheme:</span> <span class="string">dock</span> <span class="comment"># search (搜索), dock (坞), featured (精选), focus (焦点)</span></span><br><span class="line">  <span class="string">...</span></span><br></pre></td></tr></table></figure><div class="table"><table><thead><tr><th align="left">布局方案</th><th align="left">适合场景</th></tr></thead><tbody><tr><td align="left">search</td><td align="left">注重搜索</td></tr><tr><td align="left">dock</td><td align="left">入口选项比较多</td></tr><tr><td align="left">featured</td><td align="left">选项在4个左右</td></tr><tr><td align="left">focus</td><td align="left">选项在4个左右</td></tr></tbody></table></div><h3 id="默认显示设置"><a href="#默认显示设置" class="headerlink" title="默认显示设置"></a>默认显示设置</h3><figure class="highlight yaml"><figcaption><span>blog/_config.volantis.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cover:</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="attr">display:</span></span><br><span class="line">    <span class="attr">home:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">archive:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">others:</span> <span class="literal">false</span> <span class="comment"># can be written in front-matter &#x27;cover: true&#x27;</span></span><br></pre></td></tr></table></figure><p>由于主页、归档是 hexo 自动生成的，您需要在主题配置文件中设置是否显示封面，而其它页面则可以在 <code>front-matter</code> 中通过设置 <code>cover: true/false</code> 来决定显示封面或者不显示封面。</p><h2 id="文章布局配置"><a href="#文章布局配置" class="headerlink" title="文章布局配置"></a>文章布局配置</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文章布局</span></span><br><span class="line"><span class="attr">article:</span></span><br><span class="line">  <span class="comment"># 文章列表页面的文章卡片布局方案</span></span><br><span class="line">  <span class="attr">preview:</span></span><br><span class="line">    <span class="attr">scheme:</span> <span class="string">landscape</span> <span class="comment"># landscape</span></span><br><span class="line">    <span class="comment"># pin icon for post</span></span><br><span class="line">    <span class="attr">pin_icon:</span> <span class="string">https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f4cc.svg</span></span><br><span class="line">    <span class="comment"># auto generate title if not exist</span></span><br><span class="line">    <span class="attr">auto_title:</span> <span class="literal">true</span> <span class="comment"># false, true</span></span><br><span class="line">    <span class="comment"># auto generate excerpt if not exist</span></span><br><span class="line">    <span class="attr">auto_excerpt:</span> <span class="literal">true</span> <span class="comment"># false, true</span></span><br><span class="line">    <span class="comment"># show split line or not</span></span><br><span class="line">    <span class="attr">line_style:</span> <span class="string">solid</span> <span class="comment"># hidden, solid, dashed, dotted</span></span><br><span class="line">    <span class="comment"># show readmore button</span></span><br><span class="line">    <span class="attr">readmore:</span> <span class="string">auto</span> <span class="comment"># auto, always</span></span><br><span class="line">  <span class="comment"># 文章详情页面的文章卡片本体布局方案</span></span><br><span class="line">  <span class="attr">body:</span></span><br><span class="line">    <span class="comment"># 文章顶部信息</span></span><br><span class="line">    <span class="comment"># 从 meta_library 中取</span></span><br><span class="line">    <span class="attr">top_meta:</span> [<span class="string">author</span>, <span class="string">category</span>, <span class="string">date</span>, <span class="string">counter</span>]</span><br><span class="line">    <span class="comment"># ----------------</span></span><br><span class="line">    <span class="comment"># 文章页脚组件</span></span><br><span class="line">    <span class="attr">footer_widget:</span></span><br><span class="line">      <span class="comment"># ----------------</span></span><br><span class="line">      <span class="comment"># 参考资料、相关资料等 (for layout: post/docs)</span></span><br><span class="line">      <span class="attr">references:</span></span><br><span class="line">        <span class="attr">title:</span> <span class="string">参考资料</span></span><br><span class="line">        <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-quote-left</span></span><br><span class="line">        <span class="comment"># 在 front-matter 中:</span></span><br><span class="line">        <span class="comment">#   references:</span></span><br><span class="line">        <span class="comment">#     - title: 某篇文章</span></span><br><span class="line">        <span class="comment">#       url: https://</span></span><br><span class="line">        <span class="comment"># 即可显示此组件。</span></span><br><span class="line">      <span class="comment"># ----------------</span></span><br><span class="line">      <span class="comment"># 相关文章，需要安装插件 (for layout: post)</span></span><br><span class="line">      <span class="comment"># npm i hexo-related-popular-posts</span></span><br><span class="line">      <span class="attr">related_posts:</span></span><br><span class="line">        <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">        <span class="attr">title:</span> <span class="string">相关文章</span></span><br><span class="line">        <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-bookmark</span></span><br><span class="line">        <span class="attr">max_count:</span> <span class="number">5</span></span><br><span class="line">        <span class="comment"># 设为空则不使用文章头图</span></span><br><span class="line">        <span class="attr">placeholder_img:</span> <span class="string">https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/046.jpg</span></span><br><span class="line">      <span class="comment"># ----------------</span></span><br><span class="line">      <span class="comment"># 版权声明组件 (for layout: post/docs)</span></span><br><span class="line">      <span class="attr">copyright:</span></span><br><span class="line">        <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">permalink:</span> <span class="string">&#x27;本文永久链接是：&#x27;</span></span><br><span class="line">        <span class="attr">content:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">&#x27;博客内容遵循 署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议&#x27;</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">permalink</span></span><br><span class="line">      <span class="comment"># ----------------</span></span><br><span class="line">      <span class="comment"># 打赏组件 (for layout: post/docs)</span></span><br><span class="line">      <span class="attr">donate:</span></span><br><span class="line">        <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">        <span class="attr">images:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/qrcode/github@volantis.png</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/qrcode/github@volantis.png</span></span><br><span class="line">    <span class="comment"># 文章底部信息</span></span><br><span class="line">    <span class="comment"># 从 meta_library 中取</span></span><br><span class="line">    <span class="attr">bottom_meta:</span> [<span class="string">updated</span>, <span class="string">tags</span>, <span class="string">share</span>]</span><br><span class="line">    <span class="comment"># meta library</span></span><br><span class="line">    <span class="attr">meta_library:</span></span><br><span class="line">      <span class="comment"># 默认文章作者（可在 front-matter 中覆盖）</span></span><br><span class="line">      <span class="attr">author:</span></span><br><span class="line">        <span class="attr">avatar:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">请设置文章作者</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">/</span></span><br><span class="line">      <span class="comment"># 文章创建日期</span></span><br><span class="line">      <span class="attr">date:</span></span><br><span class="line">        <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-calendar-alt</span></span><br><span class="line">        <span class="attr">title:</span> <span class="string">&#x27;发布于：&#x27;</span></span><br><span class="line">        <span class="attr">format:</span> <span class="string">&#x27;ll&#x27;</span> <span class="comment"># 日期格式 http://momentjs.com/docs/</span></span><br><span class="line">      <span class="comment"># 文章更新日期</span></span><br><span class="line">      <span class="attr">updated:</span></span><br><span class="line">        <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-edit</span></span><br><span class="line">        <span class="attr">title:</span> <span class="string">&#x27;更新于：&#x27;</span></span><br><span class="line">        <span class="attr">format:</span> <span class="string">&#x27;ll&#x27;</span> <span class="comment"># 日期格式 http://momentjs.com/docs/</span></span><br><span class="line">      <span class="comment"># 文章分类</span></span><br><span class="line">      <span class="attr">category:</span></span><br><span class="line">        <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-folder-open</span></span><br><span class="line">      <span class="comment"># 文章浏览计数</span></span><br><span class="line">      <span class="attr">counter:</span></span><br><span class="line">        <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-eye</span></span><br><span class="line">        <span class="attr">unit:</span> <span class="string">&#x27;次浏览&#x27;</span></span><br><span class="line">      <span class="comment"># 文章字数和阅读时长</span></span><br><span class="line">      <span class="attr">wordcount:</span></span><br><span class="line">        <span class="attr">icon_wordcount:</span> <span class="string">fas</span> <span class="string">fa-keyboard</span></span><br><span class="line">        <span class="attr">icon_duration:</span> <span class="string">fas</span> <span class="string">fa-hourglass-half</span></span><br><span class="line">      <span class="comment"># 文章标签</span></span><br><span class="line">      <span class="attr">tags:</span></span><br><span class="line">        <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-hashtag</span></span><br><span class="line">      <span class="comment"># 分享</span></span><br><span class="line">      <span class="attr">share:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">qq</span></span><br><span class="line">          <span class="attr">img:</span> <span class="string">https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/qq.png</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">qzone</span></span><br><span class="line">          <span class="attr">img:</span> <span class="string">https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/qzone.png</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">weibo</span></span><br><span class="line">          <span class="attr">img:</span> <span class="string">https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/weibo.png</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="comment"># qrcode # 当id为qrcode时需要安装插件  npm i hexo-helper-qrcode</span></span><br><span class="line">          <span class="attr">img:</span> <span class="comment"># https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/wechat.png</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="comment"># telegram</span></span><br><span class="line">          <span class="attr">img:</span> <span class="comment"># https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/telegram.png</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中 <code>top_meta</code> 和 <code>bottom_meta</code> 部分的取值自 <code>meta_library</code> 库。</p><h2 id="侧边栏配置"><a href="#侧边栏配置" class="headerlink" title="侧边栏配置"></a>侧边栏配置</h2><p>侧边栏小组件与 meta 库不同的是：除了现有的 widget ，您可以很轻易地创建自己的 widget ，然后放在需要的地方。此外，您还可以将 widget 写在单独的文件中。</p><details ><summary> 查看所有相关配置 </summary>              <div class='content'>              <figure class="highlight yaml"><figcaption><span>blog/_config.volantis.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sidebar:</span></span><br><span class="line">  <span class="comment"># 主页、分类、归档等独立页面</span></span><br><span class="line">  <span class="attr">for_page:</span> [<span class="string">blogger</span>, <span class="string">category</span>, <span class="string">tagcloud</span>, <span class="string">qrcode</span>]</span><br><span class="line">  <span class="comment"># layout: docs/post 这类文章页面</span></span><br><span class="line">  <span class="attr">for_post:</span> [<span class="string">toc</span>]</span><br><span class="line">  <span class="comment"># 侧边栏组件库</span></span><br><span class="line">  <span class="attr">widget_library:</span></span><br><span class="line">    <span class="comment"># ---------------------------------------</span></span><br><span class="line">    <span class="comment"># blogger info widget</span></span><br><span class="line">    <span class="attr">blogger:</span></span><br><span class="line">      <span class="attr">class:</span> <span class="string">blogger</span></span><br><span class="line">      <span class="attr">display:</span> [<span class="string">desktop</span>, <span class="string">mobile</span>] <span class="comment"># [desktop, mobile]</span></span><br><span class="line">      <span class="attr">avatar:</span> <span class="string">https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/Logo-NavBar@3x.png</span></span><br><span class="line">      <span class="attr">shape:</span> <span class="string">rectangle</span> <span class="comment"># circle, rectangle</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">/about/</span></span><br><span class="line">      <span class="attr">title:</span></span><br><span class="line">      <span class="attr">subtitle:</span></span><br><span class="line">      <span class="attr">jinrishici:</span> <span class="literal">true</span> <span class="comment"># Poetry Today. You can set a string, and it will be displayed when loading fails.</span></span><br><span class="line">      <span class="attr">social:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># ---------------------------------------</span></span><br><span class="line">    <span class="comment"># toc widget (valid only in articles)</span></span><br><span class="line">    <span class="attr">toc:</span></span><br><span class="line">      <span class="attr">class:</span> <span class="string">toc</span></span><br><span class="line">      <span class="attr">display:</span> [<span class="string">desktop</span>, <span class="string">mobile</span>] <span class="comment"># [desktop, mobile]</span></span><br><span class="line">      <span class="attr">header:</span></span><br><span class="line">        <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-list</span></span><br><span class="line">        <span class="attr">title:</span> <span class="string">本文目录</span></span><br><span class="line">      <span class="attr">list_number:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">min_depth:</span> <span class="number">2</span></span><br><span class="line">      <span class="attr">max_depth:</span> <span class="number">5</span></span><br><span class="line">    <span class="comment"># ---------------------------------------</span></span><br><span class="line">    <span class="comment"># category widget</span></span><br><span class="line">    <span class="attr">category:</span></span><br><span class="line">      <span class="attr">class:</span> <span class="string">category</span></span><br><span class="line">      <span class="attr">display:</span> [<span class="string">desktop</span>] <span class="comment"># [desktop, mobile]</span></span><br><span class="line">      <span class="attr">header:</span></span><br><span class="line">        <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-folder-open</span></span><br><span class="line">        <span class="attr">title:</span> <span class="string">文章分类</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">/blog/categories/</span></span><br><span class="line">    <span class="comment"># ---------------------------------------</span></span><br><span class="line">    <span class="comment"># tagcloud widget</span></span><br><span class="line">    <span class="attr">tagcloud:</span></span><br><span class="line">      <span class="attr">class:</span> <span class="string">tagcloud</span></span><br><span class="line">      <span class="attr">display:</span> [<span class="string">desktop</span>, <span class="string">mobile</span>] <span class="comment"># [desktop, mobile]</span></span><br><span class="line">      <span class="attr">header:</span></span><br><span class="line">        <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-tags</span></span><br><span class="line">        <span class="attr">title:</span> <span class="string">热门标签</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">/blog/tags/</span></span><br><span class="line">      <span class="attr">min_font:</span> <span class="number">14</span></span><br><span class="line">      <span class="attr">max_font:</span> <span class="number">24</span></span><br><span class="line">      <span class="attr">color:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">start_color:</span> <span class="string">&#x27;#999&#x27;</span></span><br><span class="line">      <span class="attr">end_color:</span> <span class="string">&#x27;#555&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ---------------------------------------</span></span><br><span class="line">    <span class="comment"># qrcode widget</span></span><br><span class="line">    <span class="attr">donate:</span></span><br><span class="line">      <span class="attr">class:</span> <span class="string">qrcode</span></span><br><span class="line">      <span class="attr">display:</span> [<span class="string">desktop</span>, <span class="string">mobile</span>] <span class="comment"># [desktop, mobile]</span></span><br><span class="line">      <span class="attr">height:</span> <span class="string">64px</span>  <span class="comment"># Automatic height if not set</span></span><br><span class="line">      <span class="attr">images:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/qrcode/github@volantis.png</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/qrcode/github@volantis.png</span></span><br><span class="line">    <span class="comment"># ---------------------------------------</span></span><br><span class="line">    <span class="comment"># webinfo widget</span></span><br><span class="line">    <span class="attr">webinfo:</span></span><br><span class="line">      <span class="attr">class:</span> <span class="string">webinfo</span></span><br><span class="line">      <span class="attr">display:</span> [<span class="string">desktop</span>]</span><br><span class="line">      <span class="attr">header:</span></span><br><span class="line">        <span class="attr">icon:</span> <span class="string">fa-solid</span> <span class="string">fa-award</span></span><br><span class="line">        <span class="attr">title:</span> <span class="string">站点信息</span></span><br><span class="line">      <span class="attr">type:</span></span><br><span class="line">        <span class="attr">article:</span></span><br><span class="line">          <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">text:</span> <span class="string">&#x27;文章数目：&#x27;</span></span><br><span class="line">          <span class="attr">unit:</span> <span class="string">&#x27;篇&#x27;</span></span><br><span class="line">        <span class="attr">runtime:</span></span><br><span class="line">          <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">data:</span> <span class="string">&#x27;2020/01/01&#x27;</span>    <span class="comment"># 填写建站日期</span></span><br><span class="line">          <span class="attr">text:</span> <span class="string">&#x27;已运行时间：&#x27;</span></span><br><span class="line">          <span class="attr">unit:</span> <span class="string">&#x27;天&#x27;</span></span><br><span class="line">        <span class="attr">wordcount:</span></span><br><span class="line">          <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">text:</span> <span class="string">&#x27;本站总字数：&#x27;</span>   <span class="comment"># 需要启用 wordcount</span></span><br><span class="line">          <span class="attr">unit:</span> <span class="string">&#x27;字&#x27;</span></span><br><span class="line">        <span class="attr">visitcounter:</span></span><br><span class="line">          <span class="attr">siteuv:</span></span><br><span class="line">            <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">            <span class="attr">text:</span> <span class="string">&#x27;本站访客数：&#x27;</span></span><br><span class="line">            <span class="attr">unit:</span> <span class="string">&#x27;人&#x27;</span></span><br><span class="line">          <span class="attr">sitepv:</span></span><br><span class="line">            <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">            <span class="attr">text:</span> <span class="string">&#x27;本站总访问量：&#x27;</span></span><br><span class="line">            <span class="attr">unit:</span> <span class="string">&#x27;次&#x27;</span></span><br><span class="line">        <span class="attr">lastupd:</span></span><br><span class="line">          <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">friendlyShow:</span> <span class="literal">true</span>    <span class="comment"># 更友好的时间显示</span></span><br><span class="line">          <span class="attr">text:</span> <span class="string">&#x27;最后活动时间：&#x27;</span></span><br><span class="line">          <span class="attr">unit:</span> <span class="string">&#x27;日&#x27;</span></span><br></pre></td></tr></table></figure>              </div>            </details><p>每一个小部件都有 <code>class</code> 和 <code>display</code>，前者代表这个小部件是什么，后者代表这个小部件在什么桌面和移动平台中是否显示，如果在移动平台显示，由于屏幕宽度有限，侧边栏的小部件则会被移动到正文区域下方，因此部分侧边栏小部件便失去意义，建议设置为仅桌面端显示。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">小部件名:</span></span><br><span class="line">  <span class="attr">class:</span> <span class="string">小部件类别</span></span><br><span class="line">  <span class="attr">display:</span> [<span class="string">小部件在桌面端是否显示</span>, <span class="string">小部件在移动设备是否显示</span>]</span><br><span class="line">  <span class="attr">pjaxReload:</span> <span class="literal">true</span> <span class="comment"># 是否 pjax 重载 默认 true; 设置为 false 时 确保所有页面都含有该小部件</span></span><br></pre></td></tr></table></figure><h3 id="博主信息部件"><a href="#博主信息部件" class="headerlink" title="博主信息部件"></a>博主信息部件</h3><figure class="highlight yaml"><figcaption><span>blog/_config.volantis.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">blogger:</span></span><br><span class="line">  <span class="attr">class:</span> <span class="string">blogger</span></span><br><span class="line">  <span class="attr">display:</span> [<span class="string">desktop</span>] <span class="comment"># [desktop, mobile]</span></span><br><span class="line">  <span class="attr">avatar:</span> <span class="string">https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png</span></span><br><span class="line">  <span class="attr">title:</span></span><br><span class="line">  <span class="attr">subtitle:</span></span><br><span class="line">  <span class="attr">jinrishici:</span> <span class="literal">true</span> <span class="comment"># Poetry Today. You can set a string, and it will be displayed when loading fails.</span></span><br><span class="line">  <span class="attr">social:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>其中，今日诗词 <code>jinrishici</code> 如果设置为一个字符串，这个字符串会变成占位文字，加载失败时显示。如果不需要，就请设置为 <code>jinrishici: false</code>。<code>social</code> 的具体内容请在网站页脚部分设置。</p><h3 id="文章目录部件"><a href="#文章目录部件" class="headerlink" title="文章目录部件"></a>文章目录部件</h3><figure class="highlight yaml"><figcaption><span>blog/_config.volantis.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">toc:</span></span><br><span class="line">  <span class="attr">class:</span> <span class="string">toc</span></span><br><span class="line">  <span class="attr">display:</span> [<span class="string">desktop</span>, <span class="string">mobile</span>] <span class="comment"># [desktop, mobile]</span></span><br><span class="line">  <span class="attr">header:</span></span><br><span class="line">    <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-list</span></span><br><span class="line">    <span class="attr">title:</span> <span class="string">本文目录</span></span><br><span class="line">  <span class="attr">list_number:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">min_depth:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">max_depth:</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><p>这个部件只能放置在侧边栏，并且在文章中有效。在移动设备中预览时，手指向上滑动时，导航栏右边会出现 TOC 按钮，点击即可展开 TOC 部件。如果您需要显示章节序号，请设置 <code>list_number</code>。 <code>min_depth</code> 和 <code>max_depth</code> 代表 TOC 支持的标题层级，最大范围是2～6。</p><h3 id="文章分类部件"><a href="#文章分类部件" class="headerlink" title="文章分类部件"></a>文章分类部件</h3><figure class="highlight yaml"><figcaption><span>blog/_config.volantis.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">category:</span></span><br><span class="line">  <span class="attr">class:</span> <span class="string">category</span></span><br><span class="line">  <span class="attr">display:</span> [<span class="string">desktop</span>] <span class="comment"># [desktop, mobile]</span></span><br><span class="line">  <span class="attr">header:</span></span><br><span class="line">    <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-folder-open</span></span><br><span class="line">    <span class="attr">title:</span> <span class="string">文章分类</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">/blog/categories/</span></span><br></pre></td></tr></table></figure><p>这个部件可以直接显示所有文章分类，如果您希望有一个独立的页面来展示，需要自己创建一个文件，具体操作在「页面」部分文档中。</p><h3 id="标签云部件"><a href="#标签云部件" class="headerlink" title="标签云部件"></a>标签云部件</h3><figure class="highlight yaml"><figcaption><span>blog/_config.volantis.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tagcloud:</span></span><br><span class="line">  <span class="attr">class:</span> <span class="string">tagcloud</span></span><br><span class="line">  <span class="attr">display:</span> [<span class="string">desktop</span>] <span class="comment"># [desktop, mobile]</span></span><br><span class="line">  <span class="attr">header:</span></span><br><span class="line">    <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-tags</span></span><br><span class="line">    <span class="attr">title:</span> <span class="string">热门标签</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">/blog/tags/</span></span><br><span class="line">  <span class="attr">min_font:</span> <span class="number">14</span></span><br><span class="line">  <span class="attr">max_font:</span> <span class="number">24</span></span><br><span class="line">  <span class="attr">color:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">start_color:</span> <span class="string">&#x27;#999&#x27;</span></span><br><span class="line">  <span class="attr">end_color:</span> <span class="string">&#x27;#555&#x27;</span></span><br></pre></td></tr></table></figure><p>这个部件可以直接显示所有文章的标签，如果您希望有一个独立的页面来展示，需要自己创建一个文件，具体操作在「页面」部分文档中。</p><h3 id="二维码部件"><a href="#二维码部件" class="headerlink" title="二维码部件"></a>二维码部件</h3><figure class="highlight yaml"><figcaption><span>blog/_config.volantis.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">donate:</span></span><br><span class="line">  <span class="attr">class:</span> <span class="string">qrcode</span></span><br><span class="line">  <span class="attr">display:</span> [<span class="string">desktop</span>, <span class="string">mobile</span>] <span class="comment"># [desktop, mobile]</span></span><br><span class="line">  <span class="attr">height:</span> <span class="string">64px</span>  <span class="comment"># Automatic height if not set</span></span><br><span class="line">  <span class="attr">images:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/qrcode/github@volantis.png</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/qrcode/github@volantis.png</span></span><br></pre></td></tr></table></figure><p>您可以放置在文章页脚用于展示打赏图片，也可以放置在侧边栏。</p><h3 id="通用文本部件"><a href="#通用文本部件" class="headerlink" title="通用文本部件"></a>通用文本部件</h3><figure class="highlight yaml"><figcaption><span>blog/_config.volantis.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">repos:</span></span><br><span class="line">  <span class="attr">class:</span> <span class="string">text</span></span><br><span class="line">  <span class="attr">display:</span> [<span class="string">desktop</span>] <span class="comment"># [desktop, mobile]</span></span><br><span class="line">  <span class="attr">header:</span></span><br><span class="line">    <span class="attr">icon:</span> <span class="string">fab</span> <span class="string">fa-github</span></span><br><span class="line">    <span class="attr">title:</span> <span class="string">点个赞吧</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">https://github.com/xaoxuu/</span></span><br><span class="line">  <span class="attr">content:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;您的赞对我来说很重要，如果您喜欢本主题，希望能够给下面的项目点个赞来支持一下。&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;[&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/proj/prohud/logo.png&quot; height=&quot;50px&quot;&gt;](https://github.com/xaoxuu/ProHUD)&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;[&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/proj/valuex/logo.png&quot; height=&quot;50px&quot;&gt;](https://github.com/xaoxuu/ValueX)&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;[&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/proj/inspire/logo.png&quot; height=&quot;50px&quot;&gt;](https://github.com/xaoxuu/Inspire)&#x27;</span></span><br></pre></td></tr></table></figure><p>您可以创建用于展示任何文本内容的文本部件。</p><h3 id="通用列表部件"><a href="#通用列表部件" class="headerlink" title="通用列表部件"></a>通用列表部件</h3><figure class="highlight yaml"><figcaption><span>blog/_config.volantis.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">wiki-hexo-theme:</span></span><br><span class="line">  <span class="attr">class:</span> <span class="string">list</span></span><br><span class="line">  <span class="attr">display:</span> [<span class="string">desktop</span>, <span class="string">mobile</span>] <span class="comment"># [desktop, mobile]</span></span><br><span class="line">  <span class="attr">header:</span></span><br><span class="line">    <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-chevron-left</span></span><br><span class="line">    <span class="attr">title:</span> <span class="string">Hexo</span> <span class="string">Themes</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">/wiki/</span></span><br><span class="line">  <span class="attr">rows:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Volantis</span> <span class="string">for</span> <span class="string">Hexo</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">/wiki/volantis/</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Resume</span> <span class="string">for</span> <span class="string">Hexo</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">/wiki/resume/</span></span><br></pre></td></tr></table></figure><p>您可以创建用于展示任何链接列表的列表部件。列表的 <code>rows</code> 中的每一项支持的属性有： <code>name</code>、<code>url</code>、<code>icon</code>、<code>img</code>、<code>avatar</code>，其中 <code>img</code> 是方形图片的链接，<code>avatar</code> 是圆形图片的链接。</p><h4 id="组索引"><a href="#组索引" class="headerlink" title="组索引"></a>组索引</h4><p>这个部件的布局继承自 list 部件，用于展示文章所属的分组的文章列表。请将您的 Volantis 升级至 <u>2.5</u> 版本以上使用。</p><figure class="highlight yaml"><figcaption><span>blog/_config.volantis.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">group-1:</span></span><br><span class="line">  <span class="attr">class:</span> <span class="string">group</span></span><br><span class="line">  <span class="attr">display:</span> [<span class="string">desktop</span>, <span class="string">mobile</span>] <span class="comment"># [desktop, mobile]</span></span><br><span class="line">  <span class="attr">header:</span></span><br><span class="line">    <span class="attr">icon:</span> <span class="string">fab</span> <span class="string">fa-github</span></span><br><span class="line">    <span class="attr">title:</span> <span class="string">Git</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">/wiki/git/</span></span><br></pre></td></tr></table></figure><p>在文章的 front-matter 中设置：</p><figure class="highlight yaml"><figcaption><span>front-matter</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">group:</span> <span class="string">group-1</span></span><br><span class="line"><span class="attr">order:</span> <span class="number">16</span></span><br><span class="line"><span class="attr">sidebar:</span> [<span class="string">group-1</span>, <span class="string">toc</span>]</span><br></pre></td></tr></table></figure><p>「group-1」卡片将会以列表的形式显示所有设置了 <code>group: group-1</code> 的文章，顺序按照 <code>order</code> 从小到大排列。</p><h3 id="通用网格部件"><a href="#通用网格部件" class="headerlink" title="通用网格部件"></a>通用网格部件</h3><figure class="highlight yaml"><figcaption><span>blog/_config.volantis.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feedback:</span></span><br><span class="line">  <span class="attr">class:</span> <span class="string">grid</span></span><br><span class="line">  <span class="attr">display:</span> [<span class="string">desktop</span>, <span class="string">mobile</span>]</span><br><span class="line">  <span class="attr">header:</span></span><br><span class="line">    <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-headset</span></span><br><span class="line">    <span class="attr">title:</span> <span class="string">联系开发者</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">https://github.com/volantis-x/hexo-theme-volantis</span></span><br><span class="line">  <span class="attr">fixed:</span> <span class="literal">true</span> <span class="comment"># 固定宽度</span></span><br><span class="line">  <span class="attr">rows:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">反馈BUG</span></span><br><span class="line">      <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-bug</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">https://github.com/volantis-x/hexo-theme-volantis/issues/</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">疑问求助</span></span><br><span class="line">      <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-question-circle</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">https://github.com/volantis-x/hexo-theme-volantis/issues/</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">提个建议</span></span><br><span class="line">      <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-lightbulb</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">https://github.com/volantis-x/hexo-theme-volantis/issues/</span></span><br></pre></td></tr></table></figure><p>您可以创建用于展示任何链接列表的网格部件。网格默认根据文字长度自动确定每一个格子的宽度，如果文字长短不一，建议通过设置 <code>fixed: true</code> 来固定宽度，此时文字过长的格子中的文字会换行显示。</p><h3 id="通用页面部件"><a href="#通用页面部件" class="headerlink" title="通用页面部件"></a>通用页面部件</h3><figure class="highlight yaml"><figcaption><span>blog/_config.volantis.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">test:</span></span><br><span class="line">  <span class="attr">class:</span> <span class="string">page</span></span><br><span class="line">  <span class="attr">display:</span> [<span class="string">desktop</span>, <span class="string">mobile</span>]</span><br><span class="line">  <span class="attr">pid:</span> <span class="string">haha</span></span><br><span class="line">  <span class="attr">content:</span> <span class="string">excerpt</span> <span class="comment"># excerpt, more, content</span></span><br></pre></td></tr></table></figure><p>您可以把整个页面的md内容作为一个小部件渲染显示出来。只需要设置小部件里的 <code>pid</code> 属性和文章的 <code>front-matter</code> 中设置一样的 <code>pid</code> 即可。 <code>content</code> 代表这个部件显示的内容，可选 <code>excerpt</code>，<code>more</code>，<code>content</code> 分别对应文章的摘要、摘要后面的内容、全文。</p><h3 id="音乐部件"><a href="#音乐部件" class="headerlink" title="音乐部件"></a>音乐部件</h3><figure class="highlight yaml"><figcaption><span>blog/_config.volantis.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">music:</span></span><br><span class="line">  <span class="attr">class:</span> <span class="string">music</span></span><br><span class="line">  <span class="attr">display:</span> [<span class="string">desktop</span>, <span class="string">mobile</span>] <span class="comment"># [desktop, mobile]</span></span><br><span class="line">  <span class="attr">pjaxReload:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><h2 id="选择评论系统"><a href="#选择评论系统" class="headerlink" title="选择评论系统"></a>选择评论系统</h2><p>目前共支持 14 款评论系统：</p><p>artalk, giscus, beaudar, utterances, twikoo, waline, discuss, disqus, disqusjs, gitalk, vssue, livere, isso, hashover</p><figure class="highlight yaml"><figcaption><span>blog/_config.volantis.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">comments:</span></span><br><span class="line">  <span class="attr">title:</span> <span class="string">&lt;i</span> <span class="string">class=&#x27;fas</span> <span class="string">fa-comments&#x27;&gt;&lt;/i&gt;</span> <span class="string">评论</span></span><br><span class="line">  <span class="attr">subtitle:</span></span><br><span class="line">  <span class="attr">service:</span> <span class="string">giscus</span></span><br></pre></td></tr></table></figure><hr><details cyan><summary> GitHub Discussions 系列 </summary>              <div class='content'>              <div class="tabs" id="tab-comments-github-discussions-"><ul class="nav-tabs"><li class="tab active"><a class="#comments-github-discussions--1">giscus</a></li></ul><div class="tab-content"><div class="tab-pane active" id="comments-github-discussions--1"><p><i class='fas fa-comment-dots fa-fw'></i> A comments system powered by GitHub Discussions.<br><i class='fas fa-globe fa-fw'></i> <a href="https://giscus.app/">https://giscus.app/</a></p><figure class="highlight yaml"><figcaption><span>blog/_config.volantis.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">comments:</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="attr">service:</span> <span class="string">giscus</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="comment"># giscus</span></span><br><span class="line">  <span class="comment"># https://giscus.app</span></span><br><span class="line">  <span class="comment"># https://github.com/laymonage/giscus</span></span><br><span class="line">  <span class="attr">giscus:</span></span><br><span class="line">    <span class="comment"># 以下配置按照 yml 格式增删填写即可</span></span><br><span class="line">    <span class="comment"># repo: xxx/xxx</span></span><br><span class="line">    <span class="comment"># repo-id: xxx</span></span><br><span class="line">    <span class="comment"># category: xxx</span></span><br><span class="line">    <span class="comment"># category-id: xxx</span></span><br><span class="line">    <span class="comment"># mapping: &quot;pathname&quot;</span></span><br><span class="line">    <span class="comment"># reactions-enabled: &quot;1&quot;</span></span><br><span class="line">    <span class="comment"># emit-metadata: &quot;0&quot;</span></span><br><span class="line">    <span class="comment"># lang: &quot;zh-CN&quot;</span></span><br><span class="line">    <span class="comment"># 以上配置按照 yml 格式增删填写即可</span></span><br><span class="line">    <span class="attr">theme:</span></span><br><span class="line">      <span class="attr">light:</span> <span class="string">&quot;light&quot;</span> <span class="comment"># https://cdn.jsdelivr.net/gh/volantis-x/cdn-volantis@master/css/giscus/light.css</span></span><br><span class="line">      <span class="attr">dark:</span> <span class="string">&quot;dark&quot;</span> <span class="comment"># https://cdn.jsdelivr.net/gh/volantis-x/cdn-volantis@master/css/giscus/dark.css</span></span><br></pre></td></tr></table></figure></div></div></div>              </div>            </details><details green><summary> GitHub Issues 系列 </summary>              <div class='content'>              <div class="tabs" id="tab-comments-github-issues-"><ul class="nav-tabs"><li class="tab active"><a class="#comments-github-issues--1">beaudar</a></li><li class="tab"><a class="#comments-github-issues--2">utterances</a></li><li class="tab"><a class="#comments-github-issues--3">Vssue</a></li><li class="tab"><a class="#comments-github-issues--4">Gitalk</a></li></ul><div class="tab-content"><div class="tab-pane active" id="comments-github-issues--1"><p><i class='fas fa-comment-dots fa-fw'></i> Beaudar 名称源于粤语“表达”的发音，是 Utterances 的中文版本。<br><i class='fas fa-globe fa-fw'></i> <a href="https://beaudar.lipk.org/">https://beaudar.lipk.org/</a></p><figure class="highlight yaml"><figcaption><span>blog/_config.volantis.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">comments:</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="attr">service:</span> <span class="string">beaudar</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="comment"># beaudar</span></span><br><span class="line">  <span class="comment"># https://beaudar.lipk.org/</span></span><br><span class="line">  <span class="attr">beaudar:</span></span><br><span class="line">    <span class="attr">repo:</span> <span class="string">xxx/xxx</span></span><br><span class="line">    <span class="attr">issue-term:</span> <span class="string">pathname</span></span><br><span class="line">    <span class="attr">issue-number:</span></span><br><span class="line">    <span class="attr">branch:</span> <span class="string">main</span></span><br><span class="line">    <span class="attr">position:</span> <span class="string">top</span></span><br><span class="line">    <span class="attr">order:</span> <span class="string">desc</span></span><br><span class="line">    <span class="attr">theme:</span></span><br><span class="line">      <span class="attr">light:</span> <span class="string">github-light</span></span><br><span class="line">      <span class="attr">dark:</span> <span class="string">github-dark</span></span><br><span class="line">    <span class="attr">label:</span> <span class="string">✨💬✨</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="comments-github-issues--2"><p><i class='fas fa-comment-dots fa-fw'></i> A lightweight comments widget built on GitHub issues.<br><i class='fas fa-globe fa-fw'></i> <a href="https://utteranc.es/">https://utteranc.es/</a></p><figure class="highlight yaml"><figcaption><span>blog/_config.volantis.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">comments:</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="attr">service:</span> <span class="string">utterances</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="comment"># utterances</span></span><br><span class="line">  <span class="comment"># https://utteranc.es/</span></span><br><span class="line">  <span class="attr">utterances:</span></span><br><span class="line">    <span class="attr">repo:</span> <span class="string">xxx/xxx</span></span><br><span class="line">    <span class="attr">issue-term:</span> <span class="string">pathname</span></span><br><span class="line">    <span class="attr">issue-number:</span></span><br><span class="line">    <span class="attr">theme:</span></span><br><span class="line">      <span class="attr">light:</span> <span class="string">github-light</span></span><br><span class="line">      <span class="attr">dark:</span> <span class="string">github-dark</span></span><br><span class="line">    <span class="attr">label:</span> <span class="string">✨💬✨</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="comments-github-issues--3"><p><i class='fas fa-comment-dots fa-fw'></i> Vue 驱动的、基于 Issue 的评论插件<br><i class='fas fa-globe fa-fw'></i> <a href="https://vssue.js.org/zh/">https://vssue.js.org/zh/</a></p><figure class="highlight yaml"><figcaption><span>blog/_config.volantis.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">comments:</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="attr">service:</span> <span class="string">vssue</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="attr">vssue:</span></span><br><span class="line">    <span class="attr">owner:</span></span><br><span class="line">    <span class="attr">repo:</span></span><br><span class="line">    <span class="attr">clientId:</span></span><br><span class="line">    <span class="attr">clientSecret:</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="comments-github-issues--4"><p><i class='fas fa-comment-dots fa-fw'></i> A modern comment component based on Github Issue and Preact.<br><i class='fas fa-globe fa-fw'></i> <a href="https://gitalk.github.io/">https://gitalk.github.io/</a></p><figure class="highlight yaml"><figcaption><span>blog/_config.volantis.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">comments:</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="attr">service:</span> <span class="string">gitalk</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="attr">gitalk:</span></span><br><span class="line">    <span class="attr">clientID:</span></span><br><span class="line">    <span class="attr">clientSecret:</span></span><br><span class="line">    <span class="attr">repo:</span></span><br><span class="line">    <span class="attr">owner:</span></span><br><span class="line">    <span class="attr">admin:</span> <span class="comment"># []</span></span><br></pre></td></tr></table></figure><p>clientID 和 clientSecret 的获取方法可自行搜索教程，这里仅简单描述一下步骤：</p><ol><li>点击 GitHub -&gt; Settings <code>https://github.com/settings/profile</code></li><li>点击 Developer settings <code>https://github.com/settings/developers</code></li><li>点击 New OAuth App <code>https://github.com/settings/applications/new</code></li><li>填写信息：<br><strong>Application name</strong> 随便填，我的是：<code>xaoxuu.com</code><br><strong>Homepage URL</strong> 和 <strong>Authorization callback URL</strong> 都写你的网址，我的是：<code>https://xaoxuu.com</code></li></ol><p><strong>可以通过设置 gitalk.id 实现多个页面共用一个评论框。</strong></p><figure class="highlight yaml"><figcaption><span>front-matter</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">gitalk:</span></span><br><span class="line">  <span class="attr">id:</span> <span class="string">/wiki/volantis/</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure></div></div></div>              </div>            </details><details yellow><summary> Disqus 系列 </summary>              <div class='content'>              <div class="tabs" id="tab-comments-disqus-"><ul class="nav-tabs"><li class="tab active"><a class="#comments-disqus--1">Disqus</a></li><li class="tab"><a class="#comments-disqus--2">DisqusJS</a></li><li class="tab"><a class="#comments-disqus--3">Isso</a></li></ul><div class="tab-content"><div class="tab-pane active" id="comments-disqus--1"><p><i class='fas fa-comment-dots fa-fw'></i> Disqus - The #1 way to build an audience on your website.<br><i class='fas fa-globe fa-fw'></i> <a href="https://disqus.com/">https://disqus.com/</a></p><figure class="highlight yaml"><figcaption><span>blog/_config.volantis.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">comments:</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="attr">service:</span> <span class="string">disqus</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="attr">disqus:</span></span><br><span class="line">    <span class="attr">shortname:</span></span><br></pre></td></tr></table></figure><p><strong>可以通过设置 disqus.path 实现多个页面共用一个评论框。</strong></p><figure class="highlight yaml"><figcaption><span>front-matter</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">disqus:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">/wiki/volantis/</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="comments-disqus--2"><p><i class='fas fa-comment-dots fa-fw'></i> Render Disqus comments in Mainland China using Disqus API<br><i class='fas fa-globe fa-fw'></i> <a href="https://github.com/SukkaW/DisqusJS">https://github.com/SukkaW/DisqusJS</a></p><figure class="highlight yaml"><figcaption><span>blog/_config.volantis.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">comments:</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="attr">service:</span> <span class="string">disqusjs</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="comment"># DisqusJS</span></span><br><span class="line">  <span class="comment"># https://github.com/SukkaW/DisqusJS</span></span><br><span class="line">  <span class="attr">disqusjs:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="comment"># 全局评论地址</span></span><br><span class="line">    <span class="comment"># 配置项按照yml格式继续填写即可 除了 [siteName url identifier] 选项</span></span><br><span class="line">    <span class="comment">#shortname:</span></span><br><span class="line">    <span class="comment">#api:</span></span><br><span class="line">    <span class="comment">#apikey:</span></span><br><span class="line">    <span class="comment">#admin:</span></span><br><span class="line">    <span class="comment">#nesting:</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="comments-disqus--3"><p><i class='fas fa-comment-dots fa-fw'></i> A commenting server similar to Disqus.<br><i class='fas fa-globe fa-fw'></i> <a href="https://posativ.org/isso/">https://posativ.org/isso/</a></p><figure class="highlight yaml"><figcaption><span>blog/_config.volantis.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">comments:</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="attr">service:</span> <span class="string">isso</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="attr">isso:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">https://example.com/(path/)</span></span><br><span class="line">    <span class="attr">src:</span> <span class="string">https://example.com/(path/)js/embed.min.js</span></span><br></pre></td></tr></table></figure></div></div></div>              </div>            </details><details blue><summary> Valine 衍生系列 </summary>              <div class='content'>              <div class="note error"><p>Valine 在 5.0 版本被移除,具体原因可参考<a href="https://github.com/next-theme/hexo-theme-next/issues/188#issuecomment-766578906">hexo-theme-next#188#issuecomment-766578906</a></p></div><p>以下是在解决 valine 遗留问题同一时期产生的评论系统故归为一类, 然在其社区issue中也报告了类似的攻击事件(eg: <a href="https://github.com/imaegoo/twikoo/issues/157">twikoo#157</a> <a href="https://github.com/walinejs/waline/issues/424">waline#424</a> <a href="https://github.com/walinejs/waline/issues/430">waline#430</a>),故请谨慎选择.</p><div class="tabs" id="tab-comments-valine-"><ul class="nav-tabs"><li class="tab active"><a class="#comments-valine--1">discuss</a></li><li class="tab"><a class="#comments-valine--2">twikoo</a></li><li class="tab"><a class="#comments-valine--3">Waline</a></li></ul><div class="tab-content"><div class="tab-pane active" id="comments-valine--1"><p><i class='fas fa-comment-dots fa-fw'></i> 一款简单，安全，免费的评论系统 | A simple, safe, free comment system<br><i class='fas fa-globe fa-fw'></i> <a href="https://discuss.js.org/">https://discuss.js.org</a></p><figure class="highlight yaml"><figcaption><span>blog/_config.volantis.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">comments:</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="attr">service:</span> <span class="string">discuss</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="comment"># Discuss</span></span><br><span class="line">  <span class="comment"># https://discuss.js.org</span></span><br><span class="line">  <span class="attr">discuss:</span></span><br><span class="line">    <span class="attr">js:</span> <span class="string">https://cdn.jsdelivr.net/npm/discuss/dist/Discuss.js</span> <span class="comment"># 建议锁定版本</span></span><br><span class="line">    <span class="attr">serverURLs:</span> <span class="comment"># Discuss server address url</span></span><br><span class="line">    <span class="comment"># https://discuss.js.org/Quick-Start.html#path</span></span><br></pre></td></tr></table></figure><p>其中，<code>placeholder</code> 支持在 front-matter 中设置。</p><figure class="highlight yaml"><figcaption><span>front-matter</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">discuss:</span></span><br><span class="line">  <span class="attr">placeholder:</span> <span class="string">你觉得xxx怎么样呢？</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><p>也可以通过设置 <code>discuss.path</code> 实现多个页面共用一个评论框。</p><figure class="highlight yaml"><figcaption><span>front-matter</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">discuss:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="comments-valine--2"><p><i class='fas fa-comment-dots fa-fw'></i> 一个简洁、安全、免费的静态网站评论系统 | A simple, safe, free comment system.<br><i class='fas fa-globe fa-fw'></i> <a href="https://twikoo.js.org/">https://twikoo.js.org/</a></p><figure class="highlight yaml"><figcaption><span>blog/_config.volantis.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">comments:</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="attr">service:</span> <span class="string">twikoo</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="attr">twikoo:</span></span><br><span class="line">    <span class="attr">js:</span> <span class="string">https://cdn.jsdelivr.net/npm/twikoo@latest</span> <span class="comment"># 建议锁定版本</span></span><br><span class="line">    <span class="attr">path:</span> <span class="comment"># 全局评论地址</span></span><br><span class="line">    <span class="comment"># 其他配置项按照yml格式继续填写即可 除了 [el path] 选项</span></span><br><span class="line">    <span class="attr">envId:</span> <span class="string">xxxxxxxxxxxxxxx</span> <span class="comment"># 腾讯云环境id</span></span><br></pre></td></tr></table></figure><p>其中，<code>placeholder</code> 支持在 front-matter 中设置。</p><figure class="highlight yaml"><figcaption><span>front-matter</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">twikoo:</span></span><br><span class="line">  <span class="attr">placeholder:</span> <span class="string">你觉得xxx怎么样呢？</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><p>也可以通过设置 <code>twikoo.path</code> 实现多个页面共用一个评论框。</p><figure class="highlight yaml"><figcaption><span>front-matter</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">twikoo:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="comments-valine--3"><p><i class='fas fa-comment-dots fa-fw'></i> 一个简洁、安全、免费的静态网站评论系统 | A simple, safe, free comment system.<br><i class='fas fa-globe fa-fw'></i> <a href="https://waline.js.org/">https://waline.js.org/</a></p><figure class="highlight yaml"><figcaption><span>blog/_config.volantis.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">comments:</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="attr">service:</span> <span class="string">waline</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="comment"># Waline</span></span><br><span class="line">  <span class="comment"># https://waline.js.org/</span></span><br><span class="line">  <span class="attr">waline:</span></span><br><span class="line">    <span class="attr">js:</span> <span class="string">https://cdn.jsdelivr.net/npm/@waline/client/dist/Waline.min.js</span></span><br><span class="line">    <span class="attr">path:</span> <span class="comment"># 全局评论地址 目前设置全局评论地址后visitor失效,这是waline的问题</span></span><br><span class="line">    <span class="attr">placeholder:</span> <span class="string">快来评论吧~</span>  <span class="comment"># 评论占位提示</span></span><br><span class="line">    <span class="attr">imageHosting:</span> <span class="string">https://7bu.top/api/upload</span> <span class="comment"># 图床api（默认使用去不图床）</span></span><br><span class="line">    <span class="comment"># 其他配置项按照yml格式继续填写即可 除了 [el path placeholder uploadImage] 选项</span></span><br><span class="line">    <span class="attr">serverURL:</span> <span class="string">xxxxxxxxxxxxxxx</span> <span class="comment"># Waline 的服务端地址（必填） 测试用地址: https://waline-ruddy.vercel.app</span></span><br><span class="line">    <span class="string">...</span> <span class="string">可选配置项详见源码</span></span><br></pre></td></tr></table></figure><p>其中，<code>placeholder</code> 支持在 front-matter 中设置。</p><figure class="highlight yaml"><figcaption><span>front-matter</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">waline:</span></span><br><span class="line">  <span class="attr">placeholder:</span> <span class="string">你觉得xxx怎么样呢？</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><p>也可以通过设置 <code>waline.path</code> 实现多个页面共用一个评论框。</p><figure class="highlight yaml"><figcaption><span>front-matter</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">waline:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure></div></div></div>              </div>            </details><details red><summary> Others 其他系列 </summary>              <div class='content'>              <div class="tabs" id="tab-comments-others-"><ul class="nav-tabs"><li class="tab active"><a class="#comments-others--1">Artalk</a></li><li class="tab"><a class="#comments-others--2">Livere</a></li><li class="tab"><a class="#comments-others--3">Hashover</a></li><li class="tab"><a class="#comments-others--4">More...</a></li></ul><div class="tab-content"><div class="tab-pane active" id="comments-others--1"><p><i class='fas fa-comment-dots fa-fw'></i> 一款简洁的自托管评论系统 | A Selfhosted Comment System.<br><i class='fas fa-globe fa-fw'></i> <a href="https://artalk.js.org/">https://artalk.js.org/</a></p><figure class="highlight yaml"><figcaption><span>blog/_config.volantis.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">comments:</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="attr">service:</span> <span class="string">artalk</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="attr">artalk:</span></span><br><span class="line">    <span class="attr">js:</span> <span class="string">https://cdn.jsdelivr.net/npm/artalk@2.1.3/dist/Artalk.js</span></span><br><span class="line">    <span class="attr">css:</span> <span class="string">https://cdn.jsdelivr.net/npm/artalk@2.1.3/dist/Artalk.css</span></span><br><span class="line">    <span class="attr">server:</span> <span class="string">http://127.0.0.1:8080/api</span>    <span class="comment"># 修改为自建的后端服务地址</span></span><br></pre></td></tr></table></figure><p>其中，<code>placeholder</code> 支持在 front-matter 中设置。</p><figure class="highlight yaml"><figcaption><span>front-matter</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">artalk:</span></span><br><span class="line">  <span class="attr">placeholder:</span> <span class="string">你觉得xxx怎么样呢？</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><p>也可以通过设置 <code>artalk.path</code> 实现多个页面共用一个评论框。</p><figure class="highlight yaml"><figcaption><span>front-matter</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">artalk:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="comments-others--2"><p><i class='fas fa-comment-dots fa-fw'></i> Communication makes better world.<br><i class='fas fa-globe fa-fw'></i> <a href="https://www.livere.com/">https://www.livere.com/</a></p><figure class="highlight yaml"><figcaption><span>blog/_config.volantis.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">comments:</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="attr">service:</span> <span class="string">livere</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="attr">livere:</span></span><br><span class="line">    <span class="attr">uid:</span> <span class="comment">#你的livere的uid</span></span><br></pre></td></tr></table></figure><p>在这里查看你的 uid：<code>https://livere.com/insight/myCode</code>，在【代码管理 -&gt; 一般网站】中找到如下这段代码，其中 <code>data-uid</code> 中的内容就是你的 <code>livere_uid</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 来必力City版安装代码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;lv-container&quot;</span> <span class="attr">data-id</span>=<span class="string">&quot;city&quot;</span> <span class="attr">data-uid</span>=<span class="string">&quot;你的livere的uid&quot;</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="comments-others--3"><p><i class='fas fa-comment-dots fa-fw'></i> A free and open source PHP comment system designed to allow completely anonymous comments and easy theming.<br><i class='fas fa-globe fa-fw'></i> <a href="https://www.barkdull.org/software/hashover">https://www.barkdull.org/software/hashover</a></p><figure class="highlight yaml"><figcaption><span>blog/_config.volantis.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">comments:</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="attr">service:</span> <span class="string">hashover</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="attr">hashover:</span></span><br><span class="line">    <span class="attr">src:</span> <span class="string">https://example.com/(path/)comments.php</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="comments-others--4"><figure class="highlight plaintext"><figcaption><span>blog/themes/volantis/layout/_third-party/comments/评论系统名称/layout.ejs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里写布局代码</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><figcaption><span>blog/themes/volantis/layout/_third-party/comments/评论系统名称/script.ejs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里要写加载 js 的代码</span><br></pre></td></tr></table></figure><p><span class='btn large center'><a class="button" href='https://github.com/volantis-x/' title='收录更多评论系统'><i class='fas fa-plus'></i>收录更多评论系统</a></span></p></div></div></div>              </div>            </details><hr><p><strong>可以通过在 front-matter 设置 config 实现在特定页面修改评论系统的相关配置。</strong></p><p><strong>支持的有(按字母顺序): discuss, giscus, gitalk, twikoo, waline</strong></p><figure class="highlight yaml"><figcaption><span>front-matter</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">gitalk:</span></span><br><span class="line">  <span class="attr">config:</span></span><br><span class="line">    <span class="attr">id:</span> <span class="string">/233/</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><h2 id="站内搜索"><a href="#站内搜索" class="headerlink" title="站内搜索"></a>站内搜索</h2><figure class="highlight yaml"><figcaption><span>blog/_config.volantis.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">service:</span> <span class="string">hexo</span>  <span class="comment"># hexo</span></span><br><span class="line">  <span class="attr">js:</span> <span class="string">https://cdn.jsdelivr.net/xxxxxxxx/js/search/hexo.js</span></span><br></pre></td></tr></table></figure><p>默认配置为 Hexo 搜索，但是需要安装插件才能使用：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -S hexo-generator-json-content</span><br></pre></td></tr></table></figure><div class="note error"><p>原 google, algolia, azure, baidu 站内搜索 系祖传代码, 且文档丢失, 不便后续维护 在 5.0 版本移除</p></div><h2 id="插件库"><a href="#插件库" class="headerlink" title="插件库"></a>插件库</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Volantis 为丰富的插件提供了兼容性优化。大部分插件您只需开启和关闭，无需进行设置。</p><h3 id="幻灯片背景-视差滚动效果"><a href="#幻灯片背景-视差滚动效果" class="headerlink" title="幻灯片背景(视差滚动效果)"></a>幻灯片背景(视差滚动效果)</h3><div class="note error"><p>jquery.backstretch 在 5.0 版本 移除, 被 parallax 替代</p></div><figure class="highlight yaml"><figcaption><span>blog/_config.volantis.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">plugins:</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="attr">parallax:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">position:</span> <span class="string">cover</span>       <span class="comment"># cover: sticky on the cover.   fixed: Fixed as background for the site.</span></span><br><span class="line">    <span class="attr">shuffle:</span> <span class="literal">true</span>         <span class="comment"># shuffle playlist</span></span><br><span class="line">    <span class="attr">duration:</span> <span class="number">10000</span>       <span class="comment"># Duration (ms)</span></span><br><span class="line">    <span class="attr">fade:</span> <span class="number">1500</span>            <span class="comment"># fade duration (ms) (Not more than 1500)</span></span><br><span class="line">    <span class="attr">images:</span>               <span class="comment"># For personal use only. At your own risk if used for commercial purposes !!!</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper/abstract/41F215B9-261F-48B4-80B5-4E86E165259E.jpeg</span></span><br><span class="line">      <span class="string">...</span></span><br></pre></td></tr></table></figure><p>幻灯片背景图片显示的位置可以选择粘贴在封面上，跟随封面一起滑动，也可以选择固定作为网页背景图片。</p><h3 id="highlight-js"><a href="#highlight-js" class="headerlink" title="highlight.js"></a>highlight.js</h3><figure class="highlight yaml"><figcaption><span>blog/_config.volantis.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">plugins:</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="comment"># 代码高亮</span></span><br><span class="line">  <span class="attr">code_highlight:</span> <span class="string">highlightjs</span> <span class="comment"># highlightjs or prismjs</span></span><br><span class="line">  <span class="comment"># highlight.js</span></span><br><span class="line">  <span class="attr">highlightjs:</span></span><br><span class="line">    <span class="attr">copy_code:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 如果开启 js, hexo.config.highlight.enable 需要设置为 false</span></span><br><span class="line">    <span class="attr">js:</span> <span class="comment">#https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.1.0/build/highlight.min.js # Please set hexo.config.highlight.enable = false !!!</span></span><br><span class="line">    <span class="attr">css:</span> <span class="string">https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.1.0/build/styles/default.min.css</span></span><br><span class="line">    <span class="comment"># more: https://www.jsdelivr.com/package/npm/highlight.js?path=styles</span></span><br></pre></td></tr></table></figure><p>如果需要使用 highlight.js 进行语法高亮，请将站点配置文件中的 <code>highlight.enable</code> 设置为 <code>false</code> 否则不会加载插件。您可以在 <u>94</u> 种 <a href="https://www.jsdelivr.com/package/npm/highlight.js?path=styles">语法高亮主题</a> 中挑选喜爱的主题，然后替换上面的 css 链接。</p><div class="note warning"><p>如果您使用 highlight.js 请确保没有使用 hexo 官方的 codeblock 标签，否则会报错。</p></div><div class="note bug red"><p>经测试，使用 highlight.js 的情况下，部分容器内的代码可能仍然会被渲染甚至报错。</p></div><h3 id="APlayer-音乐播放器"><a href="#APlayer-音乐播放器" class="headerlink" title="APlayer 音乐播放器"></a>APlayer 音乐播放器</h3><figure class="highlight yaml"><figcaption><span>blog/_config.volantis.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">plugins:</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="comment"># APlayer is only available in mainland China.</span></span><br><span class="line">  <span class="comment"># APlayer config: https://github.com/metowolf/MetingJS</span></span><br><span class="line">  <span class="attr">aplayer:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">js:</span></span><br><span class="line">      <span class="attr">aplayer:</span> <span class="string">https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.js</span></span><br><span class="line">      <span class="attr">meting:</span> <span class="string">https://cdn.jsdelivr.net/npm/meting@2.0/dist/Meting.min.js</span></span><br><span class="line">    <span class="comment"># Required</span></span><br><span class="line">    <span class="attr">server:</span> <span class="string">netease</span>   <span class="comment"># netease, tencent, kugou, xiami, baidu</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">playlist</span>    <span class="comment"># song, playlist, album, search, artist</span></span><br><span class="line">    <span class="attr">id:</span> <span class="number">3175833810</span>    <span class="comment"># song id / playlist id / album id / search keyword</span></span><br><span class="line">    <span class="comment"># Optional</span></span><br><span class="line">    <span class="attr">fixed:</span> <span class="literal">false</span>      <span class="comment"># enable fixed mode</span></span><br><span class="line">    <span class="attr">theme:</span> <span class="string">&#x27;#1BCDFC&#x27;</span>  <span class="comment"># main color</span></span><br><span class="line">    <span class="attr">autoplay:</span> <span class="literal">false</span>   <span class="comment"># audio autoplay</span></span><br><span class="line">    <span class="attr">order:</span> <span class="string">list</span>       <span class="comment"># player play order, values: &#x27;list&#x27;, &#x27;random&#x27;</span></span><br><span class="line">    <span class="attr">loop:</span> <span class="string">all</span>         <span class="comment"># player loop play, values: &#x27;all&#x27;, &#x27;one&#x27;, &#x27;none&#x27;</span></span><br><span class="line">    <span class="attr">volume:</span> <span class="number">0.7</span>       <span class="comment"># default volume, notice that player will remember user setting, default volume will not work after user set volume themselves</span></span><br><span class="line">    <span class="attr">list_max_height:</span> <span class="string">320px</span> <span class="comment"># list max height</span></span><br><span class="line">    <span class="attr">list_folded:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><div class="note warning"><p>APlayer播放器只可以在中国大陆地区使用。相关文档： <a href="https://aplayer.js.org/">APlayer</a> | <a href="https://github.com/metowolf/MetingJS">MetingJS</a></p></div><h3 id="暗黑模式"><a href="#暗黑模式" class="headerlink" title="暗黑模式"></a>暗黑模式</h3><figure class="highlight yaml"><figcaption><span>blog/_config.volantis.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">plugins:</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="comment"># 暗黑模式 darkmode</span></span><br><span class="line">  <span class="comment"># 开关按钮：在 navbar.menu 中添加：</span></span><br><span class="line">  <span class="comment"># - name: 暗黑模式 # 可自定义</span></span><br><span class="line">  <span class="comment">#   icon: fas fa-moon # 可自定义</span></span><br><span class="line">  <span class="comment">#   toggle: darkmode</span></span><br><span class="line">  <span class="attr">darkmode:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="结束支持"><a href="#结束支持" class="headerlink" title="结束支持"></a>结束支持</h3><figure class="highlight yaml"><figcaption><span>blog/_config.volantis.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">plugins:</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="comment"># 旧版 Internet Explorer 淘汰行动</span></span><br><span class="line">  <span class="comment"># https://www.microsoft.com/zh-cn/WindowsForBusiness/End-of-IE-support</span></span><br><span class="line">  <span class="comment"># 本主题不支持Internet Explorer的任何版本!!!</span></span><br><span class="line">  <span class="attr">killOldVersionsOfIE:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 禁用JavaScript提示</span></span><br><span class="line">  <span class="comment"># 本页面需要浏览器支持（启用）JavaScript</span></span><br><span class="line">  <span class="comment"># 主题中的某些插件必须启用JavaScript才能正常工作，例如开启scrollreveal如果禁用JavaScript会导致卡片消失</span></span><br><span class="line">  <span class="attr">killNoScript:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="Artitalk"><a href="#Artitalk" class="headerlink" title="Artitalk"></a>Artitalk</h3><figure class="highlight yaml"><figcaption><span>blog/_config.volantis.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">plugins:</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="comment"># Artitalk https://artitalk.js.org</span></span><br><span class="line">  <span class="comment"># 配置过程请参考：https://artitalk.js.org/doc.html</span></span><br><span class="line">  <span class="comment"># 使用过旧版本的请修改Leancloud shuoshuo class部分列名：https://artitalk.js.org/release.html</span></span><br><span class="line">  <span class="comment"># 除appID和appKEY外均为选填项</span></span><br><span class="line">  <span class="attr">artitalk:</span></span><br><span class="line">    <span class="comment"># Set `plugins: [&quot;artitalk&quot;]` to enable in front-matter</span></span><br><span class="line">    <span class="comment"># 不支持 Pjax</span></span><br><span class="line">    <span class="comment"># 配置项按照yml格式继续填写即可</span></span><br><span class="line">    <span class="attr">appId:</span> <span class="string">ogP8qj3veMh0LFpFWMPOyF0X-MdYXbMMI</span> <span class="comment"># your appID</span></span><br><span class="line">    <span class="attr">appKey:</span> <span class="string">nHXLd3N3Jgh460t2iRQKWAtr</span> <span class="comment"># your appKEY</span></span><br><span class="line">    <span class="comment"># serverURL:  #leancloud绑定的api访问域名，使用国际版的话不需要填写</span></span><br><span class="line">    <span class="comment"># lang: # 语言设置，zh为汉语，en为英语，es为西班牙语。默认为汉语</span></span><br><span class="line">    <span class="comment"># pageSize: #每页说说的显示数量</span></span><br><span class="line">    <span class="comment"># shuoPla: #在编辑说说的输入框中的占位符</span></span><br><span class="line">    <span class="comment"># avatarPla: #自定义头像url的输入框的占位符</span></span><br><span class="line">    <span class="comment"># motion: #加载动画的开关，1为开，0为关，默认为开</span></span><br><span class="line">    <span class="comment"># bgImg: #说说输入框背景图片url</span></span><br><span class="line">    <span class="comment"># color1: #说说背景颜色1&amp;按钮颜色1</span></span><br><span class="line">    <span class="comment"># color2: #说说背景颜色2&amp;按钮颜色2</span></span><br><span class="line">    <span class="comment"># color3: #说说字体颜色</span></span><br><span class="line">    <span class="comment"># cssUrl: #自定义css接口</span></span><br></pre></td></tr></table></figure><h3 id="BBtalk"><a href="#BBtalk" class="headerlink" title="BBtalk"></a>BBtalk</h3><figure class="highlight yaml"><figcaption><span>blog/_config.volantis.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">plugins:</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="comment"># BBtalk https://bb.js.org</span></span><br><span class="line">  <span class="attr">bbtalk:</span></span><br><span class="line">    <span class="comment"># Set `plugins: [&quot;bbtalk&quot;]` to enable in front-matter</span></span><br><span class="line">    <span class="comment"># 支持 Pjax</span></span><br><span class="line">    <span class="attr">js:</span> <span class="string">https://cdn.jsdelivr.net/npm/bbtalk@0.1.5/dist/bbtalk.min.js</span> <span class="comment"># BBtalk.js</span></span><br><span class="line">    <span class="attr">appId:</span> <span class="string">0KzOX4vC7Jsk6vzUGNeEiUaI-gzGzoHsz</span> <span class="comment"># your appID</span></span><br><span class="line">    <span class="attr">appKey:</span> <span class="string">HwCiWuxfpvKiLm4teCUgTIba</span> <span class="comment"># your appKEY</span></span><br><span class="line">    <span class="attr">serverURLs:</span> <span class="string">https://bbapi.heson10.com</span> <span class="comment"># Request Api 域名</span></span><br></pre></td></tr></table></figure><h3 id="Tidio"><a href="#Tidio" class="headerlink" title="Tidio"></a>Tidio</h3><figure class="highlight yaml"><figcaption><span>blog/_config.volantis.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">plugins:</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="comment"># 聊天功能</span></span><br><span class="line">  <span class="attr">chat_service:</span> <span class="string">tidio</span> <span class="comment"># tidio or gitter</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Tidio</span></span><br><span class="line">  <span class="comment"># https://www.tidio.com/</span></span><br><span class="line">  <span class="attr">tidio:</span></span><br><span class="line">    <span class="attr">id:</span> <span class="string">xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</span></span><br></pre></td></tr></table></figure><h3 id="友链朋友圈"><a href="#友链朋友圈" class="headerlink" title="友链朋友圈"></a>友链朋友圈</h3><figure class="highlight yaml"><figcaption><span>blog/_config.volantis.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">plugins:</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="comment"># 友链朋友圈 hexo-circle-of-friends</span></span><br><span class="line">  <span class="comment"># https://github.com/Rock-Candy-Tea/hexo-circle-of-friends</span></span><br><span class="line">  <span class="comment"># https://zfe.space/post/friend-link-circle.html</span></span><br><span class="line">  <span class="attr">fcircle:</span></span><br><span class="line">    <span class="comment"># Set `plugins: [&quot;fcircle&quot;]` to enable in front-matter</span></span><br><span class="line">    <span class="comment"># 支持 Pjax</span></span><br><span class="line">    <span class="attr">api:</span> <span class="string">&#x27;&#x27;</span> <span class="comment"># api 地址</span></span><br><span class="line">    <span class="attr">max_number:</span> <span class="number">20</span> <span class="comment"># 页面展示文章数量</span></span><br><span class="line">    <span class="attr">add_number:</span> <span class="number">10</span> <span class="comment"># 每次加载增加的篇数</span></span><br><span class="line">    <span class="attr">opentype:</span> <span class="string">&#x27;_blank&#x27;</span> <span class="comment"># &#x27;_blank&#x27;打开新标签,&#x27;_self&#x27;本窗口打开</span></span><br><span class="line">    <span class="attr">nofollow:</span> <span class="literal">true</span> <span class="comment"># 禁止搜索引擎抓取</span></span><br><span class="line">    <span class="comment"># loadingCutom: # 自定义loading图 例如: &lt;i class=&quot;fa fa-spinner fa-spin&quot;&gt;&lt;/i&gt; | &lt;img src=&quot;你的图片地址&quot; alt=&quot;加载中...&quot;&gt;</span></span><br></pre></td></tr></table></figure><h3 id="消息提示"><a href="#消息提示" class="headerlink" title="消息提示"></a>消息提示</h3><figure class="highlight yaml"><figcaption><span>blog/_config.volantis.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">plugins:</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="comment"># 消息提示 </span></span><br><span class="line">  <span class="comment"># izitoast@1.4.0</span></span><br><span class="line">  <span class="attr">message:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">css:</span> <span class="string">volantis-static/libs/izitoast/dist/css/iziToast.min.css</span></span><br><span class="line">    <span class="attr">js:</span> <span class="string">volantis-static/libs/izitoast/dist/js/iziToast.min.js</span></span><br><span class="line">    <span class="attr">icon:</span>     <span class="comment"># 默认图标，支持对图标添加颜色，可选值：see：/source/css/_style/_plugins/fontcolor.styl</span></span><br><span class="line">      <span class="attr">default:</span> <span class="string">fa-solid</span> <span class="string">fa-info-circle</span> <span class="string">light-blue</span></span><br><span class="line">      <span class="attr">quection:</span> <span class="string">fa-solid</span> <span class="string">fa-question-circle</span> <span class="string">light-blue</span></span><br><span class="line">    <span class="attr">time:</span>     <span class="comment"># 默认持续时间</span></span><br><span class="line">      <span class="attr">default:</span> <span class="number">5000</span></span><br><span class="line">      <span class="attr">quection:</span> <span class="number">20000</span></span><br><span class="line">    <span class="attr">position:</span> <span class="string">&#x27;topRight&#x27;</span>                 <span class="comment"># 弹出位置 可选值：topRight, bottomRight, bottomLeft, topLeft, topCenter, bottomCenter, center</span></span><br><span class="line">    <span class="attr">transitionIn:</span> <span class="string">&#x27;bounceInLeft&#x27;</span>         <span class="comment"># 弹窗打开动画 可选值：bounceInLeft, bounceInRight, bounceInUp, bounceInDown, fadeIn, fadeInDown, fadeInUp, fadeInLeft, fadeInRight, flipInX</span></span><br><span class="line">    <span class="attr">transitionOut:</span> <span class="string">&#x27;fadeOutRight&#x27;</span>        <span class="comment"># 弹窗关闭动画 可选值：fadeOut, fadeOutUp, fadeOutDown, fadeOutLeft, fadeOutRight, flipOutX</span></span><br><span class="line">    <span class="attr">titleColor:</span> <span class="string">&#x27;var(--color-text)&#x27;</span>      <span class="comment"># 标题颜色</span></span><br><span class="line">    <span class="attr">messageColor:</span> <span class="string">&#x27;var(--color-text)&#x27;</span>    <span class="comment"># 消息颜色</span></span><br><span class="line">    <span class="attr">backgroundColor:</span> <span class="string">&#x27;var(--color-card)&#x27;</span> <span class="comment"># 默认背景色</span></span><br><span class="line">    <span class="attr">zindex:</span> <span class="number">2147483647</span>                   <span class="comment"># 层级</span></span><br><span class="line">    <span class="attr">copyright:</span>                           <span class="comment"># 是否在复制时弹出版权提示，影响范围：ctrl+c、代码块复制按钮、右键复制选项</span></span><br><span class="line">      <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">title:</span> <span class="string">&#x27;知识共享许可协议&#x27;</span></span><br><span class="line">      <span class="attr">message:</span> <span class="string">&#x27;请遵守 CC BY-NC-SA 4.0 协议。&#x27;</span></span><br><span class="line">      <span class="attr">icon:</span> <span class="string">&#x27;far fa-copyright light-blue&#x27;</span></span><br><span class="line">    <span class="attr">aplayer:</span>                              <span class="comment"># 是否开启音乐通知；播放、暂停、失败 时的图标</span></span><br><span class="line">      <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">play:</span> <span class="string">fa-solid</span> <span class="string">fa-play</span></span><br><span class="line">      <span class="attr">pause:</span> <span class="string">fa-solid</span> <span class="string">fa-pause</span></span><br><span class="line">    <span class="attr">rightmenu:</span>                            </span><br><span class="line">      <span class="attr">enable:</span> <span class="literal">true</span>                        <span class="comment"># 是否开启右键模块的消息通知</span></span><br><span class="line">      <span class="attr">notice:</span> <span class="literal">true</span>                        <span class="comment"># 唤醒原右键菜单的通知 </span></span><br></pre></td></tr></table></figure><h3 id="轮播标签"><a href="#轮播标签" class="headerlink" title="轮播标签"></a>轮播标签</h3><p>使用方法参见：<a href="/v5/tag-plugins/#swiper">swiper</a></p><figure class="highlight yaml"><figcaption><span>blog/_config.volantis.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">swiper:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">css:</span> <span class="string">https://unpkg.com/swiper@6/swiper-bundle.min.css</span></span><br><span class="line">  <span class="attr">js:</span> <span class="string">https://unpkg.com/swiper@6/swiper-bundle.min.js</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Github Pages </tag>
            
            <tag> Hexo </tag>
            
            <tag> Volantis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Github+Hexo+Volantis个人主页搭建流程</title>
      <link href="/2022/06/08/Website-Building-Tutorials/"/>
      <url>/2022/06/08/Website-Building-Tutorials/</url>
      
        <content type="html"><![CDATA[<p>本网站建立依附于Github Pages，使用到的框架是Hexo（基于Node.js），使用的主题是Volantis，图床使用Github自行搭建。目前用到的外部支持有：Busuanzi、Giscus、Parallax等。</p><span id="more"></span><p>后置教程：</p><div class="tag link"><a class="link-card" title="Github+Hexo+Volantis个人主页个性化搭建（进阶版）" href="https://yaelcassini.github.io/2022/06/08/Website-Building-Tutorials/"><div class="left"><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/blog/logo_256.png"/></div><div class="right"><p class="text">Github+Hexo+Volantis个人主页个性化搭建（进阶版）</p><p class="url">https://yaelcassini.github.io/2022/06/08/Website-Building-Tutorials/</p></div></a></div><p>搭建参考教程链接：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/60578464">https://zhuanlan.zhihu.com/p/60578464</a></li><li><a href="https://zhuanlan.zhihu.com/p/111614119">https://zhuanlan.zhihu.com/p/111614119</a></li></ul><h2 id="主要步骤"><a href="#主要步骤" class="headerlink" title="主要步骤"></a>主要步骤</h2><h3 id="一-安装Git和Node-js"><a href="#一-安装Git和Node-js" class="headerlink" title="一. 安装Git和Node.js"></a>一. 安装Git和Node.js</h3><ul><li>Git官网：<a href="https://nodejs.org/en/download/">https://nodejs.org/en/download/</a></li><li><ul><li>检查是否安装成功命令（cmd）：<code>git--version</code></li></ul></li><li>Node.js官网：<a href="https://nodejs.org/en/download/">https://nodejs.org/en/download/</a></li><li><ul><li>检查是否安装成功命令（cmd）：<code>node -v</code> 和 <code>npm -v</code></li></ul></li></ul><h3 id="二-本地部署Hexo博客"><a href="#二-本地部署Hexo博客" class="headerlink" title="二. 本地部署Hexo博客"></a>二. 本地部署Hexo博客</h3><h4 id="1-新建文件夹"><a href="#1-新建文件夹" class="headerlink" title="1. 新建文件夹"></a>1. 新建文件夹</h4><ul><li>空文件夹名：用户名.github.io（用户名为github用户名）</li></ul><h4 id="2-安装Hexo"><a href="#2-安装Hexo" class="headerlink" title="2. 安装Hexo"></a>2. 安装Hexo</h4><ul><li>右键Git Bash Here，输入命令：<code>$ npm install hexo-cli -g</code></li><li>检查是否安装成功命令：hexo -v</li><li>安装一键部署插件：<code>npm install hexo-deployer-git --save</code></li></ul><h4 id="3-hexo初始化并安装依赖"><a href="#3-hexo初始化并安装依赖" class="headerlink" title="3. hexo初始化并安装依赖"></a>3. hexo初始化并安装依赖</h4><ul><li>hexo init</li><li>npm install</li><li>Hexo文件夹目录结构：<br><img src="https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202206141355.jpg" alt="这是图片" title="Hexo博客文件夹目录结构"></li></ul><h4 id="4-生成页面并本地预览"><a href="#4-生成页面并本地预览" class="headerlink" title="4. 生成页面并本地预览"></a>4. 生成页面并本地预览</h4><ul><li>hexo g &amp;&amp; hexo s</li><li>切换端口号预览：hexo server -p 5000</li></ul><h4 id="5-修改-config中的主题为volantis"><a href="#5-修改-config中的主题为volantis" class="headerlink" title="5. 修改_config中的主题为volantis"></a>5. 修改_config中的主题为volantis</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: volantis</span><br></pre></td></tr></table></figure><h4 id="6-下载Volantis主题，编译查看效果"><a href="#6-下载Volantis主题，编译查看效果" class="headerlink" title="6. 下载Volantis主题，编译查看效果"></a>6. 下载Volantis主题，编译查看效果</h4><ul><li>安装主题：<code>npm i hexo-theme-volantis</code></li><li>安装 Hexo 搜索的依赖包：<code>npm i hexo-generator-search hexo-generator-json-content</code></li><li>安装 Stylus 渲染器：<code>npm i hexo-renderer-stylus</code></li></ul><h4 id="7-创建Volantis主题所需要的页面"><a href="#7-创建Volantis主题所需要的页面" class="headerlink" title="7. 创建Volantis主题所需要的页面"></a>7. 创建Volantis主题所需要的页面</h4><ul><li><p>参考链接：<a href="https://blog.csdn.net/qq_44161695/article/details/117648144">https://blog.csdn.net/qq_44161695/article/details/117648144</a></p></li><li><p>创建分类：hexo new page “categories”，并修改内容为：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">layout: category</span><br><span class="line">index: true</span><br><span class="line">title: 所有分类</span><br><span class="line">sidebar: [blogger]</span><br><span class="line">date: 2022-06-08 18:09:42</span><br><span class="line">---</span><br></pre></td></tr></table></figure></li><li><p>创建标签：hexo new page “tags”，并修改内容为：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">layout: tag</span><br><span class="line">index: true</span><br><span class="line">title: 所有标签</span><br><span class="line">sidebar: [blogger]</span><br><span class="line">date: 2022-06-08 18:10:12</span><br><span class="line">---</span><br></pre></td></tr></table></figure></li><li><p>创建关于我：hexo new page “about”，并修改内容为：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">layout: docs</span><br><span class="line">seo_title: 关于</span><br><span class="line">bottom_meta: false</span><br><span class="line">sidebar: []</span><br><span class="line">valine:</span><br><span class="line">placeholder: 有什么想对我说的呢？</span><br><span class="line">date: 2022-06-08 18:10:36</span><br><span class="line">---</span><br></pre></td></tr></table></figure></li><li><p>创建友链：hexo new page “friends”</p></li></ul><h4 id="8-主题样式配置"><a href="#8-主题样式配置" class="headerlink" title="8. 主题样式配置"></a>8. 主题样式配置</h4><ul><li>新建_config.volantis.yaml，参考Volantis官网源码修改_config.volantis.</li><li>yaml文件：<a href="https://github.com/volantis-x/community/blob/main/_config.volantis.yml">https://github.com/volantis-x/community/blob/main/_config.volantis.yml</a></li></ul><h4 id="9-常用命令"><a href="#9-常用命令" class="headerlink" title="9. 常用命令"></a>9. 常用命令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;name&quot;       # 新建文章</span><br><span class="line">hexo new page &quot;name&quot;  # 新建页面</span><br><span class="line">hexo g                # 生成页面</span><br><span class="line">hexo d                # 部署</span><br><span class="line">hexo g -d             # 生成页面并部署</span><br><span class="line">hexo s                # 本地预览</span><br><span class="line">hexo clean            # 清除缓存和已生成的静态文件</span><br><span class="line">hexo help             # 帮助</span><br></pre></td></tr></table></figure><h4 id="10-tips"><a href="#10-tips" class="headerlink" title="10. tips"></a>10. tips</h4><ol><li>Hexo 设置显示文章摘要，首页不显示全文<br>Hexo 主页文章列表默认会显示文章全文，浏览时很不方便，可以在文章中插入 <code>&lt;!--more--&gt;</code> 进行分段。该代码前面的内容会作为摘要显示，而后面的内容会替换为 “Read More” 隐藏起来。</li><li>连接不上Github：</li></ol><ul><li><p><a href="https://blog.csdn.net/sinat_32017511/article/details/115762643">https://blog.csdn.net/sinat_32017511/article/details/115762643</a></p></li><li><p><a href="https://blog.csdn.net/Sheyami/article/details/121631887">https://blog.csdn.net/Sheyami/article/details/121631887</a></p></li><li><p>可以尝试在.git&#x2F;config中增加：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[http]</span><br><span class="line">    sslVerify = false</span><br></pre></td></tr></table></figure></li><li><p>最终解决方案：重新Clone（orz</p></li></ul><h3 id="三-部署到Github"><a href="#三-部署到Github" class="headerlink" title="三. 部署到Github"></a>三. 部署到Github</h3><ul><li>Github官网：<a href="https://github.com/">https://github.com/</a><h4 id="1-创建仓库：仓库名：用户名-github-io"><a href="#1-创建仓库：仓库名：用户名-github-io" class="headerlink" title="1. 创建仓库：仓库名：用户名.github.io"></a>1. 创建仓库：仓库名：用户名.github.io</h4><h4 id="2-本地配置git-username和git-useremail"><a href="#2-本地配置git-username和git-useremail" class="headerlink" title="2. 本地配置git username和git useremail"></a>2. 本地配置git username和git useremail</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;Name&quot;</span><br><span class="line">git config --global user.email &quot;Email&quot;</span><br></pre></td></tr></table></figure><h4 id="3-SSH-key配置"><a href="#3-SSH-key配置" class="headerlink" title="3. SSH-key配置"></a>3. SSH-key配置</h4></li><li>参考链接：<a href="https://zhuanlan.zhihu.com/p/111614119">https://zhuanlan.zhihu.com/p/111614119</a></li><li>本地生成密钥：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;Email&quot;</span><br></pre></td></tr></table></figure></li><li>打开：C:&#x2F;Users&#x2F;用户名&#x2F;.ssh&#x2F;id_rsa.pub，并全选复制。</li><li>在Github-Settings新建SSH，并粘贴。</li><li>本地输入以下命令检查是否成功连接：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><h4 id="4-在-config-yaml中加入deploy配置"><a href="#4-在-config-yaml中加入deploy配置" class="headerlink" title="4. 在_config.yaml中加入deploy配置"></a>4. 在_config.yaml中加入deploy配置</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line">type: git</span><br><span class="line">repository: git@github.com:panakot/panakot.github.io.git</span><br><span class="line">branch: master</span><br></pre></td></tr></table></figure><h4 id="5-部署网页并查看效果"><a href="#5-部署网页并查看效果" class="headerlink" title="5. 部署网页并查看效果"></a>5. 部署网页并查看效果</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure></li></ul><h3 id="四-使用github建立图床"><a href="#四-使用github建立图床" class="headerlink" title="四. 使用github建立图床"></a>四. 使用github建立图床</h3><h4 id="1-新建Github仓库"><a href="#1-新建Github仓库" class="headerlink" title="1. 新建Github仓库"></a>1. 新建Github仓库</h4><h4 id="2-下载图片并上传到Github仓库"><a href="#2-下载图片并上传到Github仓库" class="headerlink" title="2. 下载图片并上传到Github仓库"></a>2. 下载图片并上传到Github仓库</h4><h4 id="3-通过链接访问图片"><a href="#3-通过链接访问图片" class="headerlink" title="3. 通过链接访问图片"></a>3. 通过链接访问图片</h4><p>格式示例：<code>https://cdn.jsdelivr.net/gh/YaelCassini/MyGraphBed/note/202206141355.jpg</code></p><ul><li>其中，YaelCassini为github的username，MyGraphBed为我创建的仓库名称，而note&#x2F;202206141355.jpg为仓库内图片的路径</li></ul><h3 id="五-配置插件"><a href="#五-配置插件" class="headerlink" title="五. 配置插件"></a>五. 配置插件</h3><h4 id="1-配置计数busuanzi"><a href="#1-配置计数busuanzi" class="headerlink" title="1. 配置计数busuanzi"></a>1. 配置计数busuanzi</h4><h4 id="2-配置插件giscus："><a href="#2-配置插件giscus：" class="headerlink" title="2. 配置插件giscus："></a>2. 配置插件giscus：</h4><ul><li>官网：<a href="https://giscus.app/zh-CN">https://giscus.app/zh-CN</a></li><li>参考资料：<ul><li><a href="https://www.michaeltan.org/posts/giscus/">https://www.michaeltan.org/posts/giscus/</a></li><li><a href="https://vuepress-theme-hope.github.io/v1/comment/zh/guide/giscus.html">https://vuepress-theme-hope.github.io/v1/comment/zh/guide/giscus.html</a></li></ul></li></ul><h3 id="六-多设备管理源码"><a href="#六-多设备管理源码" class="headerlink" title="六. 多设备管理源码"></a>六. 多设备管理源码</h3><ul><li>参考链接：<ul><li><a href="https://www.zhihu.com/question/21193762/answer/103097754">https://www.zhihu.com/question/21193762/answer/103097754</a></li><li><a href="https://blog.csdn.net/heimu24/article/details/81210640">https://blog.csdn.net/heimu24/article/details/81210640</a></li><li><a href="https://zhangypcn.github.io/2020/07/04/Personal-Website-Hexo-Source-Management/">https://zhangypcn.github.io/2020/07/04/Personal-Website-Hexo-Source-Management/</a></li><li><a href="https://www.zhihu.com/question/21193762/answer/103097754">https://www.zhihu.com/question/21193762/answer/103097754</a><h4 id="旧设备："><a href="#旧设备：" class="headerlink" title="旧设备："></a>旧设备：</h4></li></ul></li></ul><ol><li>Github新建仓库YealCassini_BlogCode(可以私有)，以使用git管理Hexo源码</li><li>将源码传到Github仓库，gitignore参考设置如下： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.DS_Store</span><br><span class="line">Thumbs.db</span><br><span class="line">db.json</span><br><span class="line">*.log</span><br><span class="line">node_modules/</span><br><span class="line">public/</span><br><span class="line">.deploy*/</span><br></pre></td></tr></table></figure><h4 id="新设备："><a href="#新设备：" class="headerlink" title="新设备："></a>新设备：</h4></li><li>安装Git和Node.js</li><li>生成SSH key并添加到github</li><li>命令行clone源码并安装需要的库：</li></ol><ul><li>git clone</li><li>npm install</li><li>npm install hexo-deployer-git –save</li></ul><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><h4 id="Icon网站"><a href="#Icon网站" class="headerlink" title="Icon网站"></a>Icon网站</h4><ul><li><a href="https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0.0/assets/svg/">https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0.0/assets/svg/</a></li><li><a href="https://unpkg.com/browse/volantis-static@0.0.1649552113628/media/org.volantis/icon/1322024-social-media/">https://unpkg.com/browse/volantis-static@0.0.1649552113628/media/org.volantis/icon/1322024-social-media/</a></li><li><a href="https://fontawesome.com/icons?d=gallery">https://fontawesome.com/icons?d=gallery</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Github Pages </tag>
            
            <tag> Hexo </tag>
            
            <tag> Volantis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/06/08/hello-world/"/>
      <url>/2022/06/08/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
