{"meta":{"title":"Unknown Island","subtitle":"Cassini’s Blog","description":"赛博小屋","author":"Cassini","url":"https://yaelcassini.github.io","root":"/"},"pages":[{"title":"","date":"2022-06-08T10:10:36.000Z","updated":"2023-03-29T09:43:21.621Z","comments":true,"path":"about/index.html","permalink":"https://yaelcassini.github.io/about/index.html","excerpt":"","text":"教育经历：本科：浙江大学 数字媒体技术专业研究生：浙江大学 计算机科学与技术专业 CAD&amp;CG实验室"},{"title":"所有分类","date":"2022-06-08T10:09:42.000Z","updated":"2022-06-15T06:30:20.684Z","comments":true,"path":"categories/index.html","permalink":"https://yaelcassini.github.io/categories/index.html","excerpt":"","text":""},{"title":"或许友链","date":"2022-06-08T10:11:00.000Z","updated":"2023-05-15T08:51:07.912Z","comments":true,"path":"friends/index.html","permalink":"https://yaelcassini.github.io/friends/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2022-06-08T10:10:12.000Z","updated":"2022-06-15T06:30:20.685Z","comments":true,"path":"tags/index.html","permalink":"https://yaelcassini.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"计算机动画HW1 - 路径曲线与运动物体控制","slug":"Cardinal-Spline","date":"2023-05-16T08:05:45.000Z","updated":"2023-05-16T08:30:09.215Z","comments":true,"path":"2023/05/16/Cardinal-Spline/","link":"","permalink":"https://yaelcassini.github.io/2023/05/16/Cardinal-Spline/","excerpt":"课程名称：计算机动画 实验项目名称：路径曲线与运动物体控制 实验日期：2020 年 9 月 27 日","text":"课程名称：计算机动画 实验项目名称：路径曲线与运动物体控制 实验日期：2020 年 9 月 27 日 codehttps://github.com/YaelCassini/CA_HW1 videohttps://www.bilibili.com/video/BV1T34y1B7WJ/ reporthttps://yaelcassini.github.io/2023/05/16/Cardinal-Spline/ 一、 实验目的和要求 设计并实现一个路径曲线，通过不同参数控制曲线状态，并实现对物体沿生成路线运动的控制。 通过上述实验内容，了解动画动态控制的基本原理何方法，提高动画编程能力。 二、 实验内容和原理 选用 Cardinal 曲线表示运动路径，掌握它的表示和算法，了解不同控制参数对曲线形状和状态的影响。 编写代码实现 Cardinal 曲线算法，对照 cardinal 样条曲线的数学表示和程序之间的对应关系。 给定若干关键控制点的位置（这些控制点可以大致描述某个运动路径的形状），用上述程序计算出控制点之间的插值点，显示出样条曲线。 改变曲线弯曲程度的参数$τ∈[0，1]$大小和控制插值点数目的参数 grain ，观察曲线形状的变化。 在路径曲线上放置一小汽车，使其在沿生成的 cardinal 曲线运动，汽车速度和加速度可以调节。 三、 实验平台Qt 5.14.2 @ Windows 四、 实验步骤 首先，对照Cardinal 样条曲线的数学表达和程序中计算代码的对应关系。Cardinal 样条曲线矩阵表示：$$$ P(u) &#x3D; U^T M B $$$其中，u 是幂次最高为 3 的插值变量，且u∈[0,1]， M 是 Hermite 多项式矩阵，B 是曲线中，用户指定的关键点数据。其矩阵展开表示。 其中，$P_i-1，P_i，P_i+1，P_i+2$，是用户指定的控制点控制点，参数τ 控制曲线的弯曲程度。为了实现 Cardinal 样条曲线计算，创建 spline 类。 1234567891011121314151617181920212223242526272829303132333435363738class spline&#123;private: double *ax,*bx,*cx,*dx;//P(u)系数 double *ay,*by,*cy,*dy;//P(u)系数 double *A,*B,*C,*D,*E;//计算弧长所用系数 double* matrix[4];//计算矩阵 double tension;//参数τ int num;//关键点个数 int grain;//每两个关键点之间插值点的个数（含关键点） bool create_flag=false;//是否已经为指针分配空间（判断是否需要delete） vector&lt;QPoint&gt; all_points;//所有点public: spline(); //生成CubicSpline曲线 void set_Spline(vector&lt;QPoint&gt;&amp; vec,int _grain,double _tension); //计算生成的三次样条曲线上所有插值点 void CubicSpline(vector&lt;QPoint&gt;&amp; vec); double calc_Total_length(); //计算曲线总长度 void init_Matrix(); //初始化矩阵 void init_spline_Coefficient(vector&lt;QPoint&gt;&amp; vec);//计算P(u)系数 QPoint calc_Interpolation(int i,double u);//计算内部插值点 point calc_double_Interpolation(int i,double u);//计算内部插值点（坐标为double类型） vector&lt;QPoint&gt;&amp; get_all_points(); //返回储存所有插值点的vector void init_length_Coefficient(int _num);//初始化长度计算参数 double f(int i,double u); //f函数 double simpson(int i,double a,double b);//求样条曲线长度 double calc_U(double s,int i,double u1,double u2);//根据长度计算参数u的值 void clear();//清除数据 ~spline()&#123;&#125;&#125;; 其中 set_Spline 函数根据关键点数组 vec、插值点数目 _grain、和控制曲线弯曲程度的参数 _tension 生成样条曲线所需要的计算数据（如矩阵数值，P(u)系数等）。具体算法见源码。 其中init_Matrix 函数计算矩阵中的数值，即为 P(u)公式中的矩阵M。init_spline_Coefficient 函数计算不同曲线段中的P(u)多项式系数，即为公式中的 M*B（分 x，y 两个方向计算）。具体算法见源码。 CubicSpline 函数，根据_grain 值生成不同的u 值，并计算曲线上所有插值点的坐标，储存在名为 all_points 的 vector 中。 123456789101112131415161718192021222324252627282930//计算曲线上所有插值点void spline::CubicSpline(vector&lt;QPoint&gt;&amp; vec)&#123; //当没清除就再次点击生成曲线时，不清除之前的插值点，插入间隔点 QPoint temp(0,0); all_points.push_back(temp); //根据设置的插值点个数参数，计算对应的u值 int num=vec.size(); double* u = new double[grain]; for (int i = 0; i&lt;grain; i++) &#123; u[i] = ((double)i) / grain; //u [0,1] &#125; //根据u值和曲线参数计算插值点坐标 for (int i = 0; i&lt;num-1; i++) &#123; QPoint p1=vec[i]; //加入关键点 all_points.push_back(p1); for (int j = 1; j&lt;grain; j++) &#123; QPoint temp=calc_Interpolation(i,u[j]); all_points.push_back(temp); &#125; &#125; //加入关键点 QPoint p1=vec[num-1]; all_points.push_back(p1); delete []u;&#125; 其中，calc_Interpolation 函数根据曲线段序号i，和参数 u 的不同值，计算具体一个插值点的坐标。 编写 paintWindow 类作为画板，继承自 QWidget 类。在paintWindow 类中编写鼠标回调函数mousePressEvent，记录通过鼠标交互选定的关键点。以及绘制函数 paintEvent，在每次update（）时调用。paintWindow 类定义具体如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class paintWindow : public QWidget&#123; Q_OBJECTprivate: spline* sp; int grain; //每个曲线区间有多少个插值点（包括两端关键点） double tension; //参数，控制曲线弯曲程度 bool ifDrawInpoint=false; //是否显示插值点 int time;//时间 QTimer* timer; //计时器 QPixmap* car[5]; //储存小车位图信息 int car_index;//显示第几种小车 int pen_index=0;//使用第几种笔刷 double speed; //小车速度 double accelerate; //小车加速度 point now_point; //运动当前点 point next_point; //运动下一个点 double ratio; //旋转角度 vector&lt;QPoint&gt; points;//储存所有关键点 bool endflag=false; //小车是否运动到曲线末端public: paintWindow(); void paintEvent(QPaintEvent *); //绘制函数 void mousePressEvent(QMouseEvent *e); //鼠标回调函数 void create_Spline(int _grain, double _tension); //生成并显示cubicspline曲线 void start_Move(double _speed,double _accelarate); //小车开始运动 void stop_Move(); //小车暂停运动 void continue_Move(); //小车继续运动 int numbers(); //关键点个数 double total_length(); //曲线总长度 double now_length(); //小车当前走过的路线长度 int get_spline_index(double now_len); //获取小车当前在哪一段曲线 double get_Ratio(); //获取当前曲线斜率 void change_car(); //改变小车 void change_pen(QPainter&amp; paint); //改变笔刷 void change_DrawInPoint(); //改变是否绘制插值点的控制变量 QPixmap* now_car(); //当前小车位图指针 void clear();private slots: void changeState(); //连接计时器，改变小车坐标，旋转角度等信息&#125;; 鼠标回调函数mousePressEvent，记录通过鼠标交互选定的关键点。绘制函数 paintEvent，根据数据变化，绘制所有的关键点、曲线，已经选择是否绘制插值点。 引入QTimer 类作为计时器，每隔一段时间调用 changestate 函数，改变小车坐标及旋转角度等。其中now_point 是当前小车位置，next_point 是下一个小车位置。get_Ratio 函数计算当下曲线的斜率，以及小车旋转角度。 MainWindow 设计及按钮槽函数 MainWindow 窗口设计如下： MainWindow 类设计： 12345678910111213141516171819202122232425class MainWindow : public QMainWindow&#123; Q_OBJECTprivate: paintWindow* p_w;public: MainWindow(QWidget *parent = nullptr); ~MainWindow();private slots: void on_create_clicked();//绘制曲线并显示 void on_clear_clicked();//清屏 void on_start_clicked();//开始运动按钮槽函数 void on_show_clicked();//展示插值点按钮槽函数 void on_stop_move_clicked();//停止运动按钮槽函数 void on_continue_move_clicked();//继续运动按钮槽函数 void update_numbers();//更新关键点数目 void on_change_clicked();private: Ui::MainWindow *ui;&#125;; 五、 实验结果分析选取控制点： 绘制曲线：同时显示关键点个数和路线总长度。 不同参数对曲线值的影响： 1、不同的 grain：grain&#x3D;5（红色）和 grain&#x3D;60（蓝色） 2、不同的tension（τ）：分别为：0（绿色），0.25（灰色），0.5（红色），0.75（蓝色），1.0（黄色） 显示插值点（白色为内部插值点）： 小车开始运动： 更换小车：","categories":[{"name":"Homework","slug":"Homework","permalink":"https://yaelcassini.github.io/categories/Homework/"}],"tags":[{"name":"Computer Animation","slug":"Computer-Animation","permalink":"https://yaelcassini.github.io/tags/Computer-Animation/"},{"name":"Spline","slug":"Spline","permalink":"https://yaelcassini.github.io/tags/Spline/"}]},{"title":"计算机动画HW2 - 线性插值和矢量线性插值关键帧动画","slug":"Keyframe-Interpolation","date":"2023-05-16T05:54:42.000Z","updated":"2023-05-16T08:31:19.612Z","comments":true,"path":"2023/05/16/Keyframe-Interpolation/","link":"","permalink":"https://yaelcassini.github.io/2023/05/16/Keyframe-Interpolation/","excerpt":"课程名称：计算机动画 实验项目名称：线性插值和矢量线性插值关键帧动画 实验日期：2020 年 11 月 6 日","text":"课程名称：计算机动画 实验项目名称：线性插值和矢量线性插值关键帧动画 实验日期：2020 年 11 月 6 日 codehttps://github.com/YaelCassini/CA_HW2 videohttps://www.bilibili.com/video/BV1zL4y137rn/ reporthttps://yaelcassini.github.io/2023/05/16/Keyframe-Interpolation/ 一、 实验目的和要求 关键帧动画技术是计算机动画中的一类重要技术。本实验选取线性插值和矢量线性插值作为实验内容，旨在了解关键帧动画系统的结构，变形算法的思想以及不同算法对应的不同性能。 本实验要求实现线性插值和矢量线性插值两种关键帧插值算法的图形化界面展示，用户通过鼠标点击交互选定起点帧和终点帧的关键点，由程序自行生成起始帧的图形，并且通过计算得到中间的插值图像，连续播放形成关键帧动画。 二、 实验内容和原理系统包括三个部分： 输入数据：包括初始形状数据和终止形状数据, 一般为事先定义好的整型变量数据,如简单的几何物体形状(苹果，凳子，陶罐)以及简单的动物形状(大象，马)等。也可以设计交互界面，用户通过界面交互输入数据。 插值算法：包括线性插值和矢量线性插值。 线性插值：对于初始和终止形状上每个点的坐标 $P_i$ 进行线性插值得到物体变形的中间形状； 矢量线性插值：对初始形状和终止形状上每两个相邻点计算其对应的矢量的长度和角度，然后对其进行线性插值得到中间长度和角度， 对起点帧和终点帧的第一个关键点进行线性插值得到中间图像的第一个关键点。顺序连接插值后定义的各个矢量得到中间变化形状。插值变量变化范围是[0，1], 插值变量等于 0 时对应于初始形状，插值变量等于 0 时对应于终止形状；数据类型为 double。 插值结果输出。用户可以在图形化界面中自行指定插值帧的个数以及动画刷新频率，程序会根据其设定的参数生成不同效果的关键帧动画并播放动画。用户可以通过点击不同插值方式的按钮，反复播放不同算法生成的插值结果。 三、 实验平台Qt 5.14.2 @ Windows 四、 实验步骤1. 线性插值：指定两幅关键画面图形(最简单的是大小不同的两个矩形，分别由４个点构成。学生也可以自己构造更复杂的图形，如由若干点构成的手图形)， 然后计算两幅图对应点的线性距离来得到它们的中间画面图形。设图形上有 N 个点，$(x_i，y_i), i&#x3D;1,…N$; 初始图形的点记为$(x_{0i}， y_{0i})$，终止图形记为$(x_{1i}，y_{1i})$，生成的中间图形记为$(x_{ti}，y_{ti})$，设生成 M 个画面，则有： $$$ x_{ti} &#x3D; x_0t + x_1(1-t); t&#x3D;1,…M; y_{ti} &#x3D; y_0t + y_1(1-t); $$$ 线性插值代码实现： 12345678910111213141516171819if (mode == 0)&#123; inter_points.clear(); double t = 1.0 * time / grain; for (int i = 0; i &lt; start_points.size(); i++) &#123; QPoint temp; double x0 = start_points[i].x(); double y0 = start_points[i].y(); double x1 = end_points[i].x(); double y1 = end_points[i].y(); double x = (1 - t) * x0 + t * x1; double y = (1 - t) * y0 + t * y1; temp.setX(x); temp.setY(y); inter_points.push_back(temp); &#125; &#125; 2. 矢量线性插值：与线性差值框架类似，但插值变量不再是线性插值中的点坐标表(x, y), 而是把图形曲线上每两个邻近点看成一个矢量，这样就能把由N 个点构成的曲线分解成 N-1 个矢量。初始图形的矢量记为$(a_{0i}， p_{0i})$，终止图形记为$(a_{1i}，p_{1i})$，生成的中间图形记为$(a_{ti}，p_{ti})$, 设生成 M 个画面，则有： $$$ a_{ti} &#x3D; a_0t + a_1(1-t); t&#x3D;1,…M; p_{ti} &#x3D; p_0t + p_1(1-t); $$$ 矢量线性插值代码实现： 1234567891011121314151617181920212223242526272829303132333435//mode==1:普通矢量线性插值(不规定矢量插值方向)else if(mode==1)&#123; inter_points.clear(); double t=1.0*time/grain; QPoint temp; double x0=start_points[0].x(); double y0=start_points[0].y(); double x1=end_points[0].x(); double y1=end_points[0].y(); double x=(1-t)*x0+t*x1; double y=(1-t)*y0+t*y1; temp.setX(x); temp.setY(y); inter_points.push_back(temp); for(int i=0;i&lt;start_vectors.size();i++) &#123; double vec_a0=start_vectors[i].a; double vec_p0=start_vectors[i].p; double vec_a1=end_vectors[i].a; double vec_p1=end_vectors[i].p; if(vec_a0&lt;0)vec_a0+=2*PI; if(vec_a1&lt;0)vec_a1+=2*PI; if(vec_a1-vec_a0&gt;PI)vec_a0+=2*PI; if(vec_a1-vec_a0&lt;-PI)vec_a1+=2*PI; double vec_a=(1-t)*vec_a0+t*vec_a1; double vec_p=(1-t)*vec_p0+t*vec_p1; x+=vec_p*cos(vec_a); y+=vec_p*sin(vec_a); temp.setX(x); temp.setY(y); inter_points.push_back(temp); &#125;&#125; 本次试验中，我还对矢量线性插值进行了三种不同的改良：分别是规定矢量顺时针旋转、规定矢量逆时针旋转以及规定矢量旋转角度小于π。使用控制变量 mode：mode 为 1、2、3 时分别在矢量插值函数代码中插入不同语句。 3.编写paintWindow 类作为画板，继承自 QWidget 类。在 paintWindow 类中编写鼠标回调函数 mousePressEvent，记录通过鼠标交互选定的关键点。以及绘制函数paintEvent，在每次 update()时调用。paintWindow 类定义具体如下： 123456789101112131415161718192021222324252627282930313233343536373839class paintWindow : public QWidget&#123; Q_OBJECTprivate: int grain; //每个曲线区间有多少个插值点(包括两端关键点) int speed; //刷新速度(改为int) int mode=0; //插值模式 int pen_index=0;//使用第几种笔刷 int time;//时间 QTimer* timer; //计时器 vector&lt;QPoint&gt; start_points;//储存起点帧点坐标 vector&lt;Vector&gt; start_vectors;//储存起点帧向量 vector&lt;QPoint&gt; end_points;//储存终点帧点坐标 vector&lt;Vector&gt; end_vectors;//储存终点帧向量 vector&lt;QPoint&gt; inter_points;//储存当前插值帧关键点 bool start_draw=false; //是否绘制起始帧图像 bool end_draw=false; //是否绘制终止帧图像 bool startframe=true; //是否处于起始帧选定状态 bool endframe=true; //是否处于终止帧选定状态public: paintWindow(); void change_frame(); //从起始帧切换到终止帧 void finish_frame(); //结束终止帧交互 void calc_vectors(); //计算关键帧向量 void set_interpolation(int _grain,int _speed, int _mode); //设置动画参数 void paintEvent(QPaintEvent *); //绘制函数 void mousePressEvent(QMouseEvent *e); //鼠标回调函数 int numbers(); //关键点个数 void change_pen(); //改变笔刷 void clear(); //清屏private slots: void changeState(); //连接计时器，改变小车坐标，旋转角度等信息&#125;; 4.鼠标回调函数 mousePressEvent，记录通过鼠标交互选定的关键点，储存在名为start_points 和 end_points 的vector 中。 1234567//鼠标回调函数，鼠标点击，加入关键点void paintWindow::mousePressEvent(QMouseEvent * e)&#123; if (startframe)start_points.push_back(e-&gt;pos()); else if (endframe) end_points.push_back(e-&gt;pos()); update();&#125; 5.绘制函数 paintEvent，根据数据变化，绘制所有的关键点，起始帧图像，以及中间插值图像。(篇幅限制，此处省略部分代码) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//绘制函数void paintWindow::paintEvent(QPaintEvent*)&#123; QPainter paint(this); if (start_points.size() &lt;= 0)return; //没有关键点6. //设置笔刷样式，绘制关键点 paint.setPen(QPen(Qt::black, 5, Qt::DashDotLine, Qt::RoundCap)); for (int i = 0; i &lt; start_points.size(); i++) paint.drawEllipse(start_points[i], 1, 1); for (int i = 0; i &lt; end_points.size(); i++) paint.drawEllipse(end_points[i], 1, 1); //设置笔刷样式，绘制起点帧图像 //paint.setPen(QPen(Qt::blue,3,Qt::SolidLine,Qt::RoundCap)); if (start_points.size() &gt; 0) &#123; if (start_draw) &#123; for (unsigned int i = 0; i &lt; start_points.size() - 1; i++) &#123; QPoint p1 = start_points[i]; QPoint p2 = start_points[i + 1]; paint.drawLine(p1, p2); &#125; QPoint p1 = start_points[0]; QPoint p2 = start_points[start_points.size() - 1]; paint.drawLine(p1, p2); &#125; &#125; //设置笔刷样式，绘制终点帧图像(省略) //设置笔刷样式，绘制插值帧图像 //paint.setPen(QPen(Qt::red,3,Qt::DotLine,Qt::RoundCap)); if (time != 0) &#123; if (inter_points.size() &gt; 0) &#123; for (unsigned int i = 0; i &lt; inter_points.size() - 1; i++) &#123; QPoint p1 = inter_points[i]; QPoint p2 = inter_points[i + 1]; paint.drawLine(p1, p2); &#125; QPoint p1 = inter_points[0]; QPoint p2 = inter_points[inter_points.size() - 1]; paint.drawLine(p1, p2); &#125; &#125;&#125; 6.引入QTimer 类作为计时器，每隔一段时间调用 changestate 函数， 在该函数中，改变当前插值图像信息。通过线性插值或者矢量线性插值计算，将当前插值图像的所有关键点坐标储存在名为inter_points 的vector 中。 7. MainWindow 设计及按钮槽函数MainWindow 窗口设计如下： 五、 实验结果分析分析不同起始帧和终止帧对应不同插值方法的效果和局限性： 1) 普通四边形(几乎不旋转)普通线性插值和第一种矢量线性插值(变换角不大于π)效果都很好，但是规定变换方向为顺时针或者逆时针的则出现了变形问题，通过分析，我找到了原因，这是因为有两条相邻的边，向量旋转方向相反，比如： 上图中绿色标注的边终点帧比起点帧的向量角度更小，而蓝色标注的边，则是终点帧比起点帧的向量角度更大，因此在选择向量顺时针插值时，绿色标注的边可以直接选择角度小于π的旋转方式，而蓝色标注的边则会选择大于π的旋转方式(几乎接近旋转一周)，因此导致图像插值过程中变形。 2) 边交叉的四边形(有一定的旋转角度(0 ~π&#x2F;2)) 可以看出上图中四种插值方式的效果都非常好，顺时针向量插值时，图像呈现顺时针转动效果，逆时针插值时效果相反。 3) 小车大小变化(有一定的旋转角度(π&#x2F;2 ~π)) 可以看出上图中直接线性插值方式会产生明显的变形，不能保持形状平滑变化，而其他三种矢量线性插值方式效果都表现得非常好。 4) 箭头图形(旋转角度接近π) 可以看出上图中直接线性插值方式会产生明显的变形，不能保持形状平滑变化，第一种矢量线性插值方式也会产生非常严重的变形， 而规定了顺时针或者逆时针差值的矢量线性插值方式效果表现得非常好。通过分析，我找到了原因，这是因为对第一种矢量线性差之方式， 有两条相邻的边，向量旋转方向在都接近π的情况下，一个比π略小一些，一个比π略大一些，比如： 上图中绿色标注的边终点帧比起点帧的向量大一个接近π的值， 于是算法在判断后，认为该边应该逆时针旋转插值，而蓝色标注的边， 则是终点帧比起点帧的向量大一个稍大于π的值(也可以看成是小一个接近π的值)，因此算法在判断后，认为该边应该顺时针旋转。这就导致了相邻的两个向量向着不同的方向旋转，因此导致图像插值过程中变形。 5) 复杂图像的关键帧插值动画 如上图，可以看出，除了线性插值有明显的变形之外，其他三种矢量差值方式都表现得效果非常好。 6) 分析总结没有一种关键帧动画算法可以适用于所有的场景，通过对不同起始帧终止帧图像的情形的实践和分析，我总结出： 对于方向基本没有变化的初始帧和终止帧，普通线性插值效果非常不错，第一种矢量线性插值算法(规定矢量旋转角度小于π)也表现非常好，第二三种矢量线性插值算法(规定矢量旋转方向为顺时针或者逆时针)则可能会产生较大的变形，原因是相邻两个矢量旋转角度一个大于零一个小于零。 对于方向有一定变化(0~π)的初始帧和终止帧，普通线性插值算法会使得插值图像有较大的变形(一般情况下，旋转角度大的， 变形程度也会更大)，而三种矢量线性插值算法都表现得效果非常好。 对于方向变化接近π的初始帧和终止帧，普通线性插值算法也会使得插值图像有较大的变形(一般情况下，旋转角度大的，变形程度也会更大)，第二三种矢量线性插值算法(规定矢量旋转方向为顺时针或者逆时针)也表现非常好，第一种矢量线性插值算法(规定矢量旋转角度小于π)则可能会产生较大的变形，原因是相邻两个矢量旋转角度一个大于π一个小于零π。 对于方向变化较大(π~2π)的初始帧和终止帧，效果可以参考第二条。 以上所有总结建立在本实验程序的演示基础上，本实验中产生这些现象的主要原因是，不能保证初始帧和终止帧有完全相同的角度，如果在更多元化的图形化交互界面中，可以将初始帧直接复制放大缩小平移旋转得到终止帧，则每一种矢量线性插值算法都不会产生上述的严重变形现象。 但是在真正的动画制作中，也不可能保证初始帧和终止帧有完全相同的角度，因此本次实验的分析还是非常具有实际意义的。","categories":[{"name":"Homework","slug":"Homework","permalink":"https://yaelcassini.github.io/categories/Homework/"}],"tags":[{"name":"Computer Animation","slug":"Computer-Animation","permalink":"https://yaelcassini.github.io/tags/Computer-Animation/"},{"name":"KeyFrame","slug":"KeyFrame","permalink":"https://yaelcassini.github.io/tags/KeyFrame/"}]},{"title":"Relightable Neural Renderer 配置环境记录","slug":"Relightable-Neural-Renderer-配置环境记录","date":"2023-05-15T07:03:48.000Z","updated":"2023-05-15T10:05:35.241Z","comments":true,"path":"2023/05/15/Relightable-Neural-Renderer-配置环境记录/","link":"","permalink":"https://yaelcassini.github.io/2023/05/15/Relightable-Neural-Renderer-%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E8%AE%B0%E5%BD%95/","excerpt":"","text":"原Github仓库地址：https://github.com/LansburyCH/relightable-nr 因为项目需要学习了Relightable Neural Rendering， 并尝试把源码下载到本地配置环境运行，被pytorch环境折磨的不轻，把最后成功的过程在这里放一下。原仓库中记录的环境是Ubuntu 16.04 + CUDA 9.0 + gcc 4.9.2 + Anaconda 3，但因为手边没有合适的Linux服务器，所以使用windows环境配置，版本太老的cuda目前已经找不到合适的pytorch支持，最后使用的环境是window 10 + python3.9.16 + pytorch 1.13.0 + cuda 11.7 + anaconda 3，在两台windows系统电脑上都成功跑通了：一台是双3090，一台是1650。 环境配置过程原仓库提供的environment环境文件太过杂乱，有很多不必要一一匹配的包，并且其中有很多版本都太老了已经无从下载，因此安装的时候就没有管这个environment了。首先在官网安装cuda11.7版本，anaconda新建一个python3.9的环境，安装pytorch1.13.0，安装命令为： 1conda install pytorch==1.13.0 torchvision==0.14.0 torchaudio==0.13.0 pytorch-cuda=11.7 -c pytorch -c nvidia 安装旧版本的pytorch指令集：https://pytorch.org/get-started/previous-versions/ 安装后需要进行的步骤为： 安装opencv：conda install opencv 安装trimesh：conda install -c conda-forge trimesh 安装torch-geometric。这里参考了：https://blog.csdn.net/xiangfengl/article/details/120254867#%E5%AE%89%E8%A3%85torch-%20geometric12345pip install torch-scatter -f https://pytorch-geometric.com/whl/torch-1.13.0%2Bcu117.htmlpip install torch-sparse -f https://pytorch-geometric.com/whl/torch-1.13.0%2Bcu117.htmlpip install torch-cluster -f https://pytorch-geometric.com/whl/torch-1.13.0%2Bcu117.htmlpip install torch-spline-conv -f https://pytorch-geometric.com/whl/torch-1.13.0%2Bcu117.htmlpip install torch-geometric pip install pyshtools pip install openexr conda install tensorboardX pip install pytorch_msssim 与此同时，源码需要做的修改： nerural-renderer模块中，rasterize_cuda_kernel.cu中，将#if __CUDA_ARCH__ &lt; 600 and defined(__CUDA_ARCH__)修改为#if __CUDA_ARCH__ &lt; 600 &amp;&amp; defined(__CUDA_ARCH__)。 将源码cuda文件夹下所有的代码中的AT_CHECK替换为TORCH_CHECK。 在precompute.py, stitch_lp.py, train_rnr.py三个文件开头添加：12import osos.environ[&#x27;OPENCV_IO_ENABLE_OPENEXR&#x27;] = &#x27;TRUE&#x27; 将np.int修改为np.int_ 由于在windows系统下，将num_workers = 8修改为num_workers = 0。 使用windows系统，需要把sh文件修改为bat文件，在线转换工具：https://daniel-sc.github.io/bash-shell-to-bat-converter/","categories":[{"name":"Neural Rendering","slug":"Neural-Rendering","permalink":"https://yaelcassini.github.io/categories/Neural-Rendering/"}],"tags":[{"name":"Neural Rendering","slug":"Neural-Rendering","permalink":"https://yaelcassini.github.io/tags/Neural-Rendering/"},{"name":"Rendering","slug":"Rendering","permalink":"https://yaelcassini.github.io/tags/Rendering/"},{"name":"anaconda","slug":"anaconda","permalink":"https://yaelcassini.github.io/tags/anaconda/"},{"name":"pytorch","slug":"pytorch","permalink":"https://yaelcassini.github.io/tags/pytorch/"}]},{"title":"Relighing学习笔记","slug":"Relighing学习笔记","date":"2023-05-08T06:47:49.000Z","updated":"2023-05-12T07:22:25.399Z","comments":true,"path":"2023/05/08/Relighing学习笔记/","link":"","permalink":"https://yaelcassini.github.io/2023/05/08/Relighing%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"virual box 共享文件夹设置： https://blog.csdn.net/jumpingpig/article/details/104109395 欧几里德结构数据(Euclidean Structure Data) 以及非欧几里德结构数据(Non-Euclidean Structure Data) https://blog.csdn.net/imsuhxz/article/details/91361977 U-net网络结构： https://zhuanlan.zhihu.com/p/313283141 nn.ReplicationPad3d 使用输入边界的复制对输入张量进行填充。 Parameters padding(int,tuple)–填充的大小。如果是int，则在所有边界中使用相同的填充。如果是6 tuple，则使用(padding_left,padding_right, padding_top, padding_bottom, padding_front, padding_back ) torch.nn.Conv3D 3D卷积, 输入的shape是(N, C_{in}, D, H, W) (N, C_{in}, D, H, W)(N, C_{in}, D, H, W)，输出shape(N, C_{out}, D_{out}, H_{out}, W_{out}) 其中，就是batch_size；C_{in}对应着输入图像的通道数，比如RGB图像通道数为3；D为深度，H、W则是tensor的长宽。 torch.nn.BatchNorm3d torch.nn.LeakyReLU","categories":[],"tags":[]},{"title":"Color-Management","slug":"Color-Management","date":"2023-04-24T08:26:01.000Z","updated":"2023-04-25T03:24:03.291Z","comments":true,"path":"2023/04/24/Color-Management/","link":"","permalink":"https://yaelcassini.github.io/2023/04/24/Color-Management/","excerpt":"","text":"颜色管理是图形学中一个非常重要的课题，图形学与图像和颜色的可视化息息相关，但是我们有时候追求的是储存元数据的信息，有时候又追求的是图像看上去合理，符合美术工作人员的期待。不同的显示器、不同的颜色空间管理以及不同的人眼都会产生颜色的感知偏差。 Gamma 矫正Gamma矫正最初是为了适应CRT显示器的非线性输出问题，目前存在则是主要为了适应人眼的非线性感知问题。 CRT显示器的非线性输出具体来说是，如果输入一个0.5的值到显示器，显示器会呈现出0.218的值 现在的Gamma矫正大多是为了拟合人眼的感知曲线，人眼对暗部细节的感知更加丰富，因此使用gamma矫正在储存图像时，相当于对源数据的暗部进行了展开，亮部进行了压缩，这样能储存更丰富的暗部细节信息。但gamma矫正本质上是一种编码格式，并不应该影响实际的数据，比如源数据在储存为RGB格式时做了gamma矫正，那么在从RGB文件中读取时要做反gamma矫正重新映射回源数据。 另外，由于历史遗留原因，我们使用的大部分显示器，仍然沿袭CRT显示器的这种非线性输出，也就是我们再把数据传递给显示器时需要做一个类似gamma矫正的变换，而显示器则会做一个类似CRT显示器的反gamma变换。 Reference Games101-Lecture 20-Color and Perception","categories":[{"name":"Computer Graphics","slug":"Computer-Graphics","permalink":"https://yaelcassini.github.io/categories/Computer-Graphics/"}],"tags":[{"name":"Color","slug":"Color","permalink":"https://yaelcassini.github.io/tags/Color/"},{"name":"Color Space","slug":"Color-Space","permalink":"https://yaelcassini.github.io/tags/Color-Space/"},{"name":"Gamma Correction","slug":"Gamma-Correction","permalink":"https://yaelcassini.github.io/tags/Gamma-Correction/"},{"name":"Tone Mapping","slug":"Tone-Mapping","permalink":"https://yaelcassini.github.io/tags/Tone-Mapping/"}]},{"title":"PBR Neural Rendering","slug":"PBR-Neural-Rendering","date":"2023-04-18T08:31:00.000Z","updated":"2023-04-19T06:49:18.532Z","comments":true,"path":"2023/04/18/PBR-Neural-Rendering/","link":"","permalink":"https://yaelcassini.github.io/2023/04/18/PBR-Neural-Rendering/","excerpt":"","text":"ICLR 2023：《Light Sampling Field and BRDF Representation for Physically-based Neural Rendering》 https://www.researchgate.net/publication/369974931_Light_Sampling_Field_and_BRDF_Representation_for_Physically-based_Neural_Rendering https://www.youtube.com/watch?v=qpIgS11DlJE https://docs.unrealengine.com/4.26/en-US/RenderingAndGraphics/Lightmass/VolumetricLightmaps/#:~:text=The%20Volumetric%20Lightmap%20allows%20previewing%20of%20objects%20with,the%20Volumetric%20Lightmap%20until%20lighting%20is%20built%20again. NeRF： https://www.matthewtancik.com/nerf NeRV： https://pratulsrinivasan.github.io/nerv/ NeRD： https://pratulsrinivasan.github.io/nerv/ State of Art of Neural Rendering https://arxiv.org/abs/2004.03805","categories":[{"name":"Neural Rendering","slug":"Neural-Rendering","permalink":"https://yaelcassini.github.io/categories/Neural-Rendering/"}],"tags":[{"name":"Neural Rendering","slug":"Neural-Rendering","permalink":"https://yaelcassini.github.io/tags/Neural-Rendering/"},{"name":"Rendering","slug":"Rendering","permalink":"https://yaelcassini.github.io/tags/Rendering/"},{"name":"PBR","slug":"PBR","permalink":"https://yaelcassini.github.io/tags/PBR/"}]},{"title":"Shadow Rendering","slug":"Shadow-Rendering","date":"2023-03-29T12:16:36.000Z","updated":"2023-03-29T12:59:43.344Z","comments":true,"path":"2023/03/29/Shadow-Rendering/","link":"","permalink":"https://yaelcassini.github.io/2023/03/29/Shadow-Rendering/","excerpt":"","text":"渲染技术研究报告——阴影绘制技术的发展历程及方法比较一、前言阴影绘制是真实感渲染中非常重要的一个模块，对提高场景的真实度有着至关重要的作用，不管是使用光栅化的流程还是光线追踪的流程进行场景绘制，阴影绘制的技术都经过了多次的更新和迭代。我也在一些课程中学习过一些简单的阴影绘制方法，因此想借此机会对所有的阴影绘制方法做一个系统性的梳理和总结。阴影绘制的方法按照时间发展顺序主要有Shadow Volume算法、Shadow Map算法、PCF算法、PCSS算法、VSM算法等等。首先，阴影的定义是Shadow is the region of space for which at least on point of the light source is occluded，也就是绘制中那些至少对一盏光源，其没有被直接照亮而是被其他物体遮挡住的区域。图源Real-Time Rendering 4th如上图所示，要实现阴影的绘制，需要考虑的有光源、遮挡物（Occluder）、接受物（Receiver）、本影区（umbra）半影区（penumbra）等。其中，对于接收物体是平面的情况，我们可以直接通过光源位置、物体几何等信息进行光线求交几何计算，解析地得到平面上阴影的形状和范围（如下图），但是这显然无法处理复杂的场景阴影绘制，也不是我们需要的通用的方法，也因此本文仍然选择聚焦于在任何曲面或者几何体上产生阴影的通用方法。图源Real-Time Rendering 4th 二、Shadow Volume算法诞生及其改进图源Real-Time Rendering 4thShadow Volume是Franklin在1977年提出的阴影绘制算法，虽然在今天这个算法由于其较大的开销已经不太被使用，但我们仍然可以从中学到一些基础的思维方式，并且由于该算法不是在图像空间进行的，因此不会像Shadow Map一样收到采样的影响。Shadow Volume算法的基本思想是对于投影物体（以一个三角形为例），以光源为出发点建立一个类似金字塔的无限延伸的体积结构，并切除在光源点和投影物体之间的部分。所有包含在剩余体积范围内的区域都处在阴影中。对于场景中的所有物体，都可以使用该方法建立其投影金字塔。在正常绘制场景时，对于每一哥Fragment，都需要遍历所有的投影金字塔，计算其是否被包含在其中并记录被包含的次数。被包含的越多，则该处阴影强度越大（阴影颜色更暗）。以此类推，绘制完成所有的Fragment。可想而知，对于较为复杂的场景，Shadow Volume方法需要的时间和空间开销都是巨大的，不仅需要管理每一个投影物体的投影金字塔，还需要对任何一个片元进行所有金字塔的遍历测试。如果场景中包含N个物体，且都可以投射阴影，则该算法的时间复杂度将达到O(n²)。 三、Shadow Map算法的诞生及其改进早在 1968年，Arthur Appel就在研究隐藏面消除时提出了光线投射算法（Ray Casting），并首次给出了光线跟踪算法的描述。其具体思路是从每一个像素射出一条射线，然后找到最接近的物体挡住射线的路径，而视平面上每个像素的颜色取决于从可见光表面产生的亮度。 1974年，Catmull为了解决消隐问题提出了Z-Buffer算法，该算法的主要思路是使用一个屏幕空间的缓存，记录每一个像素点所对应的最小深度，在绘制每一个多边形时，与对应像素位置的当前最小深度做对比，如果小于该值则证明该多边形可见，绘制并更新Z-Buffer。Z-Buffer算法思路简单且通用性较好，为之后图形学的许多技术提供了理论基础。 因此在1978年，William以Z-Buffer算法为基础，提出了Shadow Map算法，主要思想就是维护一个从光源看出的Z-Buffer（也就是Shadow Map）。能从光源出发直接看到的区域就不属于阴影，否则属于阴影。图源【3】Shadow Map是一个2-pass的算法。算法主要步骤为： 第一个pass：以光源为视点出发绘制场景，只需要绘制深度信息，像Z-Buffer算法一样记录屏幕空间上每一个像素点的最小深度，得到 Shadow Map。 第二个Pass：正常绘制场景。 在每个像素绘制时通过坐标转换，计算出其在光源坐标系下对应的屏幕坐标。 如果其在光源坐标系下的深度在浮点数精度下小于等于Shadow Map上对应位置的当前值，则证明该点被光源直接照亮，否则证明该点在阴影中。其中，需要做的坐标转换为：首先根据片元当前的屏幕坐标，乘以当前相机投影矩阵的逆矩阵得到其世界坐标，再根据光源坐标系下的投影矩阵计算出在Shadow Map的屏幕坐标。其中，对于太阳光这样的平行光我们需要使用平行投影方式绘制Shadow Map，而对于点光源则应该使用透视投影绘制Shadow Map。图源Real-Time Rendering 4th 不难想到，如何选择Shadow Map绘制的视口是一个至关重要的问题，如果光源坐标系下的视口刚好可以包含正常绘制时所有能看到的物体，如上图中所示，则算法可行，否则可能会出现正常绘制时的某些Fragment对应的光源坐标系下的坐标超过视口范围，在Shadow Map上没有对应点，无法判断是否属于阴影的情况。另外，对于在场景中间的点光源（在不同方向上都可能投射阴影），则一般选择使用一个six-view cude，分别绘制不同方向上的Shadow Map。但这样的解决方法同样也带来了不同view交界处的走样问题。 Shadow Map算法的效果很大程度上受限于 Shadow Map的分辨率，因此在绘制Shadow Map时进行场景物体的剔除和剪枝也是十分有必要的，对于那些在相机中不可见的物体，在Shadow Map中也不需要绘制，这样可以有效缩小Shadow Map绘制的范围，从而对同样分辨率的Shadow Map达到更高的利用率和绘制精度。图源Real-Time Rendering 4th 但是普通的Shadow Map算法不可避免地存在着问题，主要的两个问题有自遮挡问题（“surface acne”）和锯齿状走样问题。图源网络 其中，自遮挡问题产生的原因是如下图，在从灯光出发进行Shadow Map绘制时，视线方向与接收投影的平面方向存在夹角，但是绘制时仅采样了像素中心的深度值作为整体的深度值。在第二个pass比较深度是就会出现本来同一平面但是有部分像素通不过Shadow Map的深度测试这种情况，从而导致如下图所示的阴影错误。对该问题可以使用设置比较的bias来尝试解决，但是bias过小时不能完全避免这种错误的产生，过大时又会产生如下图中右边所示的阴影和物体不贴合的错误（被称为Light Leaks 或者 Peter Panning），出现物体悬浮的绘制效果。图源Real-Time Rendering 4th 另外一个解决Self-shadowing自遮挡问题的思路是修改绘制Shadow Map的过程，比如说绘制时进行面剔除（Face Culling），仅绘制模型的背面。这种方法在物体都是流形时（拥有背面和反面）效果较好，能很好地避免surface acne问题。但是无法处理某些模型只有单个面的情况。一种沿着这个思路的改进方法是Second-depth Shadow Map，是在绘制Shadow Map时选择front face和back face的中间值作为Shadow Map的采样值。图源Real-Time Rendering 4th 而另一个问题锯齿状走样本质上还是由于Shadow Map的分辨率限制导致的，由于Shadow Map的绘制视口与相机绘制视口不同，可能会导致在相机坐标系下占很大部分的空间在Shadow Map中仅仅对应几个像素，因而导致其不能完全表达出该部分的相互遮挡信息，正常绘制时的较大区域可能整体无法通过Shadow Map的深度测试，产生锯齿状走样。 为了解决分辨率不够导致的锯齿状走样问题，Nvdia提出了CSM算法（Cascaded Shadow Maps），也就是使用级联的阴影贴图。其主要思想就是通过物体的距离，动态地进行不同分辨率的Shadow Map的绘制，比如说对远处的物体采用分辨率较小的Shadow Map，而对于较近处的物体则采用分辨率较大Shadow Map。LearnOpenGL中提供了一种基本的思路：首先使用相机的视图和投影矩阵，反向计算出它所定义的视锥体在世界坐标系下的位置，然后将其划分为 n 个子视锥体，其中第i个截锥体的远平面是第i+1个截锥体的近平面。然后对于每一个截锥体中的物体依次渲染一张Shadow Map，在正常绘制时，则同样根据Fragment的Z值计算其应该属于哪一个截锥体，从而选取不同的Shadow Map。需要注意的一点是，如果某个物体不在相机视锥体内，但在光源和某个截锥体之间，则绘制Shadow Map时也需要对其进行考虑，否则也会造成阴影绘制的错误。 四、PCF算法&amp;PCSS算法普通的Shadow Map只能得到非零即一的阴影测试值，只能绘制硬阴影，这显然不能满足我们真实感渲染的需求，因此在1987年，William T. Reeves引入了本来用于做抗锯齿的PCF算法（Percentage Closer Filter）到阴影绘制领域，在此基础上改良得到Shadow Map算法得到了PCSS算法。该算法的基本思想是对深度测试的结果进行Filter（而不是直接对Shadow Map进行filter）。具体操作方法是：在第二个Pass进行正常绘制时，对于每一个Fragment的深度测试，不仅比较直接对应的Shadow Map像素，还要与其邻域内（比如说3*3）像素进行深度测试，小于等于（表示不在阴影中）则记为0，大于则记为1，得到一个01的矩阵，对其求平均得到一个0-1之间的浮点数值，则代表该像素的阴影值，这样就能实现软阴影的效果。图源【7】在以上这种思想的指导下我们不难发现，filter的邻域大小一定程度决定了得到的阴影边缘的平滑程度，也就是邻域越大越容易得到“软”阴影。而在生活中，当投影物体靠近接收物体时，我们得到的阴影边缘更硬，反之则较软。以此为指导，Fernando在2005年提出的PCSS算法是在PCF进行阴影绘制基础上的进一步改进。其主要思想是使用如下图所示的几何关系来估计半影区（Penumbra）的宽度（也就是阴影的软硬程度）。其中$d_blocker$指的是投影物体的深度也就是Shadow Map中储存的深度，$d_receiver$指的是接收物体的深度也就是当前片元的深度。而用此方法计算出的半影区的宽度可以指导我们进行PCF中filter邻域大小的选择。图源【8】 PCSS算法的主要流程为： Blocker Search 在一个小的邻域内采样得到投影物体的平均深度。 Penumbra Estimation 根据投影物体的平均深度和当前片元的深度计算半影区的宽度。 Percentage Closer Filtering 根据计算出的半影区的宽度选定filter的邻域大小并进行PCF计算。其中，在第一步进行投影物体深度的采样时，采样区域的大小可以用下图所示的这种方式选定，也就是根据投影物体的深度和光源的大小计算选定。图源【8】 五、VSM算法和VSSM算法VSM算法全称为Variance Shadow Mapping，VSSM算法全称为Variance Soft Shadow Mapping，这两种算法相互承袭，是一种使用统计学知识对PCSS算法的改进方案，其主要的思路是通过对Shadow Map中Block内的深度分布进行统计学估计，避免大量采样计算PCF的过程，从而加快阴影绘制速度。PCF算法的基本思想就是在某一个邻域内测试有百分之多少的像素能使得当前片元通过深度测试。也就是测试当前片元的深度在该邻域内分布在百分之多少。VSSM算法引入了统计学的知识，假设当前邻域内的深度分布符合高斯分布，如果要测试当前片元的深度在该邻域内分布在百分之多少，只需要知道当前分布的均值和方差。对于深度图邻域内均值的计算，我们可以自然地联想到对Shadow Map进行Mipmap查询。而对于方差的计算，VSM引入了以下的公式，因此我们只需要在绘制Shadow Map的同时绘制一个储存深度的平方的map。$var(x)&#x3D;E(x^2),-E^2(x)$这样在Shadow Map绘制完成后，对于其上的每一个点我们都能通过均值和方差得到该位置的一个深度的近似分布情况，从而可以根据当前片元的值，计算出其CDF。另外，VSM算法还引入了切比雪夫不等式（如下），只需要知道分布的期望和方差，就可以计算出x大于某个固定值的概率。$P(x&gt;t)≤σ^2&#x2F;(σ^2+(t-μ)^2)$切比雪夫不等式成立的条件是$t＞μ$，也就是当前的$d＞z_avg$。也就说如果Block内的平均深度小于当前Fragment的深度，就不能使用这种估计方法。 上面这种从统计学出发的估计解决了PCSS算法中的第三个步骤也就是PCF计算，但是PCSS算法中的第一个步骤Blocker Search仍然会耗费较长的时间，因此VSSM算法针对性地提出了估计方案。对于一个Block，第一个步骤Block Search的目标是估计其中遮挡物的平均深度，我们可以设Block中的像素总数为N，平均深度为$Z_avg$，深度小于当前值（遮挡物）的像素数为N1，平均深度为$Z_occ$，深度大于当前值（接收物体）的像素数为N2，平均深度为$Z_unocc$。则可以得到等式：$N_1&#x2F;N Z_unocc+N_2&#x2F;N Z_occ&#x3D;Z_avg$不难看出，N_1&#x2F;N就是非遮挡物所占比例，也就可以转化为P（X≥t）。则上式可以转化为：$P(x≥t) z_unocc+(1.0-P(x≥t)) z_occ&#x3D;z_avg$要计算遮挡物的平均深度，可以使用：$Z_occ&#x3D;(z_avg-P(x≥t) z_unocc)&#x2F;(1.0-P(x≥t))$而其中的$Z_avg$可以通过Mipmap得到，因此VSSM假设非遮挡物的深度都是t，从而可以计算出遮挡物的平均深度，这种假设的理论依据是一般的接收物体都是一个平面。而对于那些不是一个平面的阴影接收物体，以及切比雪夫不成立的情况，VSSM这篇论文则提出了分治的解决方案。对不满足$d&gt;z_avg$的Block，将其分割为更小的sub-Block，再进行阴影的绘制计算。具体的分治思路是，对于那些$z_avg＜d$的sub-Block，我们之前使用切比雪夫不等式的估计仍然是有效的，但是对于那些$z_avg≥d$的sub-Block，论文中选择了直接使用普通的PCSS算法进行阴影的绘制。其原因是论文认为分治之后的sub-Block较小，可以使用传统的PCF采样进行计算。论文使用类似四叉树的结构进行分治之后Block的管理和遍历。 六、MSM算法MSM算法全称为Moment Shadow Mapping。是Christoph Peters在2015年提出的一种阴影绘制方式。MSM实际上是在VSSM算法的基础上，对使用统计学思想逼近Depth Map的分布进行阴影绘制这种想法的延续。VSSM算法中，仅仅使用到了Depth的平均值和方差（也就是一阶矩和二阶矩）去估计深度的分布情况，这显然是可能产生偏差的，比如说对于下图中右边这种深度的分布，集中分布在几个固定的值附近，这样的情况使用切比雪夫不等式去估计就会出现比较大的误差。图源Games202而为了让VSM中对分布的描述更加精确，Christoph Peters提出了使用高阶矩来描述分布的方法。如下图，蓝色表示真正的深度分布CDF，如果使用VSSM算法则只能对CDF逼近到红色线条的程度，而如果使用前四阶矩则能逼近到绿色线段的程度，这样能使得我们对深度分布的估计更精确，对PCF进行近似计算也就更精确。图源【13】Christoph的测试表明，相对于VSM和ESM算法，MSM算法能提供更小的Shadow绘制误差（如下图）。图源【13】 七、总结在当前的渲染领域，由于时序上降噪技术的引入，实时的光线追踪技术成为了可能，因此目前传统的阴影绘制方法或许没有像之前那样应用这么广泛，但是在顺着这条发展路径学习的过程中，我对渲染的一些理解仍然能加深，并且获得新的启发。传统渲染方式虽然在一定程度上是某个时代算力限制的产物，但是其中蕴含的思考方式和优化方法，相信仍然能在未来的学习中给我带来灵感和启发。 参考资料： Tomas Akenine-Möller, Eric Haines, Naty Hoffman, Angelo Pesce, Michał Iwanicki, and Sébastien Hillaire,T. Real-Time Rendering 4rd Edition[M]. Natick, MA, USA: A. K. Peters, Ltd., 2020. Catmull, E., “A Subdivision Algorithm for Computer Display of Curved Surfaces,” PhD. thesis, Dept. of Computer Science, University of Utah, 1974. Lance Williams. 1978. Casting curved shadows on curved surfaces. SIGGRAPH Comput. Graph. 12, 3 (August 1978), 270–274. https://doi.org/10.1145/965139.807402 Y. Wang and S. Molnar. Second-depth shadow mapping. Technical Report TR94-019, Department of Computer Science, University of North Carolina - Chapel Hill, Dec. 1994. Fernando, S. Fernandez, K. Bala, and D. P. Greenberg. Adaptive shadow maps. In SIGGRAPH 2001 Conference Proceedings, pages 387–390, 2001. M. Stamminger and G. Drettakis. Perspective shadow maps. ACM Transactions on Graphics, 21(3):557–562, July 2002. William T. Reeves, David H. Salesin, and Robert L. Cook. 1987. Rendering antialiased shadows with depth maps. SIGGRAPH Comput. Graph. 21, 4 (July 1987), 283–291. https://doi.org/10.1145/37402.37435 https://developer.download.nvidia.com/shaderlibrary/docs/shadow_PCSS.pdf William Donnelly and Andrew Lauritzen. 2006. Variance shadow maps. In Proceedings of the 2006 symposium on Interactive 3D graphics and games (I3D ‘06). Association for Computing Machinery, New York, NY, USA, 161–165. https://doi.org/10.1145/1111411.1111440 https://developer.download.nvidia.com/SDK/10.5/opengl/src/cascaded_shadow_maps/doc/cascaded_shadow_maps.pdf Salvi, Marco, “Rendering Filtered Shadows with Exponential Shadow Maps,” in Wolfgang Engel, ed., ShaderX6, Charles River Media, pp. 257–274, 2008. Yang, B., Dong, Z., Feng, J., Seidel, H.-P. and Kautz, J. (2010), Variance Soft Shadow Mapping. Computer Graphics Forum, 29: 2127-2134. https://doi.org/10.1111/j.1467-8659.2010.01800.x Christoph Peters and Reinhard Klein. 2015. Moment shadow mapping. In Proceedings of the 19th Symposium on Interactive 3D Graphics and Games (i3D ‘15). Association for Computing Machinery, New York, NY, USA, 7–14. https://doi.org/10.1145/2699276.2699277 Lingqi Yan. Games202 Lecture3&amp;Lecture4. https://zhuanlan.zhihu.com/p/384446688 https://zhuanlan.zhihu.com/p/478472753","categories":[{"name":"Rendering","slug":"Rendering","permalink":"https://yaelcassini.github.io/categories/Rendering/"}],"tags":[{"name":"Rendering","slug":"Rendering","permalink":"https://yaelcassini.github.io/tags/Rendering/"},{"name":"Shadow","slug":"Shadow","permalink":"https://yaelcassini.github.io/tags/Shadow/"},{"name":"Shadow Map","slug":"Shadow-Map","permalink":"https://yaelcassini.github.io/tags/Shadow-Map/"},{"name":"PCF","slug":"PCF","permalink":"https://yaelcassini.github.io/tags/PCF/"},{"name":"PCSS","slug":"PCSS","permalink":"https://yaelcassini.github.io/tags/PCSS/"},{"name":"VSM","slug":"VSM","permalink":"https://yaelcassini.github.io/tags/VSM/"},{"name":"MSM","slug":"MSM","permalink":"https://yaelcassini.github.io/tags/MSM/"}]},{"title":"Rendering History","slug":"Rendering-History","date":"2023-03-28T12:37:39.000Z","updated":"2023-03-28T12:43:10.719Z","comments":true,"path":"2023/03/28/Rendering-History/","link":"","permalink":"https://yaelcassini.github.io/2023/03/28/Rendering-History/","excerpt":"","text":"真实感渲染光照模型 Illumination Model 灯光 阴影 基于物理的材质 Material 明暗 纹理 透明 一种标准的基本属性主要是Metallic-Roughness，另一种标准是Specular-Glossiness，前者对设计师更友好，后者侧重物理属性，保留了反射率F0。 光栅化 Rasterization光线追踪消隐技术全局光照（Global Illumination）后处理DLSS光照模型局部光照模型 Lambert漫反射模型 Gourand光照模型 Phong光照模型 Blinn-Phong光照模型 Cook-Torrance模型 全局光照模型 光线追踪 路径追踪 递归光线追踪 whitted-type 分布式光线追踪 distrubution 双向路径追踪 Bidirectional Path https://graphics.stanford.edu/courses/cs348b-03/papers/veach-chapter10.pdf Metropolis 光子映射 Photon Mapping 基于点的全局光照 辐射度算法 光子映射 Other TopicRay MarchingPercentage Closer Soft Shadows (PCSS)大事记&amp;原文引用1760 Johann Heinrich Lambert在其著作Photometria中提出Lambert模型。 Half-Lambert是Valve公司提出来的算法，为了解决Lambert公式在灰面太暗的问题。”Half Lambert” lighting is a technique first developed in the original Half-Life. 1967 Siggraph（Special Interest Group for Computer GRAPHICS，计算机图形图像特别兴趣小组）成立 光照模型：Wylie等人第一次在显示物体时加入了光照效果。该论文提出，物体表面上一点接收到的光强，与该点到光源距离的平方成反比，且与光照方向和表面发现的夹角有关。 Chris Wylie, Gordon Romney, David Evans, and Alan Erdahl. 1967. Half-tone perspective drawings by computer. In Proceedings of the November 14-16, 1967, fall joint computer conference (AFIPS ‘67 (Fall)). Association for Computing Machinery, New York, NY, USA, 49–58. https://doi.org/10.1145/1465611.1465619 1968 Arthur Appel 在研究隐藏面消除时提出了光线投射算法（Ray Casting），并首次给出了光线跟踪算法的描述。其具体思路是从每一个像素射出一条射线，然后找到最接近的物体挡住射线的路径，而视平面上每个像素的颜色取决于从可见光表面产生的亮度。 Arthur Appel. 1968. Some techniques for shading machine renderings of solids. In Proceedings of the April 30–May 2, 1968, spring joint computer conference (AFIPS ‘68 (Spring)). Association for Computing Machinery, New York, NY, USA, 37–45. https://doi.org/10.1145/1468075.1468082 1970 光照模型：Bouknight提出第一个光反射模型，指出物体表面朝向是确定物体表面上一点光强的主要因素，用Lambert漫反射定律计算物体表面上各多边形的光强，对光照射不到的地方，用环境光代替。 W. Jack Bouknight. 1970. A procedure for generation of three-dimensional half-toned computer graphics presentations. Commun. ACM 13, 9 (Sept. 1970), 527–536. https://doi.org/10.1145/362736.362739 1971 光照模型：Gourand提出的基于“漫反射模型与插值”思想的Gourand模型。对多面体模型，用漫反射模型计算多边形顶点的光亮度，再用增量法插值计算。 Gouraud, H. (1971). Continuous Shading of Curved Surfaces. IEEE Transactions on Computers, C-20, 623-629. https://ieeexplore.ieee.org/document/1671906 1974 Siggraph开始每年举办计算机图形学顶级年度会议。 Z-buffer算法 Catmull, E., “A Subdivision Algorithm for Com\u0002puter Display of Curved Surfaces,” PhD. thesis, Dept. of Computer Science, University of Utah, 1974. 1975 光照模型：Phong提出图形学中第一个有影响的简单光照明模型。模型虽然只是一个经验模型，但是其真实度已达到可以接受的程度。在Phong光照模型的基础之上，相继出现了Goud明暗处理和Phong明暗处理两个增量式光照模型。 Bui Tuong Phong. 1975. Illumination for computer generated pictures. Commun. ACM 18, 6 (June 1975), 311–317. https://doi.org/10.1145/360825.360839 1976 UV mapping James F. Blinn and Martin E. Newell. 1976. Texture and reflection in computer generated images. Commun. ACM 19, 10 (Oct. 1976), 542–547. https://doi.org/10.1145/360349.360353 用于消隐的数据结构 James H. Clark. 1976. Hierarchical geometric models for visible surface algorithms. Commun. ACM 19, 10 (Oct. 1976), 547–554. https://doi.org/10.1145/360349.360354 1977 光照模型：Blinn-Phong James F. Blinn. 1977. Models of light reflection for computer synthesized pictures. SIGGRAPH Comput. Graph. 11, 2 (Summer 1977), 192–198. https://doi.org/10.1145/965141.563893 Shadow Volume Crow, Franklin C., “Shadow Algorithms for Computer Graphics,” Computer Graphics (SIG\u0002GRAPH ’77 Proceedings), vol. 11, no. 2, pp. 242–248, July 1977. 1978 Shadow Map算法 Lance Williams. 1978. Casting curved shadows on curved surfaces. SIGGRAPH Comput. Graph. 12, 3 (August 1978), 270–274. https://doi.org/10.1145/965139.807402 Development： C. Hourcade and A. Nicolas. Algorithms for an\u0002tialiased cast shadows. Computers and Graphics, 9(3):259–265, 1985. Midpoint Shadow Map. Andrew Woo, VII.1 - THE SHADOW DEPTH MAP REVISITED, Editor(s): DAVID KIRK, Graphics Gems III (IBM Version), Morgan Kaufmann, 1992,Pages 338-342, https://doi.org/10.1016/B978-0-08-050755-2.50073-7. Mark Segal, Carl Korobkin, Rolf van Widenfelt, Jim Foran, and Paul Haeberli. 1992. Fast shadows and lighting effects using texture mapping. SIGGRAPH Comput. Graph. 26, 2 (July 1992), 249–252. https://doi.org/10.1145/142920.134071 Shenchang Eric Chen and Lance Williams. 1993. View interpolation for image synthesis. In Proceedings of the 20th annual conference on Computer graphics and interactive techniques (SIGGRAPH ‘93). Association for Computing Machinery, New York, NY, USA, 279–288. https://doi.org/10.1145/166117.166153 Y. Wang and S. Molnar. Second-depth shadow map\u0002ping. Technical Report TR94-019, Department of Com\u0002puter Science, University of North Carolina - Chapel Hill, Dec. 1994. . Fernando, S. Fernandez, K. Bala, and D. P. Green\u0002berg. Adaptive shadow maps. In SIGGRAPH 2001 Conference Proceedings, pages 387–390, 2001. M. Stamminger and G. Drettakis. Perspective shadow maps. ACM Transactions on Graphics, 21(3):557–562, July 2002. 感觉是消隐 Edwin Catmull. 1978. A hidden-surface algorithm with anti-aliasing. SIGGRAPH Comput. Graph. 12, 3 (August 1978), 6–11. https://doi.org/10.1145/965139.807360 太有名了先放在这里 Turner Whitted. 1978. A scan line algorithm for computer display of curved surfaces. SIGGRAPH Comput. Graph. 12, SI (August 1978), 8–13. https://doi.org/10.1145/988437.988440 1980 光照模型&amp;光线追踪：Whitted提出了Whitted模型，并第一次给出一般性光线跟踪算法的范例。该模型综合考虑了光的反射、折射透射、阴影等。此时的光线追踪才真正的变成一个强大的工具，其将光线投射算法扩展为递归算法（Recursive Ray Tracing）。 Turner Whitted. 1980. An improved illumination model for shaded display. Commun. ACM 23, 6 (June 1980), 343–349. https://doi.org/10.1145/358876.358882 八叉树？ Steven M. Rubin and Turner Whitted. 1980. A 3-dimensional representation for fast rendering of complex scenes. SIGGRAPH Comput. Graph. 14, 3 (July 1980), 110–116. https://doi.org/10.1145/965105.807479 1982 光照模型：Cook和Torrance为了克服Phong模型的缺点，提出了一个基于物理光学的表面反射模型—大名鼎鼎的Cook-Torrance微表面模型，使得模型中反射光的位置和分布与实际情况非常接近，因而用它绘制的图形具有很好的质感。 R. L. Cook and K. E. Torrance. 1982. A Reflectance Model for Computer Graphics. ACM Trans. Graph. 1, 1 (Jan. 1982), 7–24. https://doi.org/10.1145/357290.357293 体积散射 blinn 1983 光照模型：Hall和Greenbert在whitted基础上此进一步给出Hall光透射模型,考虑了漫透射和规则透射光。改进了whitted中投射高光效果，并再环境光中加入距离衰减因子，使之能够更好的模拟物体表面的透射特性。 1984 Cook于1984年引入蒙特卡洛方法（Monte Carlo method）到光线跟踪领域，将经典的光线跟踪方法扩展为分布式光线跟踪算法（Distributed Ray Tracing），又称为随机光线追踪（stochasticray tracing），可以模拟更多的效果，如金属光泽、软阴影、景深（ Depthof Field）、运动模糊等等。 Robert L. Cook, Thomas Porter, and Loren Carpenter. 1984. Distributed ray tracing. SIGGRAPH Comput. Graph. 18, 3 (July 1984), 137–145. https://doi.org/10.1145/964965.808590 Goral 1984年 辐射度算法 1986 光照模型&amp;光线追踪：Kajiya统一了以前所有的光照模型。Kajiya首先提出使类似于随机采样的蒙特卡罗（Monte Carlo）方法求解绘制方程的光线追踪算法（Raytracing）——通过对到达图像平面上的光线路径进行采样，然后估计它们对最终图像的贡献来生成图像。 James T. Kajiya. 1986. The rendering equation. SIGGRAPH Comput. Graph. 20, 4 (Aug. 1986), 143–150. https://doi.org/10.1145/15886.15902 Non-diffuse Radiosity David S. Immel, Michael F. Cohen, and Donald P. Greenberg. 1986. A radiosity method for non-diffuse environments. SIGGRAPH Comput. Graph. 20, 4 (Aug. 1986), 133–142. https://doi.org/10.1145/15886.15901 1987 PCF算法 William T. Reeves, David H. Salesin, and Robert L. Cook. 1987. Rendering antialiased shadows with depth maps. SIGGRAPH Comput. Graph. 21, 4 (July 1987), 283–291. https://doi.org/10.1145/37402.37435 1991 非漫射辐射度（Non-diffuse Radiosity） Françis X. Sillion, James R. Arvo, Stephen H. Westin, and Donald P. Greenberg. 1991. A global illumination solution for general reflectance distributions. SIGGRAPH Comput. Graph. 25, 4 (July 1991), 187–196. https://doi.org/10.1145/127719.122739 Hanrahan 1991年 分级辐射度算法（Hierarchical radiosity） 先放在这 Xiao D. He, Kenneth E. Torrance, François X. Sillion, and Donald P. Greenberg. 1991. A comprehensive physical model for light reflection. SIGGRAPH Comput. Graph. 25, 4 (July 1991), 175–186. https://doi.org/10.1145/127719.122738 1992 RenderMan规范，简称RISpec，是一个开放的API，由皮克斯开发，用于描述三维模型并把它转换成逼真的数字图像。RenderMan规范作为建模程序和渲染程序之间的通信协议（或称为接口），用于生成逼真的数字图像。 1993 不连续网格辐射度（Discontinuity meshing） Dani Lischinski, Filippo Tampieri, and Donald P. Greenberg. 1993. Combining hierarchical radiosity and discontinuity meshing. In Proceedings of the 20th annual conference on Computer graphics and interactive techniques (SIGGRAPH ‘93). Association for Computing Machinery, New York, NY, USA, 199–208. https://doi.org/10.1145/166117.166143 Lafortune and Willems 1993 年• Veach and Guibas 1994年 双向路径跟踪 1994 微表面&amp;Roughness相关 Michael Oren and Shree K. Nayar. 1994. Generalization of Lambert’s reflectance model. In Proceedings of the 21st annual conference on Computer graphics and interactive techniques (SIGGRAPH ‘94). Association for Computing Machinery, New York, NY, USA, 239–246. https://doi.org/10.1145/192161.192213 1995 Diffusion for light transport 1996 光子映射 Photon Mapping Jensen, Henrik Wann. “Global Illumination using Photon Maps.” Rendering Techniques (1996). 1997 Veach and Guibas 1997 马尔可夫链蒙特卡洛 Robust Monte Carlo Methods for Light Transport Simulation 光子映射 Photon Mapping Bruce Walter, Philip M. Hubbard, Peter Shirley, and Donald P. Greenberg. 1997. Global illumination using local linear density estimation. ACM Trans. Graph. 16, 3 (July 1997), 217–259. https://doi.org/10.1145/256157.256158 Light Transport Veach, Eric &amp; Guibas, Leonidas. (1970). Metropolis Light Transport. Computer Graphics (SIGGRAPH ‘97 Proceedings). 31. 10.1145&#x2F;258734.258775. Keller 1997年Virtual point lights (Instant Radiosity) 1998 Jensen and Christensen 1998年Volumetric photon mapping Bi-Directional Path Tracing Lafortune, Eric &amp; Willems, Yves. (1998). Bi-Directional Path Tracing. Proceedings of Third International Conference on Computational Graphics and Visualization Techniques (Compugraphics’. 93. 2000 Pauly 2000年 Metropolis in volumes 2001 次表面散射 Jensen H W, Marschner S R, Levoy M, et al. A practical model for subsurface light transport[C]&#x2F;&#x2F;Proceedings of the 28th annual conference on Computer graphics and interactive techniques. ACM, 2001: 511-518. 2002 Kelemen et al. 2002Primary sample space MCMC 2005 Walter 2005年 LightCuts Cline 2005年“Energy Redistribution” 和 非遍历 MCMC Fernando发表了Percentage-Closer Soft Shadows，称为“百分比渐近柔和阴影（PCSS）。 https://developer.download.nvidia.com/shaderlibrary/docs/shadow_PCSS.pdf RSM算法（Reflective Shadow Map） Carsten Dachsbacher and Marc Stamminger. 2005. Reflective shadow maps. In Proceedings of the 2005 symposium on Interactive 3D graphics and games (I3D ‘05). Association for Computing Machinery, New York, NY, USA, 203–231. https://doi.org/10.1145/1053427.1053460 2006 VSM算法（Variance shadow maps） William Donnelly and Andrew Lauritzen. 2006. Variance shadow maps. In Proceedings of the 2006 symposium on Interactive 3D graphics and games (I3D ‘06). Association for Computing Machinery, New York, NY, USA, 161–165. https://doi.org/10.1145/1111411.1111440 2007 Walter 2007 年 Microfacet transmission model CSM算法 https://developer.download.nvidia.com/SDK/10.5/opengl/src/cascaded_shadow_maps/doc/cascaded_shadow_maps.pdf 2008 Jarosz 2008年 光束辐射估计（Beam Radiance Estimate） 2010 Jakob 2010年Anisotropic volume media 2011 d’Eon and Irving 2011年Advanced diffusion models 2012 Jakob &amp;amp;amp; Marschner 2012年Manifold Exploration Disney Principled BRDF - MERL 100 BRDF 材质库 2014 Křivánek 2014年Unifying Points, Beams, and Paths 2015 Kettunen 2015 梯度域路径跟踪 Stochastic Screen-Space Reflections https://view.officeapps.live.com/op/view.aspx?src=https%3A%2F%2Fadvances.realtimerendering.com%2Fs2015%2FStochastic%2520Screen-Space%2520Reflections.pptx Moment Shadow Map Christoph Peters and Reinhard Klein. 2015. Moment shadow mapping. In Proceedings of the 19th Symposium on Interactive 3D Graphics and Games (i3D ‘15). Association for Computing Machinery, New York, NY, USA, 7–14. https://doi.org/10.1145/2699276.2699277 2018 微软提出了DirectX Ray Tracing（DXR）的API，提供了Ray Tracing Pipeline的雏形。 NVIDIA宣布了可加速硬件中光线追踪速度的新架构Turing，以及搭载实时光线追踪技术的RTX系列显卡。Nvidia推出了新一代的RTX显卡，提供了Ray Tracing硬件加速的能力。 第一款搭载RTX实时混合光线追踪技术的游戏《战地5（Battlefield V）》正式面世，基于EA的Frostbite引擎，带来了出色的混合光线追踪反射（Hybrid Ray-Traced Reflections）渲染表现。 Eric Heitz于2018年提出了一种结合了解析直接光照（analytic direct illumination）和随机阴影（stochastic shadows）的新方法[13]）。在paper中，他们提出了一种比率估计器（ratio estimator），该比率估计器可以将解析光照技术（analytic illumination techniques）与随机光线追踪阴影（stochastic raytraced shadows）正确组合。 Eric Heitz, Stephen Hill, and Morgan McGuire. 2018. Combining analytic direct illumination and stochastic shadows. In Proceedings of the ACM SIGGRAPH Symposium on Interactive 3D Graphics and Games (I3D ‘18). Association for Computing Machinery, New York, NY, USA, Article 2, 1–11. https://doi.org/10.1145/3190834.3190852 2019 SIGGRAPH2019的Ray Tracing专题报告展望了实时光线追踪的未来。其中，SEED团队分享了自己的混合渲染管线（上图），管线由一个接一个的阶段串联，而每个阶段采用最合适的技术来实现。 SIGGRAPH 2019, State-of-the-Art and Challenges in Game Ray Tracing 2020 Vulkan也推出了Ray Tracing规范，同DXR非常相似。 2021 2021年，UE5的视频又掀起了一波热潮，新一代的渲染引擎Lumen则是一套完整的光线追踪管线，分为Software和Hardware两种形式。 Nvidia推出 RayTracing Gens Ⅱ。 2022 AMD推出自己的Ray Tracing库——HIP。 Referencehttps://zhuanlan.zhihu.com/p/50165536https://zhuanlan.zhihu.com/p/49474631https://zhuanlan.zhihu.com/p/29418992","categories":[{"name":"Rendering","slug":"Rendering","permalink":"https://yaelcassini.github.io/categories/Rendering/"}],"tags":[{"name":"Rendering","slug":"Rendering","permalink":"https://yaelcassini.github.io/tags/Rendering/"},{"name":"RayTracing","slug":"RayTracing","permalink":"https://yaelcassini.github.io/tags/RayTracing/"},{"name":"PathTracing","slug":"PathTracing","permalink":"https://yaelcassini.github.io/tags/PathTracing/"},{"name":"Monte Carlo","slug":"Monte-Carlo","permalink":"https://yaelcassini.github.io/tags/Monte-Carlo/"}]},{"title":"PathTracing","slug":"PathTracing","date":"2023-03-24T06:32:57.000Z","updated":"2023-03-24T07:09:19.423Z","comments":true,"path":"2023/03/24/PathTracing/","link":"","permalink":"https://yaelcassini.github.io/2023/03/24/PathTracing/","excerpt":"","text":"Related Information: https://raytracing.github.io/books/RayTracingInOneWeekend.html https://raytracing.github.io/books/RayTracingTheNextWeek.html https://agraphicsguynotes.com/posts/sample_microfacet_brdf/ http://www.cim.mcgill.ca/~derek/ecse689_a3.html https://raytracing.github.io/books/RayTracingInOneWeekend.html#dielectrics https://en.wikipedia.org/wiki/M%C3%B6ller%E2%80%93Trumbore_intersection_algorithm https://math.stackexchange.com/questions/538458/how-to-sample-points-on-a-triangle-surface-in-3d https://computergraphics.stackexchange.com/questions/5152/progressive-path-tracing-with-explicit-light-sampling","categories":[{"name":"PathTracing","slug":"PathTracing","permalink":"https://yaelcassini.github.io/categories/PathTracing/"}],"tags":[{"name":"Rendering","slug":"Rendering","permalink":"https://yaelcassini.github.io/tags/Rendering/"},{"name":"RayTracing","slug":"RayTracing","permalink":"https://yaelcassini.github.io/tags/RayTracing/"},{"name":"PathTracing","slug":"PathTracing","permalink":"https://yaelcassini.github.io/tags/PathTracing/"},{"name":"Monte Carlo","slug":"Monte-Carlo","permalink":"https://yaelcassini.github.io/tags/Monte-Carlo/"}]},{"title":"Visibility","slug":"Visibility","date":"2023-02-17T06:10:50.000Z","updated":"2023-03-24T06:44:54.730Z","comments":true,"path":"2023/02/17/Visibility/","link":"","permalink":"https://yaelcassini.github.io/2023/02/17/Visibility/","excerpt":"","text":"任务目标：参与一个可微分渲染的项目，主要负责其中的渲染部分相关工作，在前期需要使用已有的Mesh和Texture数据生成网络所需要的输入数据。其中就包括Visibility，刚开始做的时候什么都不太懂，学习相关知识耽误了很多时间，故整理于此。 任务理解：经与导师沟通后，本项目要求的Visibility并不是从相机角度看过去的可视性，而是更像环境光照那种，设想有一个无限大的球面，在球面上通过遍历不同的经纬得到不同的光线方向，对于模型上面的每一个顶点，计算在球面上各个方向其是否可视（光线不被其他物体或者面片遮挡）。为了方便数据输入网络，导师还要求将这个可视数据通过球谐函数Spherical Harmonics计算得到在球谐函数空间的前9维系数，从而将每一个顶点在各个方向上是否可见的信息，转化为一个9维的向量，作为Mesh中顶点的附加属性。 具体实现：因为在计算Visibility中需要对整个球面进行光线方向的采样，并计算其在整个场景中是否与其他物体或者面片相交，因此其实可以转化为使用一个光线追踪的框架来帮助完成这个工作，在前期探索中，曾经试图使用Games202 Assignment2的Nori框架来完成这件事，但是后面与导师沟通后，导师建议我使用Mitsuba来完成该工作，原因主要有下：Mitsuba的使用场合较为广泛，相关的资料和实验室能够提供的帮助也较多；另外学习Mitsuba也对我之后在渲染方向的继续探索有帮助。 而对于投影到SH这一步，目前我在Giuhub上找到一个开源的项目： https://github.com/chalmersgit/SphericalHarmonics 初步决定在其基础上进行修改完成第二部分计算工作。这个项目初衷是针对Image Based Lighting的SH投影计算，其使用的IBL投影方式是Equirectangular Projection(ERP)。相关资料： https://blog.csdn.net/lin453701006/article/details/71173090 因此首先要把球面采样的代码修改到与该投影方式对应，得到一张这样的图像，再使用该项目计算SH。 具体实现中遇到的问题 从maya导出的mesh 在Maya中没有Transform 但是导入Blender有x轴上90度的旋转，而进入到Mitsuba时其在空间坐标系中的状态是Blender中去掉90旋转之后的状态，初步怀疑是Maya、Blender和Mitsuba三者的坐标系有些不同，但是目前还没有深入探索得到答案。 在进行球面采样的时候，需要为了防止边界出现问题，需要将每个像素点的坐标变换到像素点中心，即遍历xy时对其进行x+0.5 y+0.5的计算。 相关知识点Image Based Lighting分为三种不同的投影方式： Cube Map Dual Paraboloid Map Equirectangualr Map 相关资料 Spherical Harmonics：https://www.jianshu.com/p/a379b4c6d346","categories":[{"name":"Deep Face Project","slug":"Deep-Face-Project","permalink":"https://yaelcassini.github.io/categories/Deep-Face-Project/"}],"tags":[{"name":"Deep Learing","slug":"Deep-Learing","permalink":"https://yaelcassini.github.io/tags/Deep-Learing/"},{"name":"Artificial Intelligent","slug":"Artificial-Intelligent","permalink":"https://yaelcassini.github.io/tags/Artificial-Intelligent/"},{"name":"Spherical Harmonics","slug":"Spherical-Harmonics","permalink":"https://yaelcassini.github.io/tags/Spherical-Harmonics/"}]},{"title":"一些资源","slug":"一些资源","date":"2022-11-10T03:45:40.000Z","updated":"2023-05-11T07:30:17.577Z","comments":true,"path":"2022/11/10/一些资源/","link":"","permalink":"https://yaelcassini.github.io/2022/11/10/%E4%B8%80%E4%BA%9B%E8%B5%84%E6%BA%90/","excerpt":"","text":"常用Mesh：http://casual-effects.com/data/index.html shell转bat： https://daniel-sc.github.io/bash-shell-to-bat-converter/ Spherical Harmonics：https://www.jianshu.com/p/a379b4c6d346 https://github.com/blurgyy/cg-2020 Chrono是c++11的一个时间库，可以用它来做程序运行时间的记录。 https://www.cnblogs.com/jwk000/p/3560086.html git submodule 如何push 代码 cd your_submodule git checkout master git commit -a -m “commit message” git push cd .. git add your_submodule git commit -m “Update submodule” git submodule update –remote git pull –recurse-submodules Warp是一个可以迁移拓扑并投影贴图的软件 TinyXML2是一个可以解析XML格式文件的库 https://github.com/leethomason/tinyxml2 Maya里面的坐标系是Y轴朝上 Blender里面的坐标系是z轴朝上 都是右手坐标系 所以模型导入blender会自动沿着x轴旋转90度 PBRT: https://www.pbr-book.org/3ed-2018/contents https://github.com/BachiLi/lajolla_public https://github.com/462cmu https://github.com/wjakob/nori https://github.com/HW140701/Book-list-of-computational-geometry-and-computer-graphics https://blog.csdn.net/qq_21388689/article/details/117129404 https://zhuanlan.zhihu.com/p/553407062","categories":[{"name":"Others","slug":"Others","permalink":"https://yaelcassini.github.io/categories/Others/"}],"tags":[]},{"title":"Neural Rendering","slug":"Neural-Rendering","date":"2022-07-29T10:04:19.000Z","updated":"2023-05-08T06:47:06.703Z","comments":true,"path":"2022/07/29/Neural-Rendering/","link":"","permalink":"https://yaelcassini.github.io/2022/07/29/Neural-Rendering/","excerpt":"","text":"https://www.youtube.com/watch?v=otly9jcZ0Jg https://www.youtube.com/watch?v=aboFl5ozImM","categories":[{"name":"Neural Rendering","slug":"Neural-Rendering","permalink":"https://yaelcassini.github.io/categories/Neural-Rendering/"}],"tags":[{"name":"Neural Rendering","slug":"Neural-Rendering","permalink":"https://yaelcassini.github.io/tags/Neural-Rendering/"},{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"https://yaelcassini.github.io/tags/Artificial-Intelligence/"},{"name":"Rendering","slug":"Rendering","permalink":"https://yaelcassini.github.io/tags/Rendering/"}]},{"title":"Deep Face 初期实践","slug":"Deep-Face-初期实践","date":"2022-07-25T10:08:05.000Z","updated":"2023-03-24T06:41:24.864Z","comments":true,"path":"2022/07/25/Deep-Face-初期实践/","link":"","permalink":"https://yaelcassini.github.io/2022/07/25/Deep-Face-%E5%88%9D%E6%9C%9F%E5%AE%9E%E8%B7%B5/","excerpt":"","text":"解决CondaHTTPError:HTTP 000：https://blog.csdn.net/weixin_51484460/article/details/122179000 批处理文件格式的Deep Face Lab及教程：https://blog.csdn.net/yihuaixu/article/details/120738257 https://blog.csdn.net/u010554381/article/details/100131811 Deep Face Lab参数说明：https://blog.csdn.net/qq_28941587/article/details/113790231 数据集：https://github.com/ondyari/FaceForensics/ http://kaldir.vc.in.tum.de/faceforensics_benchmark/ 下载：http://kaldir.vc.in.tum.de/faceforensics_download_v1.py","categories":[{"name":"Deep Face Project","slug":"Deep-Face-Project","permalink":"https://yaelcassini.github.io/categories/Deep-Face-Project/"}],"tags":[{"name":"Deep Learing","slug":"Deep-Learing","permalink":"https://yaelcassini.github.io/tags/Deep-Learing/"},{"name":"GAN","slug":"GAN","permalink":"https://yaelcassini.github.io/tags/GAN/"},{"name":"Deep Fake","slug":"Deep-Fake","permalink":"https://yaelcassini.github.io/tags/Deep-Fake/"},{"name":"Artificial Intelligent","slug":"Artificial-Intelligent","permalink":"https://yaelcassini.github.io/tags/Artificial-Intelligent/"}]},{"title":"TA-learning-Note01","slug":"TA-learning","date":"2022-07-14T07:28:04.000Z","updated":"2023-03-24T06:44:02.343Z","comments":true,"path":"2022/07/14/TA-learning/","link":"","permalink":"https://yaelcassini.github.io/2022/07/14/TA-learning/","excerpt":"一些零碎的知识","text":"一些零碎的知识 Key Words: 重要性采样 Image based lighting Spherical Harmonics Blender渲染中的两种重要性采样 Indirect Light Direct Light 如何制作雨中布料渲染效果 https://www.youtube.com/watch?v=w3lwfMKkEwI https://youngjoongkwon.wordpress.com/2017/11/30/real-time-animation-of-rain-wet-cloth-material-2016/ https://cdn.jsdelivr.net/gh/YaelCassini/Papers/TA/Wet%20cloth%20animation%20with%20vertex%20based%20adhesion%20force%20model.pdf https://cdn.jsdelivr.net/gh/YaelCassini/Papers/TA/Real-time%20Animation%20of%20Rain-wet%20Cloth%20Material.pdf Normal Mapping相关 Triplanar Mapping https://blog.selfshadow.com/publications/blending-in-detail/#mjx-eqn-eqquat 渲染中的坐标变换： https://blog.csdn.net/sinat_34870723/article/details/113925012 https://zhuanlan.zhihu.com/p/115395322","categories":[{"name":"TA-learning","slug":"TA-learning","permalink":"https://yaelcassini.github.io/categories/TA-learning/"}],"tags":[{"name":"Rendering","slug":"Rendering","permalink":"https://yaelcassini.github.io/tags/Rendering/"},{"name":"Notes","slug":"Notes","permalink":"https://yaelcassini.github.io/tags/Notes/"},{"name":"Technical Artist","slug":"Technical-Artist","permalink":"https://yaelcassini.github.io/tags/Technical-Artist/"}]},{"title":"Deep Fake 初期调研","slug":"Deep Fake 初期调研","date":"2022-07-04T02:27:13.000Z","updated":"2023-03-24T06:41:29.055Z","comments":true,"path":"2022/07/04/Deep Fake 初期调研/","link":"","permalink":"https://yaelcassini.github.io/2022/07/04/Deep%20Fake%20%E5%88%9D%E6%9C%9F%E8%B0%83%E7%A0%94/","excerpt":"","text":"GAN论文总结：https://mp.weixin.qq.com/s?__biz=MzU5MTgzNzE0MA==&amp;mid=100002834&amp;idx=1&amp;sn=7d1c740509ba6b65f630f6db6bd51d7b&amp;chksm=7e29aea9495e27bfa746902298298c921320c3cb13a0619824528c3d1803f533779b7a93a242#rd 3DMM：https://zhuanlan.zhihu.com/p/161828142 深度学习入门：https://zhuanlan.zhihu.com/p/372029815 Keywords: 全连接神经网络、CNN、RNN、LTSM、GAN CNN：https://zhuanlan.zhihu.com/p/38160157","categories":[{"name":"Deep Face Project","slug":"Deep-Face-Project","permalink":"https://yaelcassini.github.io/categories/Deep-Face-Project/"}],"tags":[{"name":"Deep Learing","slug":"Deep-Learing","permalink":"https://yaelcassini.github.io/tags/Deep-Learing/"},{"name":"GAN","slug":"GAN","permalink":"https://yaelcassini.github.io/tags/GAN/"},{"name":"Deep Fake","slug":"Deep-Fake","permalink":"https://yaelcassini.github.io/tags/Deep-Fake/"},{"name":"Artificial Intelligent","slug":"Artificial-Intelligent","permalink":"https://yaelcassini.github.io/tags/Artificial-Intelligent/"}]},{"title":"Subsurface Scattering","slug":"Subsurface-Scattering","date":"2022-06-15T07:47:18.000Z","updated":"2023-03-24T06:42:30.303Z","comments":true,"path":"2022/06/15/Subsurface-Scattering/","link":"","permalink":"https://yaelcassini.github.io/2022/06/15/Subsurface-Scattering/","excerpt":"","text":"蒙特卡洛积分： https://zhuanlan.zhihu.com/p/146144853 https://www.cnblogs.com/time-flow1024/p/10094293.html#mjx-eqn-eq%3AFN https://zhuanlan.zhihu.com/p/365624460 我悟了！ Blender Random Walk SSS： https://www.blendernation.com/2018/02/10/new-random-walk-method-sss-cycles/ https://www.youtube.com/watch?v=fSShkXJtWjU Blender Subsurface： https://docs.blender.org/manual/en/latest/render/shader_nodes/shader/sss.html BRDF、BTDF、BSDF、BSSDF： https://zhuanlan.zhihu.com/p/27014447 次表面散射： 毛星云总结Gems 3：https://zhuanlan.zhihu.com/p/42433792 https://zhuanlan.zhihu.com/p/21247702?refer=graphics A Practical Model for Subsurface Light Transport 引入偶极子：2001. A Practical Model for Subsurface Light Transport 引入多极子：2005. Light Diffusion in Multi-Layered Translucent Materials 基于纹理空间、基于屏幕空间 基于纹理空间：Advanced Skin Rendering——Nvidia：https://developer.download.nvidia.com/presentations/2007/gdc/Advanced_Skin.pdf 可分离的次表面散射：Separable Subsurface Scattering Arnold 提供的次表面散射说明：https://docs.arnoldrenderer.com/display/A5AFMUG/Subsurface Random Walk算法：https://blog.csdn.net/Da___Vinci/article/details/82958297 一维随机游走：https://blog.csdn.net/qq_43186282/article/details/114585885 http://www.iryoku.com/ http://www.iryoku.com/separable-sss/","categories":[{"name":"Subsurface Scattering","slug":"Subsurface-Scattering","permalink":"https://yaelcassini.github.io/categories/Subsurface-Scattering/"}],"tags":[{"name":"Rendering","slug":"Rendering","permalink":"https://yaelcassini.github.io/tags/Rendering/"},{"name":"Monte Carlo","slug":"Monte-Carlo","permalink":"https://yaelcassini.github.io/tags/Monte-Carlo/"}]},{"title":"Volantis主题配置","slug":"Volantis主题配置","date":"2022-06-15T06:28:46.000Z","updated":"2022-06-15T07:18:04.110Z","comments":true,"path":"2022/06/15/Volantis主题配置/","link":"","permalink":"https://yaelcassini.github.io/2022/06/15/Volantis%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/","excerpt":"Volantis主题配制教程转自：https://volantis.js.org/v5/theme-settings/","text":"Volantis主题配制教程转自：https://volantis.js.org/v5/theme-settings/ 创建主题配置文件主题目录下的 _config.yml 文件通常负责主题相关配置，我们强烈建议您使用代替的主题配置文件以防止自己的配置丢失。那么如何使用代替主题配置文件呢？ 第 1&#x2F;2 步：创建配置文件 在博客根目录的 _config.yml 文件旁边新建一个文件： _config.volantis.yml ，这个文件中的配置信息优先级高于主题文件夹中的配置文件。 第 2&#x2F;2 步：覆盖自定义配置 当您需要修改某项内容时，例如导航栏菜单，那么您需要在主题配置文件中找到相关内容，复制进自己创建的配置文件中：blog/_config.volantis.yml12345678910navbar: visiable: auto # always, auto logo: # choose [img] or [icon + title] img: volantis-static/media/org.volantis/blog/Logo-NavBar@3x.png # https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/Logo-NavBar@3x.png icon: title: menu: - name: 博客 icon: fa-solid fa-rss url: /小提示使用「npm i hexo-theme-volantis」方式安装的主题，主题配置文件在「blog/node_modules/hexo-theme-volantis/_config.yml」使用传统方式安装的主题，主题配置文件在「blog/themes/volantis/_config.yml」 自定义主题外观最大布局宽度blog/_config.volantis.yml123custom_css: ... max_width: 1080px # Sum of body width and sidebar width 网页所呈现的内容的最大宽度，即 body 和 sidebar 的宽度之和。 抗锯齿blog/_config.volantis.yml123custom_css: ... font_smoothing: true # font-smoothing for webkit 自定义光标样式blog/_config.volantis.yml1234567891011custom_css: ... cursor: enable: true text: volantis-static/media/cursor/text.png # https://cdn.jsdelivr.net/gh/inkss/common@1/cursor/text.png pointer: volantis-static/media/cursor/pointer.png # https://cdn.jsdelivr.net/gh/inkss/common@1/cursor/pointer.png default: volantis-static/media/cursor/left_ptr.png # https://cdn.jsdelivr.net/gh/inkss/common@1/cursor/left_ptr.png not-allowed: volantis-static/media/cursor/circle.png # https://cdn.jsdelivr.net/gh/inkss/common@1/cursor/circle.png zoom-out: volantis-static/media/cursor/zoom-out.png # https://cdn.jsdelivr.net/gh/inkss/common@1/cursor/zoom-out.png zoom-in: volantis-static/media/cursor/zoom-in.png # https://cdn.jsdelivr.net/gh/inkss/common@1/cursor/zoom-in.png grab: volantis-static/media/cursor/openhand.png # https://cdn.jsdelivr.net/gh/inkss/common@1/cursor/openhand.png 导航栏样式您可以设置导航栏的高度以及视觉特效，视觉特效目前可选的有： shadow：卡片阴影。 floatable：当鼠标移动到容器内时，呈现出浮起来的效果。 blur：背景模糊效果（毛玻璃），当浏览器不支持时显示为不透明。 blog/_config.volantis.yml123456custom_css: ... navbar: height: 64px width: auto # auto, max effect: [shadow, blur] # [shadow, floatable, blur] 滚动条样式blog/_config.volantis.yml1234567custom_css: ... scrollbar: size: 4px border: 2px color: &#x27;#2196f3&#x27; hover: &#x27;#ff5722&#x27; 侧边栏样式视觉特效参数同上，值得注意的是：卡片的 floatable 效果和 blur 效果相冲突。 blog/_config.volantis.yml1234custom_css: ... sidebar: effect: [shadow] # [shadow, floatable, blur] 正文区域样式视觉特效参数同上，值得注意的是：卡片的 floatable 效果和 blur 效果相冲突。您可以在 language: true 这里设置代码块显示语言名称。text_align 可以设置 h1&#x2F;h2&#x2F;h3&#x2F;h4&#x2F;p 的文字对齐方向。 blog/_config.volantis.yml12345678910111213custom_css: ... body: effect: [shadow] # [shadow, floatable, blur] highlight: language: true # show language of codeblock copy_btn: true text_align: # left, right, justify, center h1: left h2: left h3: left h4: left p: justify 布局间距您可以设置几种标题的布局间距 h2&#x2F;h3&#x2F;h4、段落间距 line、区块内部的段落间距 inline。 blog/_config.volantis.yml12345678custom_css: ... gap: h2: 48px # Spacing above H2 (only px unit) h3: 24px # Spacing above H3 (only px unit) h4: 16px # Spacing above H4 (only px unit) p: 1em # Paragraph spacing between paragraphs line_height: 1.6 # normal, 1.5, 1.75, 2 ... 自定义字体您可以自定义正文和代码字体。 blog/_config.volantis.yml123456789101112131415161718192021custom_css: ... fontfamily: logofont: fontfamily: &#x27;&quot;Varela Round&quot;, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, Helvetica, Arial&#x27; name: &#x27;Varela Round&#x27; url: volantis-static/media/fonts/VarelaRound/VarelaRound-Regular.ttf # https://cdn.jsdelivr.net/gh/volantis-x/cdn-fonts/VarelaRound/VarelaRound-Regular.ttf weight: normal style: normal bodyfont: fontfamily: &#x27;UbuntuMono, &quot;Varela Round&quot;, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, Helvetica, Arial&#x27; name: &#x27;UbuntuMono&#x27; url: volantis-static/media/fonts/UbuntuMono/UbuntuMono-Regular.ttf # https://cdn.jsdelivr.net/gh/volantis-x/cdn-fonts/UbuntuMono/UbuntuMono-Regular.ttf weight: normal style: normal codefont: fontfamily: &#x27;Menlo, UbuntuMono, Monaco&#x27; # name: &#x27;Monaco&#x27; # url: volantis-static/media/fonts/Monaco/Monaco.ttf # https://cdn.jsdelivr.net/gh/volantis-x/cdn-fonts/Monaco/Monaco.ttf # weight: normal # style: normal 自定义颜色多彩配色方案 blog/_config.volantis.yml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091color_scheme: # ------------ # 通用颜色 common: # 主题色 theme: &#x27;#44D7B6&#x27; # 链接色 link: &#x27;#2196f3&#x27; # 按钮色 button: &#x27;#44D7B6&#x27; # 鼠标放到交互元素上时的色 hover: &#x27;#ff5722&#x27; # 主题色块内部的文字颜色 inner: &#x27;#fff&#x27; # 选中区域文字的背景颜色 selection: &#x27;alpha(#2196f3, 0.2)&#x27; # ------------ # 亮色主题（默认） light: # 网站背景色 site_bg: &#x27;#f4f4f4&#x27; # 网站背景上的文字 site_inner: &#x27;#fff&#x27; # 网站页脚文字 site_footer: &#x27;#666&#x27; # 卡片背景色 card: &#x27;#fff&#x27; # 卡片上的普通文字 text: &#x27;#444&#x27; # 区块和代码块背景色 block: &#x27;#f6f6f6&#x27; # 代码块高亮时的背景色 codeblock: &#x27;#FFF7EA&#x27; # 行内代码颜色 inlinecode: &#x27;#D56D28&#x27; # 文章部分 h1: &#x27;#444&#x27; h2: &#x27;#444&#x27; h3: &#x27;#444&#x27; h4: &#x27;#444&#x27; h5: &#x27;#444&#x27; h6: &#x27;#444&#x27; p: &#x27;#444&#x27; # 列表文字 list: &#x27;#666&#x27; # 列表 hover 时的文字 list_hl: &#x27;mix($color-theme, #000, 80)&#x27; # 辅助性文字 meta: &#x27;#888&#x27; # ------------ # 暗色主题 dark: # 网站背景色 site_bg: &#x27;#222&#x27; # 网站背景上的文字 site_inner: &#x27;#eee&#x27; # 网站页脚文字 site_footer: &#x27;#aaa&#x27; # 卡片背景色 card: &#x27;#444&#x27; # 卡片上的普通文字 text: &#x27;#eee&#x27; # 区块和代码块背景色 block: &#x27;#3a3a3a&#x27; # 代码块高亮时的背景色 codeblock: &#x27;#343a3c&#x27; # 行内代码颜色 inlinecode: &#x27;#D56D28&#x27; # 文章部分 h1: &#x27;#eee&#x27; h2: &#x27;#eee&#x27; h3: &#x27;#ddd&#x27; h4: &#x27;#ddd&#x27; h5: &#x27;#ddd&#x27; h6: &#x27;#ddd&#x27; p: &#x27;#bbb&#x27; # 列表文字 list: &#x27;#aaa&#x27; # 列表 hover 时的文字 list_hl: &#x27;mix($color-theme, #fff, 80)&#x27; # 辅助性文字 meta: &#x27;#888&#x27; # 夜间图片亮度 brightness: 70% 自定义右键菜单自定义右键菜单自 5.0.0-rc.8 版本进行了全新重构，与历史版本相比，重构版右键菜单拥有更灵活的配置。 由于新版右键菜单配置较为复杂，原版菜单暂时性保留，在配置文件上新版右键以 rightmenus 命名。 为了方面称呼，以新版右键代指重构版右键菜单，老版右键代指历史版本右键菜单。 差异对比新旧两版右键菜单的差异如下： 对比项 老版右键 新版右键 自定义菜单项 只支持新增链接型菜单 同时支持事件型和链接型菜单 菜单项显示与顺序调整 部分支持 完全支持 内置菜单自定义调整 部分支持 完全支持修改文字描述、图标显示、功能实现等内容 自定义响应事件处理 不支持 支持自行添加 复制图片至剪切板 仅支持 PNG 格式图片 任意格式的图片 全局音乐控制 支持 支持 新版右键菜单新版右键在菜单项上根据配置文件自行生成前端代码，所以统一了一个共用的菜单对象： 1&#123;id: &#x27;&#x27;, name: &#x27;&#x27;, icon: &#x27;&#x27;, link: &#x27;&#x27;, event: &#x27;&#x27;, group: &#x27;&#x27;&#125; 同时为了响应不同状态下的右键行为，提出了内置组 （defaultGroup）的概念，相应的对于右键默认提供的功能实现则定义为内置实现（defaultEvent）。 1234&#123; defaultEvent: [&#x27;copyText&#x27;, &#x27;copyLink&#x27;, &#x27;copyPaste&#x27;, &#x27;copyAll&#x27;, &#x27;copyCut&#x27;, &#x27;copyImg&#x27;, &#x27;printMode&#x27;, &#x27;readMode&#x27;], defaultGroup: [&#x27;navigation&#x27;, &#x27;inputBox&#x27;, &#x27;seletctText&#x27;, &#x27;elementCheck&#x27;, &#x27;elementImage&#x27;, &#x27;articlePage&#x27;]&#125; 具体来说，内置组对应右键行为，例如 inputBox 代表在输入框下右键行为；内置实现对应自定义右键默认提供的功能实现，例如 readMode 代表了阅读模式。 参数解释plugins/menus 类的组内数据支持对象（单个菜单）或数组（一系列菜单）12345678910rightmenus: order: menus.groupName plugins: defaultGroupItem menus: groupName: - &#123;menu&#125; - &#123;menu&#125; groupName1: &#123;menu&#125; 右键菜单加载菜单的具体加载由 order 控制，可供使用的内容为：plugins.[组名], menus.[组名], hr, music 这四大类。 右键菜单排序菜单的排序由 order 字段的先后顺序和组内菜单项的先后顺序决定。 右键菜单类菜单项共分为两大类：plugins 和 menus，前者放置内置组及内置菜单，允许添加&#x2F;修改组内菜单；后者为用户自建菜单类，允许添加&#x2F;修改组及组内菜单。一般意义上 plugins 类的组为动态组，根据实际的右键状态进行显示；menus 类中内容由用户添加，菜单项默认显示。 右键菜单项菜单项共六个字段：id, name, icon, link, event, group，具体作用如下： id: 唯一值 name: 用于菜单名称显示 icon: 用于菜单图标显示 link: 跳转链接 event: 事件，当输入内容不为内置事件时，作 JavaScript 代码执行 group: 菜单项所处分组名称 note link&#x2F;event 二选一，同时出现时仅处理 link。 内置功能内置组 组名 描述 备注 navigation 导航组件，横向排列，共用一行，仅显示图标 原则上支持的数量不限 inputBox 文本输入框相关组件 生效于 input&#x2F;textarea seletctText 文本选中类组件 生效于右键选中文本，text 为选中的文本 elementCheck 链接判断组件 生效于链接处的右键行为，link 为链接地址 elementImage 图片判断类组件 生效于图片类的右键行为，link 为链接地址 articlePage 文章页面组件 生效于 post.article 页面 note 除 navigation 外的内置组，在显示时会隐藏含 link 属性的菜单项。 内置实现 事件名 描述 备注 copyText 复制文本 复制选中文本 copyLink 复制链接地址 复制 a 或 image 下的链接至剪切板 copyPaste 粘贴文本 需要用户批准相应权限，仅支持粘贴文本至输入框（暂不支持粘贴图片） copyAll 全选文本 选中输入框内的文本内容 copyCut 剪切文本 剪切输入框中选中的文本内容 copyImg 复制图片 支持 Chrome 浏览器，复制图片资源至剪切板 printMode 打印页面 一个调制过样式的打印功能 readMode 阅读模式 一个简单的阅读模式功能 默认设置iconPrefixFontawesome 图标前缀，音乐类组件使用，参考内容：fa-solid, fa-regular, fa-light, fa-thin, fa-duotone, fa-brands。 articleShowLink在 articlePage 组显示时（文章页）时依旧显示含 link 属性的菜单项。 musicAlwaysShow当设定全局音乐播放器时，是否一直显示音乐控制菜单。false：仅当音乐播放时启用。 corsAnywhere适用于复制图片文件的场景，当图片源未设置 Access-Control-Allow-Origin 时，图片复制由于 CORS 问题失败。 你可以自行部署相应项目解决该问题，详见：Rob–W&#x2F;cors-anywhere 或者 Zibri&#x2F;cloudflare-cors-anywhere。 回调方法volantis.rightmenu.handle 在右键菜单打开时执行。 volantis.rightmenu.handle(callBack[,”callBackName”, “setRequestAnimationFrame &#x3D; true”])。 此外，你还可以在 volantis.mouseEvent 处获得 MouseEvent 信息。 配置文件 blog/_config.volantis.yml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394### 自定义右键 新rightmenus: enable: true # 右键菜单项及加载顺序 # 内容示例：plugins.[组名], menus.[组名], hr(分割线，推荐去线留白), music(音乐控制器) order: - plugins.navigation - hr - plugins.inputBox - plugins.seletctText - plugins.elementCheck - plugins.elementImage - menus.link - hr - menus.darkMode - plugins.articlePage - music ############################ # - &#123;id: &#x27;&#x27;, name: &#x27;&#x27;, icon: &#x27;&#x27;, link: &#x27;&#x27;, event: &#x27;&#x27;, group: &#x27;&#x27;&#125; # id: 唯一值 # name: 用于菜单名称显示 # icon: 用于菜单图标显示 # link: 跳转链接 # event: 事件，当输入内容不为内置事件时，作 JavaScript 代码执行 # group: 菜单项所处分组名称 # 注： # 1. link/event 二选一，同时出现时仅处理 link # 2. 内置事件列表： copyText, copyLink, copyPaste, copyAll, copyCut, copyImg, printMode, readMode # 3. 内置组列表：navigation, inputBox, seletctText, elementCheck, elementImage, articlePage # 4. plugins 列允许自定义组内项目 # 5. menus 列允许自定义组及其内容 # 6. 除 navigation 外的内置组，在显示时会隐藏含 link 属性的菜单项 ########################### # 基础项设置 options: # 图标前缀 fa-solid, fa-regular, fa-light, fa-thin, fa-duotone, fa-brands iconPrefix: fa-solid # 例外，在 articlePage 组显示时（文章页）时依旧显示含 link 属性的菜单项 articleShowLink: false # 当设定全局音乐播放器时，是否一直显示音乐控制菜单。false：仅当音乐播放时启用 musicAlwaysShow: false # 适用于复制图片文件的场景，当图片源未设置 Access-Control-Allow-Origin 时，图片复制由于 CORS 问题失败 # 你可以自行部署相应项目解决该问题，详见：https://github.com/Rob--W/cors-anywhere 或者 https://github.com/Zibri/cloudflare-cors-anywhere corsAnywhere: # 右键内置组，预置实现 plugins: # 导航组件 # 横向排列，共用一行，仅显示图标 (原则上支持的数量不限) navigation: - &#123;id: &#x27;left&#x27;, name: &#x27;转到上一页&#x27;, icon: &#x27;fa-solid fa-arrow-left&#x27;, event: &#x27;history.back()&#x27;, group: &#x27;navigation&#x27;&#125; - &#123;id: &#x27;right&#x27;, name: &#x27;转到下一页&#x27;, icon: &#x27;fa-solid fa-arrow-right&#x27;, event: &#x27;history.forward()&#x27;, group: &#x27;navigation&#x27;&#125; - &#123;id: &#x27;redo&#x27;, name: &#x27;刷新当前页面&#x27;, icon: &#x27;fa-solid fa-redo&#x27;, event: &#x27;window.location.reload()&#x27;, group: &#x27;navigation&#x27;&#125; - &#123;id: &#x27;up&#x27;, name: &#x27;回到顶部&#x27;, icon: &#x27;fa-solid fa-arrow-up&#x27;, event: &#x27;VolantisApp.scrolltoElement(volantis.dom.bodyAnchor)&#x27;, group: &#x27;navigation&#x27;&#125; #- &#123;id: &#x27;home&#x27;, name: &#x27;回到首页&#x27;, icon: &#x27;fa-solid fa-home&#x27;, link: &#x27;/&#x27;, group: &#x27;navigation&#x27;&#125; # 文本输入框相关组件 # 生效于 input/textarea，粘贴、剪切、全选 inputBox: - &#123;id: &#x27;copyPaste&#x27;, name: &#x27;粘贴文本&#x27;, icon: &#x27;fa-solid fa-paste&#x27;, event: &#x27;copyPaste&#x27;, group: &#x27;inputBox&#x27;&#125; - &#123;id: &#x27;copyAll&#x27;, name: &#x27;全选文本&#x27;, icon: &#x27;fa-solid fa-object-ungroup&#x27;, event: &#x27;copyAll&#x27;, group: &#x27;inputBox&#x27;&#125; - &#123;id: &#x27;copyCut&#x27;, name: &#x27;剪切文本&#x27;, icon: &#x27;fa-solid fa-cut&#x27;, event: &#x27;copyCut&#x27;, group: &#x27;inputBox&#x27;&#125; # 文本选中类组件 # 生效于右键选中文本，__text__ 为选中的文本。 seletctText: - &#123;id: &#x27;copyText&#x27;, name: &#x27;复制文本&#x27;, icon: &#x27;fa-solid fa-copy&#x27;, event: &#x27;copyText&#x27;, group: &#x27;seletctText&#x27;&#125; - &#123;id: &#x27;searchWord&#x27;, name: &#x27;站内搜索&#x27;, icon: &#x27;fa-solid fa-search&#x27;, event: &#x27;OpenSearch(__text__)&#x27;, group: &#x27;seletctText&#x27;&#125; - &#123;id: &#x27;bingSearch&#x27;, name: &#x27;必应搜索&#x27;, icon: &#x27;fa-solid fa-search&#x27;, event: &#x27;window.open(`https://cn.bing.com/search?q=$&#123;__text__&#125;`)&#x27;, group: &#x27;seletctText&#x27;&#125; #- &#123;id: &#x27;googleSearch&#x27;, name: &#x27;谷歌搜索&#x27;, icon: &#x27;fa-solid fa-search&#x27;, event: &#x27;window.open(`https://www.google.com/search?q=$&#123;__text__&#125;`)&#x27;, group: &#x27;seletctText&#x27;&#125; # 链接判断组件 # 生效于链接处的右键行为，__link__ 为链接地址 elementCheck: - &#123;id: &#x27;openTab&#x27;, name: &#x27;新标签页打开&#x27;, icon: &#x27;fa-solid fa-external-link-square-alt&#x27;, event: &#x27;window.open(__link__)&#x27;, group: &#x27;elementCheck&#x27;&#125; - &#123;id: &#x27;copyLink&#x27;, name: &#x27;复制链接地址&#x27;, icon: &#x27;fa-solid fa-link&#x27;, event: &#x27;copyLink&#x27;, group: &#x27;elementCheck&#x27;&#125; # 图片判断类组件 # 生效于图片类的右键行为，__link__ 为链接地址 elementImage: - &#123;id: &#x27;copyImg&#x27;, name: &#x27;复制图片&#x27;, icon: &#x27;fa-solid fa-image&#x27;, event: &#x27;copyImg&#x27;, group: &#x27;elementImage&#x27;&#125; - &#123;id: &#x27;googleImg&#x27;, name: &#x27;谷歌识图&#x27;, icon: &#x27;fa-solid fa-images&#x27;, event: &#x27;window.open(`https://www.google.com.hk/searchbyimage?image_url=$&#123;__link__&#125;`)&#x27;, group: &#x27;elementImage&#x27;&#125; # 文章页面组件 # 生效于 post.article 页面 articlePage: - &#123;id: &#x27;printMode&#x27;, name: &#x27;打印页面&#x27;, icon: &#x27;fa-solid fa-print&#x27;, event: &#x27;printMode&#x27;, group: &#x27;articlePage&#x27;&#125; - &#123;id: &#x27;readMode&#x27;, name: &#x27;阅读模式&#x27;, icon: &#x27;fa-solid fa-book-open&#x27;, event: &#x27;readMode&#x27;, group: &#x27;articlePage&#x27;&#125; # 右键自定义菜单区域 menus: link: - &#123;id: &#x27;help&#x27;, name: &#x27;常见问题&#x27;, icon: &#x27;fa-solid fa-question&#x27;, link: &#x27;https://volantis.js.org/faqs/&#x27;, group: &#x27;link&#x27;&#125; - &#123;id: &#x27;examples&#x27;, name: &#x27;示例博客&#x27;, icon: &#x27;fa-solid fa-rss&#x27;, link: &#x27;https://volantis.js.org/examples/&#x27;, group: &#x27;link&#x27;&#125; - &#123;id: &#x27;contributors&#x27;, name: &#x27;加入社区&#x27;, icon: &#x27;fa-solid fa-fan&#x27;, link: &#x27;https://volantis.js.org/contributors/&#x27;, group: &#x27;link&#x27;&#125; - hr - &#123;id: &#x27;source_docs&#x27;, name: &#x27;本站源码&#x27;, icon: &#x27;fa-solid fa-code-branch&#x27;, link: &#x27;https://github.com/volantis-x/volantis-docs/&#x27;, group: &#x27;link&#x27;&#125; - &#123;id: &#x27;source_theme&#x27;, name: &#x27;主题源码&#x27;, icon: &#x27;fa-solid fa-code-branch&#x27;, link: &#x27;https://github.com/volantis-x/hexo-theme-volantis/&#x27;, group: &#x27;link&#x27;&#125; darkMode: - &#123;id: &#x27;darkMode&#x27;, name: &#x27;暗黑模式&#x27;, icon: &#x27;fa-solid fa-moon&#x27;, event: &#x27;volantis.dark.toggle()&#x27;, group: &#x27;darkMode&#x27;&#125;### 高级玩法可以利用 Custom Files 自定义文件 功能，实现自定义右键菜单脚本及菜单项控制。 一个在右键菜单中添加 查看上一篇、查看下一篇 菜单项的范例： blog/_config.volantis.ymlblog/source/_volantis/bodyEnd.ejs省略了部分不相关内容1234567rightmenus: order: - menus.prevNext menus: prevNext: - &#123;id: &#x27;prev&#x27;, name: &#x27;查看上一篇&#x27;, icon: &#x27;fa-solid fa-angles-left&#x27;, event: &quot;volantis.rightmenu.jump(&#x27;prev&#x27;)&quot;, group: &#x27;prevNext&#x27;&#125; - &#123;id: &#x27;next&#x27;, name: &#x27;查看下一篇&#x27;, icon: &#x27;fa-solid fa-angles-right&#x27;, event: &quot;volantis.rightmenu.jump(&#x27;next&#x27;)&quot;, group: &#x27;prevNext&#x27;&#125;为了方便管理，将函数挂在 volantis.rightmenu 对象下12345678910111213141516171819202122232425&lt;script&gt; volantis.rightmenu.jump = (type) =&gt; &#123; const selector = type === &#x27;prev&#x27; ? &#x27;article .prev-next a.prev&#x27; : &#x27;article .prev-next a.next&#x27;; const item = document.querySelector(selector); if(!!item) &#123; if(typeof pjax !== &#x27;undefined&#x27;) &#123; pjax.loadUrl(item.href) &#125; else &#123; window.location.href = item.href; &#125; &#125; &#125; volantis.rightmenu.handle(() =&gt; &#123; const prev = document.querySelector(&#x27;#prev&#x27;).parentElement, next = document.querySelector(&#x27;#next&#x27;).parentElement, articlePrev = document.querySelector(&#x27;article .prev-next a.prev p.title&#x27;), articleNext = document.querySelector(&#x27;article .prev-next a.next p.title&#x27;); prev.style.display = articlePrev ? &#x27;block&#x27; : &#x27;none&#x27;; prev.title = articlePrev ? articlePrev.innerText : null; next.style.display = articleNext ? &#x27;block&#x27; : &#x27;none&#x27;; next.title = articleNext ? articleNext.innerText : null; &#125;, &#x27;prevNext&#x27;, false) &lt;/script&gt; 老版右键菜单目前老版右键与新版右键共存，但同时只能开启一个自定义右键菜单。 配置文件 blog/_config.volantis.yml 1234567891011121314151617181920212223242526272829303132333435363738394041424344# 自定义右键菜单rightmenu: enable: false faicon: fa # 公共图标类型 fa fal fa-solid fa-duotone # hr: 分割线, music: 音乐控制器 layout: [home, hr, help, examples, contributors, hr, source_docs, source_theme, hr, print, darkmode, reading, music] ### 可选功能项 ### print: # 只有文章页才允许自定义打印 name: 打印页面 icon: fa fa-print darkmode: # 需开启 plugins.darkmodejs name: 暗黑模式 icon: fa fa-moon reading: name: 阅读模式 icon: fa fa-book-open customPicUrl: # 右键的图片复制：只有 Chrome 支持，且只支持 PNG 格式的图片。 enable: false # 如果使用了对象存储且开启了自适应 Webp，那么可以提供额外的链接用以替换图片的访问地址 old: #https://static.inkss.cn/img/article/ new: #https://cdn.jsdelivr.net/gh/inkss/inkss-cdn@master/img/article/ music: # 当设定全局音乐播放器时，是否一直显示音乐控制菜单。false：仅当音乐播放时启用 alwaysShow: true ### 自定义菜单 ### help: name: 常见问题 icon: fa fa-question url: https://volantis.js.org/faqs/ examples: name: 示例博客 icon: fa fa-rss url: https://volantis.js.org/examples/ contributors: name: 加入社区 icon: fa fa-fan fa-spin url: https://volantis.js.org/contributors/ source_docs: name: 本站源码 icon: fa fa-code-branch url: https://github.com/volantis-x/volantis-docs/ source_theme: name: 主题源码 icon: fa fa-code-branch url: https://github.com/volantis-x/hexo-theme-volantis/#### 设置网站导航栏导航栏配置导航栏分为 logo、menu、search 三个区域设置，其中 logo 区域如果设置了图片，则不能显示图标和标题， menu 区域的设置可以写在一个单独的文件中。 blog/_config.volantis.yml123456789101112131415161718192021222324252627# 注意事项：建议规范全站路径 URL 最后带一个 &quot;/&quot; 例如 &quot;about/&quot;navbar: visiable: auto # always, auto logo: # choose [img] or [icon + title] img: volantis-static/media/org.volantis/blog/Logo-NavBar@3x.png # https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/Logo-NavBar@3x.png icon: title: menu: - name: 博客 icon: fa-solid fa-rss url: / - name: 分类 icon: fa-solid fa-folder-open url: categories/ - name: 标签 icon: fa-solid fa-tags url: tags/ - name: 归档 icon: fa-solid fa-archive url: archives/ - name: 友链 icon: fa-solid fa-link url: friends/ - name: 关于 icon: fa-solid fa-info-circle url: about/ search: Search... # Search bar placeholder 菜单嵌套导航栏菜单支持嵌套，嵌套的属性名为 rows ，写法示例： 123456789101112131415161718192021222324...- name: 更多 icon: fa-solid fa-ellipsis-v rows: - name: 主题源码 url: https://github.com/volantis-x/hexo-theme-volantis/ - name: 更新日志 url: https://github.com/volantis-x/hexo-theme-volantis/releases/ - name: hr - name: 有疑问？ rows: - name: 看 FAQ url: faqs/ - name: 看 本站源码 url: https://github.com/volantis-x/volantis-docs/ - name: 提 Issue url: https://github.com/volantis-x/hexo-theme-volantis/issues/ - name: hr - name: 公告和测试博文 url: archives/ - name: 示例博客 url: examples/ - name: 特别感谢 url: contributors/ 分割线在子菜单中，新增一个只有 name: hr 的“菜单”就会被渲染成一个分割线。 1- name: hr 小标题在子菜单中，新增一个只有 name: 小标题内容（也可以有 icon: 小标题的图标）的“菜单”就会被渲染成一个小标题。 12345678910111213...- name: 近期 icon: fa-solid fa-clock url: / rows: - name: 热门文章 icon: fa-solid fa-fire - name: ProHUD 开源库的设计思路 url: blog/2019-08-27-prohud/ - name: ValueX：实用的安全对象类型转换库 url: blog/2019-08-29-valuex/ - name: 心率管家 App 的设计与开发 url: blog/2019-07-23-heartmate/ 播放器在子菜单中，新增一个 icon: fa-solid fa-compact-disc 的“菜单”就会被渲染成一个 APlayer 播放器。 12- name: 背景音乐 icon: fa-solid fa-compact-disc 设置网站页脚您通过 layout 可以自由布局网站页脚内容 aplayer, social, license, info, copyright。 blog/_config.volantis.yml123456789101112131415site_footer: # layout of footer: [aplayer, social, license, info, copyright] layout: [aplayer, social, license, info, copyright] social: - icon: fas fa-rss url: atom.xml - icon: fas fa-envelope url: mailto:me@xaoxuu.com - icon: fab fa-github url: https://github.com/xaoxuu - icon: fas fa-headphones-alt url: https://music.163.com/#/user/home?id=63035382 copyright: &#x27;[Copyright © 2017-2021 XXX](/)&#x27; # You can add your own property here. (Support markdown, for example: br: &#x27;&lt;br&gt;&#x27;) br: &#x27;&lt;br&gt;&#x27; 其中，aplayer 需要在插件部分设置中启用。您可以新增文字属性，用于展示其它文字信息，例如： blog/_config.volantis.yml123456site_footer: layout: [..., br, hello, ...] ... # You can add your own property here. (Support markdown, for example: br: &#x27;&lt;br&gt;&#x27;) br: &#x27;&lt;br&gt;&#x27; hello: &#x27;[Hello World](/)&#x27; 网站与文章封面封面高度blog/_config.volantis.yml123cover: height_scheme: full # full, half ... 目前主题提供两种首页封面高度方案，其它页面均为半屏幕高度。 封面布局方案blog/_config.volantis.yml1234cover: ... scheme: dock # search (搜索), dock (坞), featured (精选), focus (焦点) ... 布局方案 适合场景 search 注重搜索 dock 入口选项比较多 featured 选项在4个左右 focus 选项在4个左右 默认显示设置blog/_config.volantis.yml123456cover: ... display: home: true archive: false others: false # can be written in front-matter &#x27;cover: true&#x27; 由于主页、归档是 hexo 自动生成的，您需要在主题配置文件中设置是否显示封面，而其它页面则可以在 front-matter 中通过设置 cover: true/false 来决定显示封面或者不显示封面。 文章布局配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105# 文章布局article: # 文章列表页面的文章卡片布局方案 preview: scheme: landscape # landscape # pin icon for post pin_icon: https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f4cc.svg # auto generate title if not exist auto_title: true # false, true # auto generate excerpt if not exist auto_excerpt: true # false, true # show split line or not line_style: solid # hidden, solid, dashed, dotted # show readmore button readmore: auto # auto, always # 文章详情页面的文章卡片本体布局方案 body: # 文章顶部信息 # 从 meta_library 中取 top_meta: [author, category, date, counter] # ---------------- # 文章页脚组件 footer_widget: # ---------------- # 参考资料、相关资料等 (for layout: post/docs) references: title: 参考资料 icon: fas fa-quote-left # 在 front-matter 中: # references: # - title: 某篇文章 # url: https:// # 即可显示此组件。 # ---------------- # 相关文章，需要安装插件 (for layout: post) # npm i hexo-related-popular-posts related_posts: enable: false title: 相关文章 icon: fas fa-bookmark max_count: 5 # 设为空则不使用文章头图 placeholder_img: https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/046.jpg # ---------------- # 版权声明组件 (for layout: post/docs) copyright: enable: true permalink: &#x27;本文永久链接是：&#x27; content: - &#x27;博客内容遵循 署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议&#x27; - permalink # ---------------- # 打赏组件 (for layout: post/docs) donate: enable: false images: - https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/qrcode/github@volantis.png - https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/qrcode/github@volantis.png # 文章底部信息 # 从 meta_library 中取 bottom_meta: [updated, tags, share] # meta library meta_library: # 默认文章作者（可在 front-matter 中覆盖） author: avatar: name: 请设置文章作者 url: / # 文章创建日期 date: icon: fas fa-calendar-alt title: &#x27;发布于：&#x27; format: &#x27;ll&#x27; # 日期格式 http://momentjs.com/docs/ # 文章更新日期 updated: icon: fas fa-edit title: &#x27;更新于：&#x27; format: &#x27;ll&#x27; # 日期格式 http://momentjs.com/docs/ # 文章分类 category: icon: fas fa-folder-open # 文章浏览计数 counter: icon: fas fa-eye unit: &#x27;次浏览&#x27; # 文章字数和阅读时长 wordcount: icon_wordcount: fas fa-keyboard icon_duration: fas fa-hourglass-half # 文章标签 tags: icon: fas fa-hashtag # 分享 share: - id: qq img: https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/qq.png - id: qzone img: https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/qzone.png - id: weibo img: https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/weibo.png - id: # qrcode # 当id为qrcode时需要安装插件 npm i hexo-helper-qrcode img: # https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/wechat.png - id: # telegram img: # https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/telegram.png 其中 top_meta 和 bottom_meta 部分的取值自 meta_library 库。 侧边栏配置侧边栏小组件与 meta 库不同的是：除了现有的 widget ，您可以很轻易地创建自己的 widget ，然后放在需要的地方。此外，您还可以将 widget 写在单独的文件中。 查看所有相关配置 blog/_config.volantis.yml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899sidebar: # 主页、分类、归档等独立页面 for_page: [blogger, category, tagcloud, qrcode] # layout: docs/post 这类文章页面 for_post: [toc] # 侧边栏组件库 widget_library: # --------------------------------------- # blogger info widget blogger: class: blogger display: [desktop, mobile] # [desktop, mobile] avatar: https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/Logo-NavBar@3x.png shape: rectangle # circle, rectangle url: /about/ title: subtitle: jinrishici: true # Poetry Today. You can set a string, and it will be displayed when loading fails. social: true # --------------------------------------- # toc widget (valid only in articles) toc: class: toc display: [desktop, mobile] # [desktop, mobile] header: icon: fas fa-list title: 本文目录 list_number: false min_depth: 2 max_depth: 5 # --------------------------------------- # category widget category: class: category display: [desktop] # [desktop, mobile] header: icon: fas fa-folder-open title: 文章分类 url: /blog/categories/ # --------------------------------------- # tagcloud widget tagcloud: class: tagcloud display: [desktop, mobile] # [desktop, mobile] header: icon: fas fa-tags title: 热门标签 url: /blog/tags/ min_font: 14 max_font: 24 color: true start_color: &#x27;#999&#x27; end_color: &#x27;#555&#x27; # --------------------------------------- # qrcode widget donate: class: qrcode display: [desktop, mobile] # [desktop, mobile] height: 64px # Automatic height if not set images: - https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/qrcode/github@volantis.png - https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/qrcode/github@volantis.png # --------------------------------------- # webinfo widget webinfo: class: webinfo display: [desktop] header: icon: fa-solid fa-award title: 站点信息 type: article: enable: true text: &#x27;文章数目：&#x27; unit: &#x27;篇&#x27; runtime: enable: true data: &#x27;2020/01/01&#x27; # 填写建站日期 text: &#x27;已运行时间：&#x27; unit: &#x27;天&#x27; wordcount: enable: true text: &#x27;本站总字数：&#x27; # 需要启用 wordcount unit: &#x27;字&#x27; visitcounter: siteuv: enable: true text: &#x27;本站访客数：&#x27; unit: &#x27;人&#x27; sitepv: enable: true text: &#x27;本站总访问量：&#x27; unit: &#x27;次&#x27; lastupd: enable: true friendlyShow: true # 更友好的时间显示 text: &#x27;最后活动时间：&#x27; unit: &#x27;日&#x27; 每一个小部件都有 class 和 display，前者代表这个小部件是什么，后者代表这个小部件在什么桌面和移动平台中是否显示，如果在移动平台显示，由于屏幕宽度有限，侧边栏的小部件则会被移动到正文区域下方，因此部分侧边栏小部件便失去意义，建议设置为仅桌面端显示。 1234小部件名: class: 小部件类别 display: [小部件在桌面端是否显示, 小部件在移动设备是否显示] pjaxReload: true # 是否 pjax 重载 默认 true; 设置为 false 时 确保所有页面都含有该小部件 博主信息部件blog/_config.volantis.yml12345678blogger: class: blogger display: [desktop] # [desktop, mobile] avatar: https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png title: subtitle: jinrishici: true # Poetry Today. You can set a string, and it will be displayed when loading fails. social: true 其中，今日诗词 jinrishici 如果设置为一个字符串，这个字符串会变成占位文字，加载失败时显示。如果不需要，就请设置为 jinrishici: false。social 的具体内容请在网站页脚部分设置。 文章目录部件blog/_config.volantis.yml123456789toc: class: toc display: [desktop, mobile] # [desktop, mobile] header: icon: fas fa-list title: 本文目录 list_number: false min_depth: 2 max_depth: 5 这个部件只能放置在侧边栏，并且在文章中有效。在移动设备中预览时，手指向上滑动时，导航栏右边会出现 TOC 按钮，点击即可展开 TOC 部件。如果您需要显示章节序号，请设置 list_number。 min_depth 和 max_depth 代表 TOC 支持的标题层级，最大范围是2～6。 文章分类部件blog/_config.volantis.yml1234567category: class: category display: [desktop] # [desktop, mobile] header: icon: fas fa-folder-open title: 文章分类 url: /blog/categories/ 这个部件可以直接显示所有文章分类，如果您希望有一个独立的页面来展示，需要自己创建一个文件，具体操作在「页面」部分文档中。 标签云部件blog/_config.volantis.yml123456789101112tagcloud: class: tagcloud display: [desktop] # [desktop, mobile] header: icon: fas fa-tags title: 热门标签 url: /blog/tags/ min_font: 14 max_font: 24 color: true start_color: &#x27;#999&#x27; end_color: &#x27;#555&#x27; 这个部件可以直接显示所有文章的标签，如果您希望有一个独立的页面来展示，需要自己创建一个文件，具体操作在「页面」部分文档中。 二维码部件blog/_config.volantis.yml1234567donate: class: qrcode display: [desktop, mobile] # [desktop, mobile] height: 64px # Automatic height if not set images: - https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/qrcode/github@volantis.png - https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/qrcode/github@volantis.png 您可以放置在文章页脚用于展示打赏图片，也可以放置在侧边栏。 通用文本部件blog/_config.volantis.yml123456789101112repos: class: text display: [desktop] # [desktop, mobile] header: icon: fab fa-github title: 点个赞吧 url: https://github.com/xaoxuu/ content: - &#x27;您的赞对我来说很重要，如果您喜欢本主题，希望能够给下面的项目点个赞来支持一下。&#x27; - &#x27;[&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/proj/prohud/logo.png&quot; height=&quot;50px&quot;&gt;](https://github.com/xaoxuu/ProHUD)&#x27; - &#x27;[&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/proj/valuex/logo.png&quot; height=&quot;50px&quot;&gt;](https://github.com/xaoxuu/ValueX)&#x27; - &#x27;[&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/proj/inspire/logo.png&quot; height=&quot;50px&quot;&gt;](https://github.com/xaoxuu/Inspire)&#x27; 您可以创建用于展示任何文本内容的文本部件。 通用列表部件blog/_config.volantis.yml123456789101112wiki-hexo-theme: class: list display: [desktop, mobile] # [desktop, mobile] header: icon: fas fa-chevron-left title: Hexo Themes url: /wiki/ rows: - name: Volantis for Hexo url: /wiki/volantis/ - name: Resume for Hexo url: /wiki/resume/ 您可以创建用于展示任何链接列表的列表部件。列表的 rows 中的每一项支持的属性有： name、url、icon、img、avatar，其中 img 是方形图片的链接，avatar 是圆形图片的链接。 组索引这个部件的布局继承自 list 部件，用于展示文章所属的分组的文章列表。请将您的 Volantis 升级至 2.5 版本以上使用。 blog/_config.volantis.yml1234567group-1: class: group display: [desktop, mobile] # [desktop, mobile] header: icon: fab fa-github title: Git url: /wiki/git/ 在文章的 front-matter 中设置： front-matter123group: group-1order: 16sidebar: [group-1, toc] 「group-1」卡片将会以列表的形式显示所有设置了 group: group-1 的文章，顺序按照 order 从小到大排列。 通用网格部件blog/_config.volantis.yml123456789101112131415161718feedback: class: grid display: [desktop, mobile] header: icon: fas fa-headset title: 联系开发者 url: https://github.com/volantis-x/hexo-theme-volantis fixed: true # 固定宽度 rows: - name: 反馈BUG icon: fas fa-bug url: https://github.com/volantis-x/hexo-theme-volantis/issues/ - name: 疑问求助 icon: fas fa-question-circle url: https://github.com/volantis-x/hexo-theme-volantis/issues/ - name: 提个建议 icon: fas fa-lightbulb url: https://github.com/volantis-x/hexo-theme-volantis/issues/ 您可以创建用于展示任何链接列表的网格部件。网格默认根据文字长度自动确定每一个格子的宽度，如果文字长短不一，建议通过设置 fixed: true 来固定宽度，此时文字过长的格子中的文字会换行显示。 通用页面部件blog/_config.volantis.yml12345test: class: page display: [desktop, mobile] pid: haha content: excerpt # excerpt, more, content 您可以把整个页面的md内容作为一个小部件渲染显示出来。只需要设置小部件里的 pid 属性和文章的 front-matter 中设置一样的 pid 即可。 content 代表这个部件显示的内容，可选 excerpt，more，content 分别对应文章的摘要、摘要后面的内容、全文。 音乐部件blog/_config.volantis.yml1234music: class: music display: [desktop, mobile] # [desktop, mobile] pjaxReload: false 选择评论系统目前共支持 14 款评论系统： artalk, giscus, beaudar, utterances, twikoo, waline, discuss, disqus, disqusjs, gitalk, vssue, livere, isso, hashover blog/_config.volantis.yml1234comments: title: &lt;i class=&#x27;fas fa-comments&#x27;&gt;&lt;/i&gt; 评论 subtitle: service: giscus GitHub Discussions 系列 giscus A comments system powered by GitHub Discussions. https://giscus.app/blog/_config.volantis.yml123456789101112131415161718192021comments: ... service: giscus ... # giscus # https://giscus.app # https://github.com/laymonage/giscus giscus: # 以下配置按照 yml 格式增删填写即可 # repo: xxx/xxx # repo-id: xxx # category: xxx # category-id: xxx # mapping: &quot;pathname&quot; # reactions-enabled: &quot;1&quot; # emit-metadata: &quot;0&quot; # lang: &quot;zh-CN&quot; # 以上配置按照 yml 格式增删填写即可 theme: light: &quot;light&quot; # https://cdn.jsdelivr.net/gh/volantis-x/cdn-volantis@master/css/giscus/light.css dark: &quot;dark&quot; # https://cdn.jsdelivr.net/gh/volantis-x/cdn-volantis@master/css/giscus/dark.css GitHub Issues 系列 beaudarutterancesVssueGitalk Beaudar 名称源于粤语“表达”的发音，是 Utterances 的中文版本。 https://beaudar.lipk.org/blog/_config.volantis.yml1234567891011121314151617comments: ... service: beaudar ... # beaudar # https://beaudar.lipk.org/ beaudar: repo: xxx/xxx issue-term: pathname issue-number: branch: main position: top order: desc theme: light: github-light dark: github-dark label: ✨💬✨ A lightweight comments widget built on GitHub issues. https://utteranc.es/blog/_config.volantis.yml1234567891011121314comments: ... service: utterances ... # utterances # https://utteranc.es/ utterances: repo: xxx/xxx issue-term: pathname issue-number: theme: light: github-light dark: github-dark label: ✨💬✨ Vue 驱动的、基于 Issue 的评论插件 https://vssue.js.org/zh/blog/_config.volantis.yml123456789comments: ... service: vssue ... vssue: owner: repo: clientId: clientSecret: A modern comment component based on Github Issue and Preact. https://gitalk.github.io/blog/_config.volantis.yml12345678910comments: ... service: gitalk ... gitalk: clientID: clientSecret: repo: owner: admin: # []clientID 和 clientSecret 的获取方法可自行搜索教程，这里仅简单描述一下步骤：点击 GitHub -&gt; Settings https://github.com/settings/profile点击 Developer settings https://github.com/settings/developers点击 New OAuth App https://github.com/settings/applications/new填写信息：Application name 随便填，我的是：xaoxuu.comHomepage URL 和 Authorization callback URL 都写你的网址，我的是：https://xaoxuu.com可以通过设置 gitalk.id 实现多个页面共用一个评论框。front-matter1234---gitalk: id: /wiki/volantis/--- Disqus 系列 DisqusDisqusJSIsso Disqus - The #1 way to build an audience on your website. https://disqus.com/blog/_config.volantis.yml123456comments: ... service: disqus ... disqus: shortname:可以通过设置 disqus.path 实现多个页面共用一个评论框。front-matter1234---disqus: path: /wiki/volantis/--- Render Disqus comments in Mainland China using Disqus API https://github.com/SukkaW/DisqusJSblog/_config.volantis.yml1234567891011121314comments: ... service: disqusjs ... # DisqusJS # https://github.com/SukkaW/DisqusJS disqusjs: path: # 全局评论地址 # 配置项按照yml格式继续填写即可 除了 [siteName url identifier] 选项 #shortname: #api: #apikey: #admin: #nesting: A commenting server similar to Disqus. https://posativ.org/isso/blog/_config.volantis.yml1234567comments: ... service: isso ... isso: url: https://example.com/(path/) src: https://example.com/(path/)js/embed.min.js Valine 衍生系列 Valine 在 5.0 版本被移除,具体原因可参考hexo-theme-next#188#issuecomment-766578906以下是在解决 valine 遗留问题同一时期产生的评论系统故归为一类, 然在其社区issue中也报告了类似的攻击事件(eg: twikoo#157 waline#424 waline#430),故请谨慎选择.discusstwikooWaline 一款简单，安全，免费的评论系统 | A simple, safe, free comment system https://discuss.js.orgblog/_config.volantis.yml12345678910comments: ... service: discuss ... # Discuss # https://discuss.js.org discuss: js: https://cdn.jsdelivr.net/npm/discuss/dist/Discuss.js # 建议锁定版本 serverURLs: # Discuss server address url # https://discuss.js.org/Quick-Start.html#path其中，placeholder 支持在 front-matter 中设置。front-matter1234---discuss: placeholder: 你觉得xxx怎么样呢？---也可以通过设置 discuss.path 实现多个页面共用一个评论框。front-matter1234---discuss: path: /--- 一个简洁、安全、免费的静态网站评论系统 | A simple, safe, free comment system. https://twikoo.js.org/blog/_config.volantis.yml123456789comments: ... service: twikoo ... twikoo: js: https://cdn.jsdelivr.net/npm/twikoo@latest # 建议锁定版本 path: # 全局评论地址 # 其他配置项按照yml格式继续填写即可 除了 [el path] 选项 envId: xxxxxxxxxxxxxxx # 腾讯云环境id其中，placeholder 支持在 front-matter 中设置。front-matter1234---twikoo: placeholder: 你觉得xxx怎么样呢？---也可以通过设置 twikoo.path 实现多个页面共用一个评论框。front-matter1234---twikoo: path: /--- 一个简洁、安全、免费的静态网站评论系统 | A simple, safe, free comment system. https://waline.js.org/blog/_config.volantis.yml1234567891011121314comments: ... service: waline ... # Waline # https://waline.js.org/ waline: js: https://cdn.jsdelivr.net/npm/@waline/client/dist/Waline.min.js path: # 全局评论地址 目前设置全局评论地址后visitor失效,这是waline的问题 placeholder: 快来评论吧~ # 评论占位提示 imageHosting: https://7bu.top/api/upload # 图床api（默认使用去不图床） # 其他配置项按照yml格式继续填写即可 除了 [el path placeholder uploadImage] 选项 serverURL: xxxxxxxxxxxxxxx # Waline 的服务端地址（必填） 测试用地址: https://waline-ruddy.vercel.app ... 可选配置项详见源码其中，placeholder 支持在 front-matter 中设置。front-matter1234---waline: placeholder: 你觉得xxx怎么样呢？---也可以通过设置 waline.path 实现多个页面共用一个评论框。front-matter1234---waline: path: /--- Others 其他系列 ArtalkLivereHashoverMore... 一款简洁的自托管评论系统 | A Selfhosted Comment System. https://artalk.js.org/blog/_config.volantis.yml12345678comments: ... service: artalk ... artalk: js: https://cdn.jsdelivr.net/npm/artalk@2.1.3/dist/Artalk.js css: https://cdn.jsdelivr.net/npm/artalk@2.1.3/dist/Artalk.css server: http://127.0.0.1:8080/api # 修改为自建的后端服务地址其中，placeholder 支持在 front-matter 中设置。front-matter1234---artalk: placeholder: 你觉得xxx怎么样呢？---也可以通过设置 artalk.path 实现多个页面共用一个评论框。front-matter1234---artalk: path: /--- Communication makes better world. https://www.livere.com/blog/_config.volantis.yml123456comments: ... service: livere ... livere: uid: #你的livere的uid在这里查看你的 uid：https://livere.com/insight/myCode，在【代码管理 -&gt; 一般网站】中找到如下这段代码，其中 data-uid 中的内容就是你的 livere_uid。123&lt;!-- 来必力City版安装代码 --&gt;&lt;div id=&quot;lv-container&quot; data-id=&quot;city&quot; data-uid=&quot;你的livere的uid&quot;&gt;... A free and open source PHP comment system designed to allow completely anonymous comments and easy theming. https://www.barkdull.org/software/hashoverblog/_config.volantis.yml123456comments: ... service: hashover ... hashover: src: https://example.com/(path/)comments.phpblog/themes/volantis/layout/_third-party/comments/评论系统名称/layout.ejs1这里写布局代码blog/themes/volantis/layout/_third-party/comments/评论系统名称/script.ejs1这里要写加载 js 的代码收录更多评论系统 可以通过在 front-matter 设置 config 实现在特定页面修改评论系统的相关配置。 支持的有(按字母顺序): discuss, giscus, gitalk, twikoo, waline front-matter12345---gitalk: config: id: /233/--- 站内搜索blog/_config.volantis.yml1234search: enable: true service: hexo # hexo js: https://cdn.jsdelivr.net/xxxxxxxx/js/search/hexo.js 默认配置为 Hexo 搜索，但是需要安装插件才能使用： 1npm i -S hexo-generator-json-content 原 google, algolia, azure, baidu 站内搜索 系祖传代码, 且文档丢失, 不便后续维护 在 5.0 版本移除 插件库概述Volantis 为丰富的插件提供了兼容性优化。大部分插件您只需开启和关闭，无需进行设置。 幻灯片背景(视差滚动效果)jquery.backstretch 在 5.0 版本 移除, 被 parallax 替代 blog/_config.volantis.yml1234567891011plugins: ... parallax: enable: true position: cover # cover: sticky on the cover. fixed: Fixed as background for the site. shuffle: true # shuffle playlist duration: 10000 # Duration (ms) fade: 1500 # fade duration (ms) (Not more than 1500) images: # For personal use only. At your own risk if used for commercial purposes !!! - https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper/abstract/41F215B9-261F-48B4-80B5-4E86E165259E.jpeg ... 幻灯片背景图片显示的位置可以选择粘贴在封面上，跟随封面一起滑动，也可以选择固定作为网页背景图片。 highlight.jsblog/_config.volantis.yml1234567891011plugins: ... # 代码高亮 code_highlight: highlightjs # highlightjs or prismjs # highlight.js highlightjs: copy_code: true # 如果开启 js, hexo.config.highlight.enable 需要设置为 false js: #https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.1.0/build/highlight.min.js # Please set hexo.config.highlight.enable = false !!! css: https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.1.0/build/styles/default.min.css # more: https://www.jsdelivr.com/package/npm/highlight.js?path=styles 如果需要使用 highlight.js 进行语法高亮，请将站点配置文件中的 highlight.enable 设置为 false 否则不会加载插件。您可以在 94 种 语法高亮主题 中挑选喜爱的主题，然后替换上面的 css 链接。 如果您使用 highlight.js 请确保没有使用 hexo 官方的 codeblock 标签，否则会报错。 经测试，使用 highlight.js 的情况下，部分容器内的代码可能仍然会被渲染甚至报错。 APlayer 音乐播放器blog/_config.volantis.yml12345678910111213141516171819202122plugins: ... # APlayer is only available in mainland China. # APlayer config: https://github.com/metowolf/MetingJS aplayer: enable: true js: aplayer: https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.js meting: https://cdn.jsdelivr.net/npm/meting@2.0/dist/Meting.min.js # Required server: netease # netease, tencent, kugou, xiami, baidu type: playlist # song, playlist, album, search, artist id: 3175833810 # song id / playlist id / album id / search keyword # Optional fixed: false # enable fixed mode theme: &#x27;#1BCDFC&#x27; # main color autoplay: false # audio autoplay order: list # player play order, values: &#x27;list&#x27;, &#x27;random&#x27; loop: all # player loop play, values: &#x27;all&#x27;, &#x27;one&#x27;, &#x27;none&#x27; volume: 0.7 # default volume, notice that player will remember user setting, default volume will not work after user set volume themselves list_max_height: 320px # list max height list_folded: true APlayer播放器只可以在中国大陆地区使用。相关文档： APlayer | MetingJS 暗黑模式blog/_config.volantis.yml123456789plugins: ... # 暗黑模式 darkmode # 开关按钮：在 navbar.menu 中添加： # - name: 暗黑模式 # 可自定义 # icon: fas fa-moon # 可自定义 # toggle: darkmode darkmode: enable: true 结束支持blog/_config.volantis.yml12345678910111213plugins: ... # 旧版 Internet Explorer 淘汰行动 # https://www.microsoft.com/zh-cn/WindowsForBusiness/End-of-IE-support # 本主题不支持Internet Explorer的任何版本!!! killOldVersionsOfIE: enable: true # 禁用JavaScript提示 # 本页面需要浏览器支持（启用）JavaScript # 主题中的某些插件必须启用JavaScript才能正常工作，例如开启scrollreveal如果禁用JavaScript会导致卡片消失 killNoScript: enable: true Artitalkblog/_config.volantis.yml1234567891011121314151617181920212223plugins: ... # Artitalk https://artitalk.js.org # 配置过程请参考：https://artitalk.js.org/doc.html # 使用过旧版本的请修改Leancloud shuoshuo class部分列名：https://artitalk.js.org/release.html # 除appID和appKEY外均为选填项 artitalk: # Set `plugins: [&quot;artitalk&quot;]` to enable in front-matter # 不支持 Pjax # 配置项按照yml格式继续填写即可 appId: ogP8qj3veMh0LFpFWMPOyF0X-MdYXbMMI # your appID appKey: nHXLd3N3Jgh460t2iRQKWAtr # your appKEY # serverURL: #leancloud绑定的api访问域名，使用国际版的话不需要填写 # lang: # 语言设置，zh为汉语，en为英语，es为西班牙语。默认为汉语 # pageSize: #每页说说的显示数量 # shuoPla: #在编辑说说的输入框中的占位符 # avatarPla: #自定义头像url的输入框的占位符 # motion: #加载动画的开关，1为开，0为关，默认为开 # bgImg: #说说输入框背景图片url # color1: #说说背景颜色1&amp;按钮颜色1 # color2: #说说背景颜色2&amp;按钮颜色2 # color3: #说说字体颜色 # cssUrl: #自定义css接口 BBtalkblog/_config.volantis.yml12345678910plugins: ... # BBtalk https://bb.js.org bbtalk: # Set `plugins: [&quot;bbtalk&quot;]` to enable in front-matter # 支持 Pjax js: https://cdn.jsdelivr.net/npm/bbtalk@0.1.5/dist/bbtalk.min.js # BBtalk.js appId: 0KzOX4vC7Jsk6vzUGNeEiUaI-gzGzoHsz # your appID appKey: HwCiWuxfpvKiLm4teCUgTIba # your appKEY serverURLs: https://bbapi.heson10.com # Request Api 域名 Tidioblog/_config.volantis.yml123456789plugins: ... # 聊天功能 chat_service: tidio # tidio or gitter # Tidio # https://www.tidio.com/ tidio: id: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx 友链朋友圈blog/_config.volantis.yml1234567891011121314plugins: ... # 友链朋友圈 hexo-circle-of-friends # https://github.com/Rock-Candy-Tea/hexo-circle-of-friends # https://zfe.space/post/friend-link-circle.html fcircle: # Set `plugins: [&quot;fcircle&quot;]` to enable in front-matter # 支持 Pjax api: &#x27;&#x27; # api 地址 max_number: 20 # 页面展示文章数量 add_number: 10 # 每次加载增加的篇数 opentype: &#x27;_blank&#x27; # &#x27;_blank&#x27;打开新标签,&#x27;_self&#x27;本窗口打开 nofollow: true # 禁止搜索引擎抓取 # loadingCutom: # 自定义loading图 例如: &lt;i class=&quot;fa fa-spinner fa-spin&quot;&gt;&lt;/i&gt; | &lt;img src=&quot;你的图片地址&quot; alt=&quot;加载中...&quot;&gt; 消息提示blog/_config.volantis.yml123456789101112131415161718192021222324252627282930313233plugins: ... # 消息提示 # izitoast@1.4.0 message: enable: true css: volantis-static/libs/izitoast/dist/css/iziToast.min.css js: volantis-static/libs/izitoast/dist/js/iziToast.min.js icon: # 默认图标，支持对图标添加颜色，可选值：see：/source/css/_style/_plugins/fontcolor.styl default: fa-solid fa-info-circle light-blue quection: fa-solid fa-question-circle light-blue time: # 默认持续时间 default: 5000 quection: 20000 position: &#x27;topRight&#x27; # 弹出位置 可选值：topRight, bottomRight, bottomLeft, topLeft, topCenter, bottomCenter, center transitionIn: &#x27;bounceInLeft&#x27; # 弹窗打开动画 可选值：bounceInLeft, bounceInRight, bounceInUp, bounceInDown, fadeIn, fadeInDown, fadeInUp, fadeInLeft, fadeInRight, flipInX transitionOut: &#x27;fadeOutRight&#x27; # 弹窗关闭动画 可选值：fadeOut, fadeOutUp, fadeOutDown, fadeOutLeft, fadeOutRight, flipOutX titleColor: &#x27;var(--color-text)&#x27; # 标题颜色 messageColor: &#x27;var(--color-text)&#x27; # 消息颜色 backgroundColor: &#x27;var(--color-card)&#x27; # 默认背景色 zindex: 2147483647 # 层级 copyright: # 是否在复制时弹出版权提示，影响范围：ctrl+c、代码块复制按钮、右键复制选项 enable: true title: &#x27;知识共享许可协议&#x27; message: &#x27;请遵守 CC BY-NC-SA 4.0 协议。&#x27; icon: &#x27;far fa-copyright light-blue&#x27; aplayer: # 是否开启音乐通知；播放、暂停、失败 时的图标 enable: true play: fa-solid fa-play pause: fa-solid fa-pause rightmenu: enable: true # 是否开启右键模块的消息通知 notice: true # 唤醒原右键菜单的通知 轮播标签使用方法参见：swiper blog/_config.volantis.yml1234swiper: enable: true css: https://unpkg.com/swiper@6/swiper-bundle.min.css js: https://unpkg.com/swiper@6/swiper-bundle.min.js","categories":[{"name":"前端","slug":"前端","permalink":"https://yaelcassini.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Github Pages","slug":"Github-Pages","permalink":"https://yaelcassini.github.io/tags/Github-Pages/"},{"name":"Hexo","slug":"Hexo","permalink":"https://yaelcassini.github.io/tags/Hexo/"},{"name":"Volantis","slug":"Volantis","permalink":"https://yaelcassini.github.io/tags/Volantis/"}]},{"title":"个人主页搭建流程","slug":"个人主页搭建流程","date":"2022-06-08T10:28:46.000Z","updated":"2023-05-15T09:08:11.652Z","comments":true,"path":"2022/06/08/个人主页搭建流程/","link":"","permalink":"https://yaelcassini.github.io/2022/06/08/%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5%E6%90%AD%E5%BB%BA%E6%B5%81%E7%A8%8B/","excerpt":"本网站建立依附于Github Pages，使用到的框架是Hexo（基于Node.js），使用的主题是Volantis，图床使用Github自行搭建。目前用到的外部支持有：Busuanzi、Giscus、Parallax等。","text":"本网站建立依附于Github Pages，使用到的框架是Hexo（基于Node.js），使用的主题是Volantis，图床使用Github自行搭建。目前用到的外部支持有：Busuanzi、Giscus、Parallax等。 搭建参考教程链接： https://zhuanlan.zhihu.com/p/60578464 https://zhuanlan.zhihu.com/p/111614119 主要步骤1. 安装Git和Node.js Git官网：https://nodejs.org/en/download/ 检查是否安装成功命令（cmd）：git--version Node.js官网：https://nodejs.org/en/download/ 检查是否安装成功命令（cmd）：node -v 和 npm -v 2. 本地部署Hexo博客0. 新建文件夹 空文件夹名：用户名.github.io（用户名为github用户名）1. 安装Hexo 右键Git Bash Here，输入命令：$ npm install hexo-cli -g 检查是否安装成功命令：hexo -v 安装一键部署插件：npm install hexo-deployer-git --save2. hexo初始化并安装依赖 hexo init npm install Hexo文件夹目录结构：3. 生成页面并本地预览 hexo g &amp;&amp; hexo s 切换端口号预览：hexo server -p 50004. 修改_config中的主题为volantis1theme: volantis 5. 下载Volantis主题，编译查看效果 安装主题：npm i hexo-theme-volantis 安装 Hexo 搜索的依赖包：npm i hexo-generator-search hexo-generator-json-content 安装 Stylus 渲染器：npm i hexo-renderer-stylus 6. 创建Volantis主题所需要的页面 参考链接：https://blog.csdn.net/qq_44161695/article/details/117648144 创建分类：hexo new page “categories”，并修改内容为： 1234567---layout: categoryindex: truetitle: 所有分类sidebar: [blogger]date: 2022-06-08 18:09:42--- 创建标签：hexo new page “tags”，并修改内容为： 1234567---layout: tagindex: truetitle: 所有标签sidebar: [blogger]date: 2022-06-08 18:10:12--- 创建关于我：hexo new page “about”，并修改内容为： 123456789---layout: docsseo_title: 关于bottom_meta: falsesidebar: []valine:placeholder: 有什么想对我说的呢？date: 2022-06-08 18:10:36--- 创建友链：hexo new page “friends” 7. 主题样式配置 新建_config.volantis.yaml，参考Volantis官网源码修改_config.volantis. yaml文件：https://github.com/volantis-x/community/blob/main/_config.volantis.yml 8. 常用命令12345678hexo new &quot;name&quot; # 新建文章hexo new page &quot;name&quot; # 新建页面hexo g # 生成页面hexo d # 部署hexo g -d # 生成页面并部署hexo s # 本地预览hexo clean # 清除缓存和已生成的静态文件hexo help # 帮助 9. tips Hexo 设置显示文章摘要，首页不显示全文 Hexo 主页文章列表默认会显示文章全文，浏览时很不方便，可以在文章中插入 &lt;!--more--&gt; 进行分段。 该代码前面的内容会作为摘要显示，而后面的内容会替换为 “Read More” 隐藏起来。 连接不上Github： https://blog.csdn.net/sinat_32017511/article/details/115762643 https://blog.csdn.net/Sheyami/article/details/121631887 另外 可以尝试在.git&#x2F;config中增加： 12[http] sslVerify = false 最终解决方案：旧设备也重新Clone（orz 3. 部署到Github Github官网：https://github.com/0. 创建仓库：仓库名：用户名.github.io1. 本地配置git username和git useremail12git config --global user.name &quot;Name&quot;git config --global user.email &quot;Email&quot; 2. SSH-key配置 参考链接：https://zhuanlan.zhihu.com/p/111614119 本地生成密钥： 1ssh-keygen -t rsa -C &quot;Email&quot; 打开：C:&#x2F;Users&#x2F;用户名&#x2F;.ssh&#x2F;id_rsa.pub，并全选复制。 在Github-Settings新建SSH，并粘贴。 本地输入以下命令检查是否成功连接： 1ssh -T git@github.com 3. 在_config.yaml中加入deploy配置123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:type: gitrepository: git@github.com:panakot/panakot.github.io.gitbranch: master 4. 部署网页并查看效果1hexo d 4. 使用github建立图床1. 新建Github仓库2. 下载图片并上传到Github仓库3. 通过链接访问图片 5. 配置插件1. 配置计数busuanzi2. 配置插件giscus： 官网：- https://giscus.app/zh-CN https://www.michaeltan.org/posts/giscus/ https://vuepress-theme-hope.github.io/v1/comment/zh/guide/giscus.html 6. 多设备管理源码 参考链接：https://www.zhihu.com/question/21193762/answer/103097754 https://blog.csdn.net/heimu24/article/details/81210640 https://zhangypcn.github.io/2020/07/04/Personal-Website-Hexo-Source-Management/ https://www.zhihu.com/question/21193762/answer/103097754 旧设备： Github新建仓库YealCassini_BlogCode，以使用git管理Hexo源码 将源码传到Github仓库 .gitignore: 1234567.DS_StoreThumbs.dbdb.json*.lognode_modules/public/.deploy*/ 新设备： 安装Git和Node.js 生成SSH key并添加到github git clone npm install npm install hexo-deployer-git –save 附录Icon网站 https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0.0/assets/svg/ https://unpkg.com/browse/volantis-static@0.0.1649552113628/media/org.volantis/icon/1322024-social-media/ https://fontawesome.com/icons?d=gallery","categories":[{"name":"前端","slug":"前端","permalink":"https://yaelcassini.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Github Pages","slug":"Github-Pages","permalink":"https://yaelcassini.github.io/tags/Github-Pages/"},{"name":"Hexo","slug":"Hexo","permalink":"https://yaelcassini.github.io/tags/Hexo/"},{"name":"Volantis","slug":"Volantis","permalink":"https://yaelcassini.github.io/tags/Volantis/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-06-08T10:00:00.000Z","updated":"2022-07-14T08:40:00.852Z","comments":true,"path":"2022/06/08/hello-world/","link":"","permalink":"https://yaelcassini.github.io/2022/06/08/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"Homework","slug":"Homework","permalink":"https://yaelcassini.github.io/categories/Homework/"},{"name":"Neural Rendering","slug":"Neural-Rendering","permalink":"https://yaelcassini.github.io/categories/Neural-Rendering/"},{"name":"Computer Graphics","slug":"Computer-Graphics","permalink":"https://yaelcassini.github.io/categories/Computer-Graphics/"},{"name":"Rendering","slug":"Rendering","permalink":"https://yaelcassini.github.io/categories/Rendering/"},{"name":"PathTracing","slug":"PathTracing","permalink":"https://yaelcassini.github.io/categories/PathTracing/"},{"name":"Deep Face Project","slug":"Deep-Face-Project","permalink":"https://yaelcassini.github.io/categories/Deep-Face-Project/"},{"name":"Others","slug":"Others","permalink":"https://yaelcassini.github.io/categories/Others/"},{"name":"TA-learning","slug":"TA-learning","permalink":"https://yaelcassini.github.io/categories/TA-learning/"},{"name":"Subsurface Scattering","slug":"Subsurface-Scattering","permalink":"https://yaelcassini.github.io/categories/Subsurface-Scattering/"},{"name":"前端","slug":"前端","permalink":"https://yaelcassini.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Computer Animation","slug":"Computer-Animation","permalink":"https://yaelcassini.github.io/tags/Computer-Animation/"},{"name":"Spline","slug":"Spline","permalink":"https://yaelcassini.github.io/tags/Spline/"},{"name":"KeyFrame","slug":"KeyFrame","permalink":"https://yaelcassini.github.io/tags/KeyFrame/"},{"name":"Neural Rendering","slug":"Neural-Rendering","permalink":"https://yaelcassini.github.io/tags/Neural-Rendering/"},{"name":"Rendering","slug":"Rendering","permalink":"https://yaelcassini.github.io/tags/Rendering/"},{"name":"anaconda","slug":"anaconda","permalink":"https://yaelcassini.github.io/tags/anaconda/"},{"name":"pytorch","slug":"pytorch","permalink":"https://yaelcassini.github.io/tags/pytorch/"},{"name":"Color","slug":"Color","permalink":"https://yaelcassini.github.io/tags/Color/"},{"name":"Color Space","slug":"Color-Space","permalink":"https://yaelcassini.github.io/tags/Color-Space/"},{"name":"Gamma Correction","slug":"Gamma-Correction","permalink":"https://yaelcassini.github.io/tags/Gamma-Correction/"},{"name":"Tone Mapping","slug":"Tone-Mapping","permalink":"https://yaelcassini.github.io/tags/Tone-Mapping/"},{"name":"PBR","slug":"PBR","permalink":"https://yaelcassini.github.io/tags/PBR/"},{"name":"Shadow","slug":"Shadow","permalink":"https://yaelcassini.github.io/tags/Shadow/"},{"name":"Shadow Map","slug":"Shadow-Map","permalink":"https://yaelcassini.github.io/tags/Shadow-Map/"},{"name":"PCF","slug":"PCF","permalink":"https://yaelcassini.github.io/tags/PCF/"},{"name":"PCSS","slug":"PCSS","permalink":"https://yaelcassini.github.io/tags/PCSS/"},{"name":"VSM","slug":"VSM","permalink":"https://yaelcassini.github.io/tags/VSM/"},{"name":"MSM","slug":"MSM","permalink":"https://yaelcassini.github.io/tags/MSM/"},{"name":"RayTracing","slug":"RayTracing","permalink":"https://yaelcassini.github.io/tags/RayTracing/"},{"name":"PathTracing","slug":"PathTracing","permalink":"https://yaelcassini.github.io/tags/PathTracing/"},{"name":"Monte Carlo","slug":"Monte-Carlo","permalink":"https://yaelcassini.github.io/tags/Monte-Carlo/"},{"name":"Deep Learing","slug":"Deep-Learing","permalink":"https://yaelcassini.github.io/tags/Deep-Learing/"},{"name":"Artificial Intelligent","slug":"Artificial-Intelligent","permalink":"https://yaelcassini.github.io/tags/Artificial-Intelligent/"},{"name":"Spherical Harmonics","slug":"Spherical-Harmonics","permalink":"https://yaelcassini.github.io/tags/Spherical-Harmonics/"},{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"https://yaelcassini.github.io/tags/Artificial-Intelligence/"},{"name":"GAN","slug":"GAN","permalink":"https://yaelcassini.github.io/tags/GAN/"},{"name":"Deep Fake","slug":"Deep-Fake","permalink":"https://yaelcassini.github.io/tags/Deep-Fake/"},{"name":"Notes","slug":"Notes","permalink":"https://yaelcassini.github.io/tags/Notes/"},{"name":"Technical Artist","slug":"Technical-Artist","permalink":"https://yaelcassini.github.io/tags/Technical-Artist/"},{"name":"Github Pages","slug":"Github-Pages","permalink":"https://yaelcassini.github.io/tags/Github-Pages/"},{"name":"Hexo","slug":"Hexo","permalink":"https://yaelcassini.github.io/tags/Hexo/"},{"name":"Volantis","slug":"Volantis","permalink":"https://yaelcassini.github.io/tags/Volantis/"}]}